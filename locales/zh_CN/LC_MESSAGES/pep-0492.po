# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0492.txt
msgid "PEP"
msgstr ""

#: ../../pep-0492.txt:1
msgid "492"
msgstr ""

#: ../../pep-0492.txt
msgid "Title"
msgstr ""

#: ../../pep-0492.txt:2
msgid "Coroutines with async and await syntax"
msgstr ""

#: ../../pep-0492.txt
msgid "Author"
msgstr ""

#: ../../pep-0492.txt:5
msgid "Yury Selivanov <yury@edgedb.com>"
msgstr ""

#: ../../pep-0492.txt
msgid "Discussions-To"
msgstr ""

#: ../../pep-0492.txt:6
msgid "<python-dev@python.org>"
msgstr ""

#: ../../pep-0492.txt
msgid "Status"
msgstr ""

#: ../../pep-0492.txt:7
msgid "Final"
msgstr ""

#: ../../pep-0492.txt
msgid "Type"
msgstr ""

#: ../../pep-0492.txt:8
msgid "Standards Track"
msgstr ""

#: ../../pep-0492.txt
msgid "Created"
msgstr ""

#: ../../pep-0492.txt:10
msgid "09-Apr-2015"
msgstr ""

#: ../../pep-0492.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0492.txt:11
msgid "3.5"
msgstr ""

#: ../../pep-0492.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0492.txt:12
msgid "17-Apr-2015, 21-Apr-2015, 27-Apr-2015, 29-Apr-2015, 05-May-2015"
msgstr ""

#: ../../pep-0492.txt:16
msgid "Abstract"
msgstr ""

#: ../../pep-0492.txt:18
msgid ""
"The growth of Internet and general connectivity has triggered the "
"proportionate need for responsive and scalable code.  This proposal aims "
"to answer that need by making writing explicitly asynchronous, concurrent"
" Python code easier and more Pythonic."
msgstr ""

#: ../../pep-0492.txt:23
msgid ""
"It is proposed to make *coroutines* a proper standalone concept in "
"Python, and introduce new supporting syntax.  The ultimate goal is to "
"help establish a common, easily approachable, mental model of "
"asynchronous programming in Python and make it as close to synchronous "
"programming as possible."
msgstr ""

#: ../../pep-0492.txt:29
msgid ""
"This PEP assumes that the asynchronous tasks are scheduled and "
"coordinated by an Event Loop similar to that of stdlib module "
"``asyncio.events.AbstractEventLoop``.  While the PEP is not tied to any "
"specific Event Loop implementation, it is relevant only to the kind of "
"coroutine that uses ``yield`` as a signal to the scheduler, indicating "
"that the coroutine will be waiting until an event (such as IO) is "
"completed."
msgstr ""

#: ../../pep-0492.txt:37
msgid ""
"We believe that the changes proposed here will help keep Python relevant "
"and competitive in a quickly growing area of asynchronous programming, as"
" many other languages have adopted, or are planning to adopt, similar "
"features: [2]_, [5]_, [6]_, [7]_, [8]_, [10]_."
msgstr ""

#: ../../pep-0492.txt:44
msgid "API Design and Implementation Revisions"
msgstr ""

#: ../../pep-0492.txt:46
msgid ""
"Feedback on the initial beta release of Python 3.5 resulted in a redesign"
" of the object model supporting this PEP to more clearly separate native "
"coroutines from generators - rather than being a new kind of generator, "
"native coroutines are now their own completely distinct type (implemented"
" in [17]_)."
msgstr ""

#: ../../pep-0492.txt:52
msgid ""
"This change was implemented based primarily due to problems encountered "
"attempting to integrate support for native coroutines into the Tornado "
"web server (reported in [18]_)."
msgstr ""

#: ../../pep-0492.txt:56
msgid "In CPython 3.5.2, the ``__aiter__`` protocol was updated."
msgstr ""

#: ../../pep-0492.txt:58
msgid ""
"Before 3.5.2, ``__aiter__`` was expected to return an *awaitable* "
"resolving to an *asynchronous iterator*.  Starting with 3.5.2, "
"``__aiter__`` should return asynchronous iterators directly."
msgstr ""

#: ../../pep-0492.txt:62
msgid ""
"If the old protocol is used in 3.5.2, Python will raise a "
"``PendingDeprecationWarning``."
msgstr ""

#: ../../pep-0492.txt:65
msgid ""
"In CPython 3.6, the old ``__aiter__`` protocol will still be supported "
"with a ``DeprecationWarning`` being raised."
msgstr ""

#: ../../pep-0492.txt:68
msgid ""
"In CPython 3.7, the old ``__aiter__`` protocol will no longer be "
"supported: a ``RuntimeError`` will be raised if ``__aiter__`` returns "
"anything but an asynchronous iterator."
msgstr ""

#: ../../pep-0492.txt:72
msgid "See [19]_ and [20]_ for more details."
msgstr ""

#: ../../pep-0492.txt:76
msgid "Rationale and Goals"
msgstr ""

#: ../../pep-0492.txt:78
msgid ""
"Current Python supports implementing coroutines via generators (PEP 342),"
" further enhanced by the ``yield from`` syntax introduced in PEP 380. "
"This approach has a number of shortcomings:"
msgstr ""

#: ../../pep-0492.txt:82
msgid ""
"It is easy to confuse coroutines with regular generators, since they "
"share the same syntax; this is especially true for new developers."
msgstr ""

#: ../../pep-0492.txt:85
msgid ""
"Whether or not a function is a coroutine is determined by a presence of "
"``yield``  or ``yield from`` statements in its *body*, which can lead to "
"unobvious errors when such statements appear in or disappear from "
"function body during refactoring."
msgstr ""

#: ../../pep-0492.txt:90
msgid ""
"Support for asynchronous calls is limited to expressions where ``yield`` "
"is allowed syntactically, limiting the usefulness of syntactic features, "
"such as ``with`` and ``for`` statements."
msgstr ""

#: ../../pep-0492.txt:94
msgid ""
"This proposal makes coroutines a native Python language feature, and "
"clearly separates them from generators.  This removes generator/coroutine"
" ambiguity, and makes it possible to reliably define coroutines without "
"reliance on a specific library.  This also enables linters and IDEs to "
"improve static code analysis and refactoring."
msgstr ""

#: ../../pep-0492.txt:100
msgid ""
"Native coroutines and the associated new syntax features make it possible"
" to define context manager and iteration protocols in asynchronous terms."
" As shown later in this proposal, the new ``async with`` statement lets "
"Python programs perform asynchronous calls when entering and exiting a "
"runtime context, and the new ``async for`` statement makes it possible to"
" perform asynchronous calls in iterators."
msgstr ""

#: ../../pep-0492.txt:109
msgid "Specification"
msgstr ""

#: ../../pep-0492.txt:111
msgid ""
"This proposal introduces new syntax and semantics to enhance coroutine "
"support in Python."
msgstr ""

#: ../../pep-0492.txt:114
msgid ""
"This specification presumes knowledge of the implementation of coroutines"
" in Python (PEP 342 and PEP 380).  Motivation for the syntax changes "
"proposed here comes from the asyncio framework (PEP 3156) and the "
"\"Cofunctions\" proposal (PEP 3152, now rejected in favor of this "
"specification)."
msgstr ""

#: ../../pep-0492.txt:120
msgid ""
"From this point in this document we use the word *native coroutine* to "
"refer to functions declared using the new syntax.  *generator-based "
"coroutine* is used where necessary to refer to coroutines that are based "
"on generator syntax.  *coroutine* is used in contexts where both "
"definitions are applicable."
msgstr ""

#: ../../pep-0492.txt:128
msgid "New Coroutine Declaration Syntax"
msgstr ""

#: ../../pep-0492.txt:130
msgid "The following new syntax is used to declare a *native coroutine*::"
msgstr ""

#: ../../pep-0492.txt:135
msgid "Key properties of *coroutines*:"
msgstr ""

#: ../../pep-0492.txt:137
msgid ""
"``async def`` functions are always coroutines, even if they do not "
"contain ``await`` expressions."
msgstr ""

#: ../../pep-0492.txt:140
msgid ""
"It is a ``SyntaxError`` to have ``yield`` or ``yield from`` expressions "
"in an ``async`` function."
msgstr ""

#: ../../pep-0492.txt:143
msgid "Internally, two new code object flags were introduced:"
msgstr ""

#: ../../pep-0492.txt:145
msgid ""
"``CO_COROUTINE`` is used to mark *native coroutines* (defined with new "
"syntax)."
msgstr ""

#: ../../pep-0492.txt:148
msgid ""
"``CO_ITERABLE_COROUTINE`` is used to make *generator-based coroutines* "
"compatible with *native coroutines* (set by `types.coroutine()`_ "
"function)."
msgstr ""

#: ../../pep-0492.txt:152
msgid ""
"Regular generators, when called, return a *generator object*; similarly, "
"coroutines return a *coroutine* object."
msgstr ""

#: ../../pep-0492.txt:155
msgid ""
"``StopIteration`` exceptions are not propagated out of coroutines, and "
"are replaced with a ``RuntimeError``.  For regular generators such "
"behavior requires a future import (see PEP 479)."
msgstr ""

#: ../../pep-0492.txt:159
msgid ""
"When a *native coroutine* is garbage collected, a ``RuntimeWarning`` is "
"raised if it was never awaited on (see also `Debugging Features`_)."
msgstr ""

#: ../../pep-0492.txt:163
msgid "See also `Coroutine objects`_ section."
msgstr ""

#: ../../pep-0492.txt:167
msgid "types.coroutine()"
msgstr ""

#: ../../pep-0492.txt:169
msgid ""
"A new function ``coroutine(fn)`` is added to the ``types`` module.  It "
"allows interoperability between existing *generator-based coroutines* in "
"asyncio and *native coroutines* introduced by this PEP::"
msgstr ""

#: ../../pep-0492.txt:178
msgid ""
"The function applies ``CO_ITERABLE_COROUTINE`` flag to generator- "
"function's code object, making it return a *coroutine* object."
msgstr ""

#: ../../pep-0492.txt:181
msgid ""
"If ``fn`` is not a *generator function*, it is wrapped.  If it returns a "
"*generator*, it will be wrapped in an *awaitable* proxy object (see below"
" the definition of awaitable objects)."
msgstr ""

#: ../../pep-0492.txt:185
msgid ""
"Note, that the ``CO_COROUTINE`` flag is not applied by "
"``types.coroutine()`` to make it possible to separate *native coroutines*"
" defined with new syntax, from *generator-based coroutines*."
msgstr ""

#: ../../pep-0492.txt:191
msgid "Await Expression"
msgstr ""

#: ../../pep-0492.txt:193
msgid ""
"The following new ``await`` expression is used to obtain a result of "
"coroutine execution::"
msgstr ""

#: ../../pep-0492.txt:200
msgid ""
"``await``, similarly to ``yield from``, suspends execution of "
"``read_data`` coroutine until ``db.fetch`` *awaitable* completes and "
"returns the result data."
msgstr ""

#: ../../pep-0492.txt:204
msgid ""
"It uses the ``yield from`` implementation with an extra step of "
"validating its argument.  ``await`` only accepts an *awaitable*, which "
"can be one of:"
msgstr ""

#: ../../pep-0492.txt:208
msgid "A *native coroutine* object returned from a *native coroutine function*."
msgstr ""

#: ../../pep-0492.txt:211
msgid ""
"A *generator-based coroutine* object returned from a function decorated "
"with ``types.coroutine()``."
msgstr ""

#: ../../pep-0492.txt:214
msgid "An object with an ``__await__`` method returning an iterator."
msgstr ""

#: ../../pep-0492.txt:216
msgid ""
"Any ``yield from`` chain of calls ends with a ``yield``.  This is a "
"fundamental mechanism of how *Futures* are implemented.  Since, "
"internally, coroutines are a special kind of generators, every ``await`` "
"is suspended by a ``yield`` somewhere down the chain of ``await`` calls "
"(please refer to PEP 3156 for a detailed explanation)."
msgstr ""

#: ../../pep-0492.txt:223
msgid ""
"To enable this behavior for coroutines, a new magic method called "
"``__await__`` is added.  In asyncio, for instance, to enable *Future* "
"objects in ``await`` statements, the only change is to add ``__await__ = "
"__iter__`` line to ``asyncio.Future`` class."
msgstr ""

#: ../../pep-0492.txt:228
msgid ""
"Objects with ``__await__`` method are called *Future-like* objects in the"
" rest of this PEP."
msgstr ""

#: ../../pep-0492.txt:231
msgid "It is a ``TypeError`` if ``__await__`` returns anything but an iterator."
msgstr ""

#: ../../pep-0492.txt:234
msgid ""
"Objects defined with CPython C API with a ``tp_as_async.am_await`` "
"function, returning an *iterator* (similar to ``__await__`` method)."
msgstr ""

#: ../../pep-0492.txt:237
msgid ""
"It is a ``SyntaxError`` to use ``await`` outside of an ``async def`` "
"function (like it is a ``SyntaxError`` to use ``yield`` outside of "
"``def`` function)."
msgstr ""

#: ../../pep-0492.txt:241
msgid ""
"It is a ``TypeError`` to pass anything other than an *awaitable* object "
"to an ``await`` expression."
msgstr ""

#: ../../pep-0492.txt:246
msgid "Updated operator precedence table"
msgstr ""

#: ../../pep-0492.txt:248
msgid "``await`` keyword is defined as follows::"
msgstr ""

#: ../../pep-0492.txt:253
msgid ""
"where \"primary\" represents the most tightly bound operations of the "
"language.  Its syntax is::"
msgstr ""

#: ../../pep-0492.txt:258
msgid ""
"See Python Documentation [12]_ and `Grammar Updates`_ section of this "
"proposal for details."
msgstr ""

#: ../../pep-0492.txt:261
msgid ""
"The key ``await`` difference from ``yield`` and ``yield from`` operators "
"is that *await expressions* do not require parentheses around them most "
"of the times."
msgstr ""

#: ../../pep-0492.txt:265
msgid ""
"Also, ``yield from`` allows any expression as its argument, including "
"expressions like ``yield from a() + b()``, that would be parsed as "
"``yield from (a() + b())``, which is almost always a bug.  In general, "
"the result of any arithmetic operation is not an *awaitable* object. To "
"avoid this kind of mistakes, it was decided to make ``await`` precedence "
"lower than ``[]``, ``()``, and ``.``, but higher than ``**`` operators."
msgstr ""

#: ../../pep-0492.txt:274
msgid "Operator"
msgstr ""

#: ../../pep-0492.txt:274
msgid "Description"
msgstr ""

#: ../../pep-0492.txt:276
msgid "``yield`` ``x``, ``yield from`` ``x``"
msgstr ""

#: ../../pep-0492.txt:276
msgid "Yield expression"
msgstr ""

#: ../../pep-0492.txt:279
msgid "``lambda``"
msgstr ""

#: ../../pep-0492.txt:279
msgid "Lambda expression"
msgstr ""

#: ../../pep-0492.txt:281
msgid "``if`` -- ``else``"
msgstr ""

#: ../../pep-0492.txt:281
msgid "Conditional expression"
msgstr ""

#: ../../pep-0492.txt:283
msgid "``or``"
msgstr ""

#: ../../pep-0492.txt:283
msgid "Boolean OR"
msgstr ""

#: ../../pep-0492.txt:285
msgid "``and``"
msgstr ""

#: ../../pep-0492.txt:285
msgid "Boolean AND"
msgstr ""

#: ../../pep-0492.txt:287
msgid "``not`` ``x``"
msgstr ""

#: ../../pep-0492.txt:287
msgid "Boolean NOT"
msgstr ""

#: ../../pep-0492.txt:289
msgid ""
"``in``, ``not in``, ``is``, ``is not``, ``<``, ``<=``, ``>``, ``>=``, "
"``!=``, ``==``"
msgstr ""

#: ../../pep-0492.txt:289
msgid "Comparisons, including membership tests and identity tests"
msgstr ""

#: ../../pep-0492.txt:294
msgid "``|``"
msgstr ""

#: ../../pep-0492.txt:294
msgid "Bitwise OR"
msgstr ""

#: ../../pep-0492.txt:296
msgid "``^``"
msgstr ""

#: ../../pep-0492.txt:296
msgid "Bitwise XOR"
msgstr ""

#: ../../pep-0492.txt:298
msgid "``&``"
msgstr ""

#: ../../pep-0492.txt:298
msgid "Bitwise AND"
msgstr ""

#: ../../pep-0492.txt:300
msgid "``<<``, ``>>``"
msgstr ""

#: ../../pep-0492.txt:300
msgid "Shifts"
msgstr ""

#: ../../pep-0492.txt:302
msgid "``+``, ``-``"
msgstr ""

#: ../../pep-0492.txt:302
msgid "Addition and subtraction"
msgstr ""

#: ../../pep-0492.txt:304
msgid "``*``, ``@``, ``/``, ``//``, ``%``"
msgstr ""

#: ../../pep-0492.txt:304
msgid "Multiplication, matrix multiplication, division, remainder"
msgstr ""

#: ../../pep-0492.txt:308
msgid "``+x``, ``-x``, ``~x``"
msgstr ""

#: ../../pep-0492.txt:308
msgid "Positive, negative, bitwise NOT"
msgstr ""

#: ../../pep-0492.txt:310
msgid "``**``"
msgstr ""

#: ../../pep-0492.txt:310
msgid "Exponentiation"
msgstr ""

#: ../../pep-0492.txt:312
msgid "``await`` ``x``"
msgstr ""

#: ../../pep-0492.txt:312
msgid "Await expression"
msgstr ""

#: ../../pep-0492.txt:314
msgid "``x[index]``, ``x[index:index]``, ``x(arguments...)``, ``x.attribute``"
msgstr ""

#: ../../pep-0492.txt:314
msgid "Subscription, slicing, call, attribute reference"
msgstr ""

#: ../../pep-0492.txt:319
msgid ""
"``(expressions...)``, ``[expressions...]``, ``{key: value...}``, "
"``{expressions...}``"
msgstr ""

#: ../../pep-0492.txt:319
msgid "Binding or tuple display, list display, dictionary display, set display"
msgstr ""

#: ../../pep-0492.txt:327
msgid "Examples of \"await\" expressions"
msgstr ""

#: ../../pep-0492.txt:329
msgid "Valid syntax examples:"
msgstr ""

#: ../../pep-0492.txt:332 ../../pep-0492.txt:349
msgid "Expression"
msgstr ""

#: ../../pep-0492.txt:332
msgid "Will be parsed as"
msgstr ""

#: ../../pep-0492.txt:334
msgid "``if await fut: pass``"
msgstr ""

#: ../../pep-0492.txt:334
msgid "``if (await fut): pass``"
msgstr ""

#: ../../pep-0492.txt:335
msgid "``if await fut + 1: pass``"
msgstr ""

#: ../../pep-0492.txt:335
msgid "``if (await fut) + 1: pass``"
msgstr ""

#: ../../pep-0492.txt:336
msgid "``pair = await fut, 'spam'``"
msgstr ""

#: ../../pep-0492.txt:336
msgid "``pair = (await fut), 'spam'``"
msgstr ""

#: ../../pep-0492.txt:337
msgid "``with await fut, open(): pass``"
msgstr ""

#: ../../pep-0492.txt:337
msgid "``with (await fut), open(): pass``"
msgstr ""

#: ../../pep-0492.txt:338
msgid "``await foo()['spam'].baz()()``"
msgstr ""

#: ../../pep-0492.txt:338
msgid "``await ( foo()['spam'].baz()() )``"
msgstr ""

#: ../../pep-0492.txt:339
msgid "``return await coro()``"
msgstr ""

#: ../../pep-0492.txt:339
msgid "``return ( await coro() )``"
msgstr ""

#: ../../pep-0492.txt:340
msgid "``res = await coro() ** 2``"
msgstr ""

#: ../../pep-0492.txt:340
msgid "``res = (await coro()) ** 2``"
msgstr ""

#: ../../pep-0492.txt:341
msgid "``func(a1=await coro(), a2=0)``"
msgstr ""

#: ../../pep-0492.txt:341
msgid "``func(a1=(await coro()), a2=0)``"
msgstr ""

#: ../../pep-0492.txt:342
msgid "``await foo() + await bar()``"
msgstr ""

#: ../../pep-0492.txt:342
msgid "``(await foo()) + (await bar())``"
msgstr ""

#: ../../pep-0492.txt:343
msgid "``-await foo()``"
msgstr ""

#: ../../pep-0492.txt:343
msgid "``-(await foo())``"
msgstr ""

#: ../../pep-0492.txt:346
msgid "Invalid syntax examples:"
msgstr ""

#: ../../pep-0492.txt:349
msgid "Should be written as"
msgstr ""

#: ../../pep-0492.txt:351
msgid "``await await coro()``"
msgstr ""

#: ../../pep-0492.txt:351
msgid "``await (await coro())``"
msgstr ""

#: ../../pep-0492.txt:352
msgid "``await -coro()``"
msgstr ""

#: ../../pep-0492.txt:352
msgid "``await (-coro())``"
msgstr ""

#: ../../pep-0492.txt:357
msgid "Asynchronous Context Managers and \"async with\""
msgstr ""

#: ../../pep-0492.txt:359
msgid ""
"An *asynchronous context manager* is a context manager that is able to "
"suspend execution in its *enter* and *exit* methods."
msgstr ""

#: ../../pep-0492.txt:362
msgid ""
"To make this possible, a new protocol for asynchronous context managers "
"is proposed.  Two new magic methods are added: ``__aenter__`` and "
"``__aexit__``. Both must return an *awaitable*."
msgstr ""

#: ../../pep-0492.txt:366
msgid "An example of an asynchronous context manager::"
msgstr ""

#: ../../pep-0492.txt:377 ../../pep-0492.txt:471
msgid "New Syntax"
msgstr ""

#: ../../pep-0492.txt:379
msgid "A new statement for asynchronous context managers is proposed::"
msgstr ""

#: ../../pep-0492.txt:385 ../../pep-0492.txt:481
msgid "which is semantically equivalent to::"
msgstr ""

#: ../../pep-0492.txt:401
msgid ""
"As with regular ``with`` statements, it is possible to specify multiple "
"context managers in a single ``async with`` statement."
msgstr ""

#: ../../pep-0492.txt:404
msgid ""
"It is an error to pass a regular context manager without ``__aenter__`` "
"and ``__aexit__`` methods to ``async with``.  It is a ``SyntaxError`` to "
"use ``async with`` outside of an ``async def`` function."
msgstr ""

#: ../../pep-0492.txt:410
msgid "Example"
msgstr ""

#: ../../pep-0492.txt:412
msgid ""
"With *asynchronous context managers* it is easy to implement proper "
"database transaction managers for coroutines::"
msgstr ""

#: ../../pep-0492.txt:423
msgid "Code that needs locking also looks lighter::"
msgstr ""

#: ../../pep-0492.txt:428
msgid "instead of::"
msgstr ""

#: ../../pep-0492.txt:435
msgid "Asynchronous Iterators and \"async for\""
msgstr ""

#: ../../pep-0492.txt:437
msgid ""
"An *asynchronous iterable* is able to call asynchronous code in its "
"*iter* implementation, and *asynchronous iterator* can call asynchronous "
"code in its *next* method.  To support asynchronous iteration:"
msgstr ""

#: ../../pep-0492.txt:442
msgid ""
"An object must implement an  ``__aiter__`` method (or, if defined with "
"CPython C API, ``tp_as_async.am_aiter`` slot) returning an *asynchronous "
"iterator object*."
msgstr ""

#: ../../pep-0492.txt:446
msgid ""
"An *asynchronous iterator object* must implement an ``__anext__`` method "
"(or, if defined with CPython C API, ``tp_as_async.am_anext`` slot) "
"returning an *awaitable*."
msgstr ""

#: ../../pep-0492.txt:450
msgid ""
"To stop iteration ``__anext__`` must raise a ``StopAsyncIteration`` "
"exception."
msgstr ""

#: ../../pep-0492.txt:453
msgid "An example of asynchronous iterable::"
msgstr ""

#: ../../pep-0492.txt:473
msgid "A new statement for iterating through asynchronous iterators is proposed::"
msgstr ""

#: ../../pep-0492.txt:497
msgid ""
"It is a ``TypeError`` to pass a regular iterable without ``__aiter__`` "
"method to ``async for``.  It is a ``SyntaxError`` to use ``async for`` "
"outside of an ``async def`` function."
msgstr ""

#: ../../pep-0492.txt:501
msgid ""
"As for with regular ``for`` statement, ``async for`` has an optional "
"``else`` clause."
msgstr ""

#: ../../pep-0492.txt:506
msgid "Example 1"
msgstr ""

#: ../../pep-0492.txt:508
msgid ""
"With asynchronous iteration protocol it is possible to asynchronously "
"buffer data during iteration::"
msgstr ""

#: ../../pep-0492.txt:514
msgid ""
"Where ``cursor`` is an asynchronous iterator that prefetches ``N`` rows "
"of data from a database after every ``N`` iterations."
msgstr ""

#: ../../pep-0492.txt:517
msgid "The following code illustrates new asynchronous iteration protocol::"
msgstr ""

#: ../../pep-0492.txt:536
msgid "then the ``Cursor`` class can be used as follows::"
msgstr ""

#: ../../pep-0492.txt:541
msgid "which would be equivalent to the following code::"
msgstr ""

#: ../../pep-0492.txt:554
msgid "Example 2"
msgstr ""

#: ../../pep-0492.txt:556
msgid ""
"The following is a utility class that transforms a regular iterable to an"
" asynchronous one.  While this is not a very useful thing to do, the code"
" illustrates the relationship between regular and asynchronous iterators."
msgstr ""

#: ../../pep-0492.txt:582
msgid "Why StopAsyncIteration?"
msgstr ""

#: ../../pep-0492.txt:584
msgid ""
"Coroutines are still based on generators internally.  So, before PEP 479,"
" there was no fundamental difference between"
msgstr ""

#: ../../pep-0492.txt:593
msgid "and"
msgstr ""

#: ../../pep-0492.txt:601
msgid ""
"And since PEP 479 is accepted and enabled by default for coroutines, the "
"following example will have its ``StopIteration`` wrapped into a "
"``RuntimeError``"
msgstr ""

#: ../../pep-0492.txt:611
msgid ""
"The only way to tell the outside code that the iteration has ended is to "
"raise something other than ``StopIteration``.  Therefore, a new built-in "
"exception class ``StopAsyncIteration`` was added."
msgstr ""

#: ../../pep-0492.txt:615
msgid ""
"Moreover, with semantics from PEP 479, all ``StopIteration`` exceptions "
"raised in coroutines are wrapped in ``RuntimeError``."
msgstr ""

#: ../../pep-0492.txt:620
msgid "Coroutine objects"
msgstr ""

#: ../../pep-0492.txt:623
msgid "Differences from generators"
msgstr ""

#: ../../pep-0492.txt:625
msgid ""
"This section applies only to *native coroutines* with ``CO_COROUTINE`` "
"flag, i.e. defined with the new ``async def`` syntax."
msgstr ""

#: ../../pep-0492.txt:628
msgid ""
"**The behavior of existing *generator-based coroutines* in asyncio "
"remains unchanged.**"
msgstr ""

#: ../../pep-0492.txt:631
msgid ""
"Great effort has been made to make sure that coroutines and generators "
"are treated as distinct concepts:"
msgstr ""

#: ../../pep-0492.txt:634
msgid ""
"*Native coroutine* objects do not implement ``__iter__`` and ``__next__``"
" methods.  Therefore, they cannot be iterated over or passed to "
"``iter()``, ``list()``, ``tuple()`` and other built-ins. They also cannot"
" be used in a ``for..in`` loop."
msgstr ""

#: ../../pep-0492.txt:639
msgid ""
"An attempt to use ``__iter__`` or ``__next__`` on a *native coroutine* "
"object will result in a ``TypeError``."
msgstr ""

#: ../../pep-0492.txt:642
msgid ""
"*Plain generators* cannot ``yield from`` *native coroutines*: doing so "
"will result in a ``TypeError``."
msgstr ""

#: ../../pep-0492.txt:645
msgid ""
"*generator-based coroutines* (for asyncio code must be decorated with "
"``@asyncio.coroutine``) can ``yield from`` *native coroutine objects*."
msgstr ""

#: ../../pep-0492.txt:649
msgid ""
"``inspect.isgenerator()`` and ``inspect.isgeneratorfunction()`` return "
"``False`` for *native coroutine* objects and *native coroutine "
"functions*."
msgstr ""

#: ../../pep-0492.txt:655
msgid "Coroutine object methods"
msgstr ""

#: ../../pep-0492.txt:657
msgid ""
"Coroutines are based on generators internally, thus they share the "
"implementation.  Similarly to generator objects, *coroutines* have "
"``throw()``, ``send()`` and ``close()`` methods.  ``StopIteration`` and "
"``GeneratorExit`` play the same role for coroutines (although PEP 479 is "
"enabled by default for coroutines).  See PEP 342, PEP 380, and Python "
"Documentation [11]_ for details."
msgstr ""

#: ../../pep-0492.txt:664
msgid ""
"``throw()``, ``send()`` methods for *coroutines* are used to push values "
"and raise errors into *Future-like* objects."
msgstr ""

#: ../../pep-0492.txt:669
msgid "Debugging Features"
msgstr ""

#: ../../pep-0492.txt:671
msgid ""
"A common beginner mistake is forgetting to use ``yield from`` on "
"coroutines::"
msgstr ""

#: ../../pep-0492.txt:678
msgid ""
"For debugging this kind of mistakes there is a special debug mode in "
"asyncio, in which ``@coroutine`` decorator wraps all functions with a "
"special object with a destructor logging a warning.  Whenever a wrapped "
"generator gets garbage collected, a detailed logging message is generated"
" with information about where exactly the decorator function was defined,"
" stack trace of where it was collected, etc.  Wrapper object also "
"provides a convenient ``__repr__`` function with detailed information "
"about the generator."
msgstr ""

#: ../../pep-0492.txt:687
msgid ""
"The only problem is how to enable these debug capabilities.  Since debug "
"facilities should be a no-op in production mode, ``@coroutine`` decorator"
" makes the decision of whether to wrap or not to wrap based on an OS "
"environment variable ``PYTHONASYNCIODEBUG``.  This way it is possible to "
"run asyncio programs with asyncio's own functions instrumented.  "
"``EventLoop.set_debug``, a different debug facility, has no impact on "
"``@coroutine`` decorator's behavior."
msgstr ""

#: ../../pep-0492.txt:695
msgid ""
"With this proposal, coroutines is a native, distinct from generators, "
"concept.  *In addition* to a ``RuntimeWarning`` being raised on "
"coroutines that were never awaited, it is proposed to add two new "
"functions to the ``sys`` module: ``set_coroutine_wrapper`` and "
"``get_coroutine_wrapper``.  This is to enable advanced debugging "
"facilities in asyncio and other frameworks (such as displaying where "
"exactly coroutine was created, and a more detailed stack trace of where "
"it was garbage collected)."
msgstr ""

#: ../../pep-0492.txt:706
msgid "New Standard Library Functions"
msgstr ""

#: ../../pep-0492.txt:708
msgid "``types.coroutine(gen)``.  See `types.coroutine()`_ section for details."
msgstr ""

#: ../../pep-0492.txt:711
msgid ""
"``inspect.iscoroutine(obj)`` returns ``True`` if ``obj`` is a *native "
"coroutine* object."
msgstr ""

#: ../../pep-0492.txt:714
msgid ""
"``inspect.iscoroutinefunction(obj)`` returns ``True`` if ``obj`` is a "
"*native coroutine function*."
msgstr ""

#: ../../pep-0492.txt:717
msgid ""
"``inspect.isawaitable(obj)`` returns ``True`` if ``obj`` is an "
"*awaitable*."
msgstr ""

#: ../../pep-0492.txt:720
msgid ""
"``inspect.getcoroutinestate(coro)`` returns the current state of a "
"*native coroutine object* (mirrors ``inspect.getfgeneratorstate(gen)``)."
msgstr ""

#: ../../pep-0492.txt:724
msgid ""
"``inspect.getcoroutinelocals(coro)`` returns the mapping of a *native "
"coroutine object's* local variables to their values (mirrors "
"``inspect.getgeneratorlocals(gen)``)."
msgstr ""

#: ../../pep-0492.txt:728
msgid ""
"``sys.set_coroutine_wrapper(wrapper)`` allows to intercept creation of "
"*native coroutine* objects. ``wrapper`` must be either a callable that "
"accepts one argument (a *coroutine* object), or ``None``.  ``None`` "
"resets the wrapper.  If called twice, the new wrapper replaces the "
"previous one. The function is thread-specific.  See `Debugging Features`_"
" for more details."
msgstr ""

#: ../../pep-0492.txt:735
msgid ""
"``sys.get_coroutine_wrapper()`` returns the current wrapper object. "
"Returns ``None`` if no wrapper was set.  The function is thread-specific."
"  See  `Debugging Features`_ for more details."
msgstr ""

#: ../../pep-0492.txt:741
msgid "New Abstract Base Classes"
msgstr ""

#: ../../pep-0492.txt:743
msgid ""
"In order to allow better integration with existing frameworks (such as "
"Tornado, see [13]_) and compilers (such as Cython, see [16]_), two new "
"Abstract Base Classes (ABC) are added:"
msgstr ""

#: ../../pep-0492.txt:747
msgid ""
"``collections.abc.Awaitable`` ABC for *Future-like* classes, that "
"implement ``__await__`` method."
msgstr ""

#: ../../pep-0492.txt:750
msgid ""
"``collections.abc.Coroutine`` ABC for *coroutine* objects, that implement"
" ``send(value)``, ``throw(type, exc, tb)``, ``close()`` and "
"``__await__()`` methods."
msgstr ""

#: ../../pep-0492.txt:754
msgid ""
"Note that generator-based coroutines with ``CO_ITERABLE_COROUTINE`` flag "
"do not implement ``__await__`` method, and therefore are not instances of"
" ``collections.abc.Coroutine`` and ``collections.abc.Awaitable`` ABCs::"
msgstr ""

#: ../../pep-0492.txt:768
msgid ""
"To allow easy testing if objects support asynchronous iteration, two more"
" ABCs are added:"
msgstr ""

#: ../../pep-0492.txt:771
msgid "``collections.abc.AsyncIterable`` -- tests for ``__aiter__`` method."
msgstr ""

#: ../../pep-0492.txt:773
msgid ""
"``collections.abc.AsyncIterator`` -- tests for ``__aiter__`` and "
"``__anext__`` methods."
msgstr ""

#: ../../pep-0492.txt:778
msgid "Glossary"
msgstr ""

#: ../../pep-0492.txt:783
msgid "Native coroutine function"
msgstr ""

#: ../../pep-0492.txt:781
msgid ""
"A coroutine function is declared with ``async def``. It uses ``await`` "
"and ``return value``; see `New Coroutine Declaration Syntax`_ for "
"details."
msgstr ""

#: ../../pep-0492.txt:787
msgid "Native coroutine"
msgstr ""

#: ../../pep-0492.txt:786
msgid ""
"Returned from a native coroutine function. See `Await Expression`_ for "
"details."
msgstr ""

#: ../../pep-0492.txt:791
msgid "Generator-based coroutine function"
msgstr ""

#: ../../pep-0492.txt:790
msgid ""
"Coroutines based on generator syntax.  Most common example are functions "
"decorated with ``@asyncio.coroutine``."
msgstr ""

#: ../../pep-0492.txt:794
msgid "Generator-based coroutine"
msgstr ""

#: ../../pep-0492.txt:794
msgid "Returned from a generator-based coroutine function."
msgstr ""

#: ../../pep-0492.txt:797
msgid "Coroutine"
msgstr ""

#: ../../pep-0492.txt:797
msgid "Either *native coroutine* or *generator-based coroutine*."
msgstr ""

#: ../../pep-0492.txt:801
msgid "Coroutine object"
msgstr ""

#: ../../pep-0492.txt:800
msgid "Either *native coroutine* object or *generator-based coroutine* object."
msgstr ""

#: ../../pep-0492.txt:809
msgid "Future-like object"
msgstr ""

#: ../../pep-0492.txt:804
msgid ""
"An object with an ``__await__`` method, or a C object with "
"``tp_as_async->am_await`` function, returning an *iterator*.  Can be "
"consumed by an ``await`` expression in a coroutine. A coroutine waiting "
"for a Future-like object is suspended until the Future-like object's "
"``__await__`` completes, and returns the result.  See `Await Expression`_"
" for details."
msgstr ""

#: ../../pep-0492.txt:813
msgid "Awaitable"
msgstr ""

#: ../../pep-0492.txt:812
msgid ""
"A *Future-like* object or a *coroutine* object.  See `Await Expression`_ "
"for details."
msgstr ""

#: ../../pep-0492.txt:818
msgid "Asynchronous context manager"
msgstr ""

#: ../../pep-0492.txt:816
msgid ""
"An asynchronous context manager has ``__aenter__`` and ``__aexit__`` "
"methods and can be used with ``async with``.  See `Asynchronous Context "
"Managers and \"async with\"`_ for details."
msgstr ""

#: ../../pep-0492.txt:823
msgid "Asynchronous iterable"
msgstr ""

#: ../../pep-0492.txt:821
msgid ""
"An object with an ``__aiter__`` method, which must return an "
"*asynchronous iterator* object.  Can be used with ``async for``. See "
"`Asynchronous Iterators and \"async for\"`_ for details."
msgstr ""

#: ../../pep-0492.txt:828
msgid "Asynchronous iterator"
msgstr ""

#: ../../pep-0492.txt:826
msgid ""
"An asynchronous iterator has an ``__anext__`` method.  See `Asynchronous "
"Iterators and \"async for\"`_ for details."
msgstr ""

#: ../../pep-0492.txt:831
msgid "Transition Plan"
msgstr ""

#: ../../pep-0492.txt:833
msgid ""
"To avoid backwards compatibility issues with ``async`` and ``await`` "
"keywords, it was decided to modify ``tokenizer.c`` in such a way, that "
"it:"
msgstr ""

#: ../../pep-0492.txt:837
msgid "recognizes ``async def`` ``NAME`` tokens combination;"
msgstr ""

#: ../../pep-0492.txt:839
msgid ""
"while tokenizing ``async def`` block, it replaces ``'async'`` ``NAME`` "
"token with ``ASYNC``, and ``'await'`` ``NAME`` token with ``AWAIT``;"
msgstr ""

#: ../../pep-0492.txt:843
msgid ""
"while tokenizing ``def`` block, it yields ``'async'`` and ``'await'`` "
"``NAME`` tokens as is."
msgstr ""

#: ../../pep-0492.txt:846
msgid ""
"This approach allows for seamless combination of new syntax features (all"
" of them available only in ``async`` functions) with any existing code."
msgstr ""

#: ../../pep-0492.txt:850
msgid ""
"An example of having \"async def\" and \"async\" attribute in one piece "
"of code::"
msgstr ""

#: ../../pep-0492.txt:863
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0492.txt:865
msgid "This proposal preserves 100% backwards compatibility."
msgstr ""

#: ../../pep-0492.txt:869
msgid "asyncio"
msgstr ""

#: ../../pep-0492.txt:871
msgid ""
"``asyncio`` module was adapted and tested to work with coroutines and new"
" statements.  Backwards compatibility is 100% preserved, i.e. all "
"existing code will work as-is."
msgstr ""

#: ../../pep-0492.txt:875
msgid "The required changes are mainly:"
msgstr ""

#: ../../pep-0492.txt:877
msgid ""
"Modify ``@asyncio.coroutine`` decorator to use new ``types.coroutine()`` "
"function."
msgstr ""

#: ../../pep-0492.txt:880
msgid "Add ``__await__ = __iter__`` line to ``asyncio.Future`` class."
msgstr ""

#: ../../pep-0492.txt:882
msgid ""
"Add ``ensure_future()`` as an alias for ``async()`` function. Deprecate "
"``async()`` function."
msgstr ""

#: ../../pep-0492.txt:887
msgid "asyncio migration strategy"
msgstr ""

#: ../../pep-0492.txt:889
msgid ""
"Because *plain generators* cannot ``yield from`` *native coroutine "
"objects* (see `Differences from generators`_ section for more details), "
"it is advised to make sure that all generator-based coroutines are "
"decorated with ``@asyncio.coroutine`` *before* starting to use the new "
"syntax."
msgstr ""

#: ../../pep-0492.txt:897
msgid "async/await in CPython code base"
msgstr ""

#: ../../pep-0492.txt:899
msgid "There is no use of ``await`` names in CPython."
msgstr ""

#: ../../pep-0492.txt:901
msgid ""
"``async`` is mostly used by asyncio.  We are addressing this by renaming "
"``async()`` function to ``ensure_future()`` (see `asyncio`_ section for "
"details)."
msgstr ""

#: ../../pep-0492.txt:905
msgid ""
"Another use of ``async`` keyword is in ``Lib/xml/dom/xmlbuilder.py``, to "
"define an ``async = False`` attribute for ``DocumentLS`` class. There is "
"no documentation or tests for it, it is not used anywhere else in "
"CPython.  It is replaced with a getter, that raises a "
"``DeprecationWarning``, advising to use ``async_`` attribute instead. "
"'async' attribute is not documented and is not used in CPython code base."
msgstr ""

#: ../../pep-0492.txt:915
msgid "Grammar Updates"
msgstr ""

#: ../../pep-0492.txt:917
msgid "Grammar changes are fairly minimal::"
msgstr ""

#: ../../pep-0492.txt:932
msgid "Deprecation Plans"
msgstr ""

#: ../../pep-0492.txt:934
msgid ""
"``async`` and ``await`` names will be softly deprecated in CPython 3.5 "
"and 3.6. In 3.7 we will transform them to proper keywords.  Making "
"``async`` and ``await`` proper keywords before 3.7 might make it harder "
"for people to port their code to Python 3."
msgstr ""

#: ../../pep-0492.txt:941
msgid "Design Considerations"
msgstr ""

#: ../../pep-0492.txt:944
msgid "PEP 3152"
msgstr ""

#: ../../pep-0492.txt:946
msgid ""
"PEP 3152 by Gregory Ewing proposes a different mechanism for coroutines "
"(called \"cofunctions\").  Some key points:"
msgstr ""

#: ../../pep-0492.txt:949
msgid ""
"A new keyword ``codef`` to declare a *cofunction*.  *Cofunction* is "
"always a generator, even if there is no ``cocall`` expressions inside it."
"  Maps to ``async def`` in this proposal."
msgstr ""

#: ../../pep-0492.txt:953
msgid ""
"A new keyword ``cocall`` to call a *cofunction*.  Can only be used inside"
" a *cofunction*.  Maps to ``await`` in this proposal (with some "
"differences, see below)."
msgstr ""

#: ../../pep-0492.txt:957
msgid "It is not possible to call a *cofunction* without a ``cocall`` keyword."
msgstr ""

#: ../../pep-0492.txt:960
msgid "``cocall`` grammatically requires parentheses after it::"
msgstr ""

#: ../../pep-0492.txt:966
msgid ""
"``cocall f(*args, **kwds)`` is semantically equivalent to ``yield from "
"f.__cocall__(*args, **kwds)``."
msgstr ""

#: ../../pep-0492.txt:969
msgid "Differences from this proposal:"
msgstr ""

#: ../../pep-0492.txt:971
msgid ""
"There is no equivalent of ``__cocall__`` in this PEP, which is called and"
" its result is passed to ``yield from`` in the ``cocall`` expression. "
"``await`` keyword expects an *awaitable* object, validates the type, and "
"executes ``yield from`` on it.  Although, ``__await__`` method is similar"
" to ``__cocall__``, but is only used to define *Future-like* objects."
msgstr ""

#: ../../pep-0492.txt:978
msgid ""
"``await`` is defined in almost the same way as ``yield from`` in the "
"grammar (it is later enforced that ``await`` can only be inside ``async "
"def``).  It is possible to simply write ``await future``, whereas "
"``cocall`` always requires parentheses."
msgstr ""

#: ../../pep-0492.txt:983
msgid ""
"To make asyncio work with PEP 3152 it would be required to modify "
"``@asyncio.coroutine`` decorator to wrap all functions in an object with "
"a ``__cocall__`` method, or to implement ``__cocall__`` on generators.  "
"To call *cofunctions* from existing generator-based coroutines it would "
"be required to use ``costart(cofunc, *args, **kwargs)`` built-in."
msgstr ""

#: ../../pep-0492.txt:990
msgid ""
"Since it is impossible to call a *cofunction* without a ``cocall`` "
"keyword, it automatically prevents the common mistake of forgetting to "
"use ``yield from`` on generator-based coroutines.  This proposal "
"addresses this problem with a different approach, see `Debugging "
"Features`_."
msgstr ""

#: ../../pep-0492.txt:996
msgid ""
"A shortcoming of requiring a ``cocall`` keyword to call a coroutine is "
"that if is decided to implement coroutine-generators -- coroutines with "
"``yield`` or ``async yield`` expressions -- we wouldn't need a ``cocall``"
" keyword to call them.  So we'll end up having ``__cocall__`` and no "
"``__call__`` for regular coroutines, and having ``__call__`` and no "
"``__cocall__`` for coroutine- generators."
msgstr ""

#: ../../pep-0492.txt:1004
msgid ""
"Requiring parentheses grammatically also introduces a whole lot of new "
"problems."
msgstr ""

#: ../../pep-0492.txt:1007
msgid "The following code::"
msgstr ""

#: ../../pep-0492.txt:1013
msgid "would look like::"
msgstr ""

#: ../../pep-0492.txt:1020
msgid "There are no equivalents of ``async for`` and ``async with`` in PEP 3152."
msgstr ""

#: ../../pep-0492.txt:1025
msgid "Coroutine-generators"
msgstr ""

#: ../../pep-0492.txt:1027
msgid ""
"With ``async for`` keyword it is desirable to have a concept of a "
"*coroutine-generator* -- a coroutine with ``yield`` and ``yield from`` "
"expressions.  To avoid any ambiguity with regular generators, we would "
"likely require to have an ``async`` keyword before ``yield``, and ``async"
" yield from`` would raise a ``StopAsyncIteration`` exception."
msgstr ""

#: ../../pep-0492.txt:1033
msgid ""
"While it is possible to implement coroutine-generators, we believe that "
"they are out of scope of this proposal.  It is an advanced concept that "
"should be carefully considered and balanced, with a non-trivial changes "
"in the implementation of current generator objects.  This is a matter for"
" a separate PEP."
msgstr ""

#: ../../pep-0492.txt:1041
msgid "Why \"async\" and \"await\" keywords"
msgstr ""

#: ../../pep-0492.txt:1043
msgid "async/await is not a new concept in programming languages:"
msgstr ""

#: ../../pep-0492.txt:1045
msgid "C# has it since long time ago [5]_;"
msgstr ""

#: ../../pep-0492.txt:1047
msgid ""
"proposal to add async/await in ECMAScript 7 [2]_; see also Traceur "
"project [9]_;"
msgstr ""

#: ../../pep-0492.txt:1050
msgid "Facebook's Hack/HHVM [6]_;"
msgstr ""

#: ../../pep-0492.txt:1052
msgid "Google's Dart language [7]_;"
msgstr ""

#: ../../pep-0492.txt:1054
msgid "Scala [8]_;"
msgstr ""

#: ../../pep-0492.txt:1056
msgid "proposal to add async/await to C++ [10]_;"
msgstr ""

#: ../../pep-0492.txt:1058
msgid "and many other less popular languages."
msgstr ""

#: ../../pep-0492.txt:1060
msgid ""
"This is a huge benefit, as some users already have experience with "
"async/await, and because it makes working with many languages in one "
"project easier (Python with ECMAScript 7 for instance)."
msgstr ""

#: ../../pep-0492.txt:1066
msgid "Why \"__aiter__\" does not return an awaitable"
msgstr ""

#: ../../pep-0492.txt:1068
msgid ""
"PEP 492 was accepted in CPython 3.5.0 with ``__aiter__`` defined as a "
"method, that was expected to return an awaitable resolving to an "
"asynchronous iterator."
msgstr ""

#: ../../pep-0492.txt:1072
msgid ""
"In 3.5.2 (as PEP 492 was accepted on a provisional basis) the "
"``__aiter__`` protocol was updated to return asynchronous iterators "
"directly."
msgstr ""

#: ../../pep-0492.txt:1076
msgid ""
"The motivation behind this change is to make it possible to implement "
"asynchronous generators in Python.  See [19]_ and [20]_ for more details."
msgstr ""

#: ../../pep-0492.txt:1082
msgid "Importance of \"async\" keyword"
msgstr ""

#: ../../pep-0492.txt:1084
msgid ""
"While it is possible to just implement ``await`` expression and treat all"
" functions with at least one ``await`` as coroutines, this approach makes"
" APIs design, code refactoring and its long time support harder."
msgstr ""

#: ../../pep-0492.txt:1088
msgid "Let's pretend that Python only has ``await`` keyword::"
msgstr ""

#: ../../pep-0492.txt:1098
msgid ""
"If ``useful()`` function is refactored and someone removes all ``await`` "
"expressions from it, it would become a regular python function, and all "
"code that depends on it, including ``important()`` would be broken.  To "
"mitigate this issue a decorator similar to ``@asyncio.coroutine`` has to "
"be introduced."
msgstr ""

#: ../../pep-0492.txt:1106
msgid "Why \"async def\""
msgstr ""

#: ../../pep-0492.txt:1108
msgid ""
"For some people bare ``async name(): pass`` syntax might look more "
"appealing than ``async def name(): pass``.  It is certainly easier to "
"type.  But on the other hand, it breaks the symmetry between ``async "
"def``, ``async with`` and ``async for``, where ``async`` is a modifier, "
"stating that the statement is asynchronous.  It is also more consistent "
"with the existing grammar."
msgstr ""

#: ../../pep-0492.txt:1117
msgid "Why not \"await for\" and \"await with\""
msgstr ""

#: ../../pep-0492.txt:1119
msgid ""
"``async`` is an adjective, and hence it is a better choice for a "
"*statement qualifier* keyword.  ``await for/with`` would imply that "
"something is awaiting for a completion of a ``for`` or ``with`` "
"statement."
msgstr ""

#: ../../pep-0492.txt:1126
msgid "Why \"async def\" and not \"def async\""
msgstr ""

#: ../../pep-0492.txt:1128
msgid ""
"``async`` keyword is a *statement qualifier*.  A good analogy to it are "
"\"static\", \"public\", \"unsafe\" keywords from other languages.  "
"\"async for\" is an asynchronous \"for\" statement, \"async with\" is an "
"asynchronous \"with\" statement, \"async def\" is an asynchronous "
"function."
msgstr ""

#: ../../pep-0492.txt:1133
msgid ""
"Having \"async\" after the main statement keyword might introduce some "
"confusion, like \"for async item in iterator\" can be read as \"for each "
"asynchronous item in iterator\"."
msgstr ""

#: ../../pep-0492.txt:1137
msgid ""
"Having ``async`` keyword before ``def``, ``with`` and ``for`` also makes "
"the language grammar simpler.  And \"async def\" better separates "
"coroutines from regular functions visually."
msgstr ""

#: ../../pep-0492.txt:1143
msgid "Why not a __future__ import"
msgstr ""

#: ../../pep-0492.txt:1145
msgid ""
"`Transition Plan`_ section explains how tokenizer is modified to treat "
"``async`` and ``await`` as keywords *only* in ``async def`` blocks. Hence"
" ``async def`` fills the role that a module level compiler declaration "
"like ``from __future__ import async_await`` would otherwise fill."
msgstr ""

#: ../../pep-0492.txt:1153
msgid "Why magic methods start with \"a\""
msgstr ""

#: ../../pep-0492.txt:1155
msgid ""
"New asynchronous magic methods ``__aiter__``, ``__anext__``, "
"``__aenter__``, and ``__aexit__`` all start with the same prefix \"a\". "
"An alternative proposal is to use \"async\" prefix, so that ``__anext__``"
" becomes ``__async_next__``. However, to align new magic methods with the"
" existing ones, such as ``__radd__`` and ``__iadd__`` it was decided to "
"use a shorter version."
msgstr ""

#: ../../pep-0492.txt:1164
msgid "Why not reuse existing magic names"
msgstr ""

#: ../../pep-0492.txt:1166
msgid ""
"An alternative idea about new asynchronous iterators and context managers"
" was to reuse existing magic methods, by adding an ``async`` keyword to "
"their declarations::"
msgstr ""

#: ../../pep-0492.txt:1174
msgid "This approach has the following downsides:"
msgstr ""

#: ../../pep-0492.txt:1176
msgid ""
"it would not be possible to create an object that works in both ``with`` "
"and ``async with`` statements;"
msgstr ""

#: ../../pep-0492.txt:1179
msgid ""
"it would break backwards compatibility, as nothing prohibits from "
"returning a Future-like objects from ``__enter__`` and/or ``__exit__`` in"
" Python <= 3.4;"
msgstr ""

#: ../../pep-0492.txt:1183
msgid ""
"one of the main points of this proposal is to make native coroutines as "
"simple and foolproof as possible, hence the clear separation of the "
"protocols."
msgstr ""

#: ../../pep-0492.txt:1189
msgid "Why not reuse existing \"for\" and \"with\" statements"
msgstr ""

#: ../../pep-0492.txt:1191
msgid ""
"The vision behind existing generator-based coroutines and this proposal "
"is to make it easy for users to see where the code might be suspended. "
"Making existing \"for\" and \"with\" statements to recognize asynchronous"
" iterators and context managers will inevitably create implicit suspend "
"points, making it harder to reason about the code."
msgstr ""

#: ../../pep-0492.txt:1199
msgid "Comprehensions"
msgstr ""

#: ../../pep-0492.txt:1201
msgid ""
"Syntax for asynchronous comprehensions could be provided, but this "
"construct is outside of the scope of this PEP."
msgstr ""

#: ../../pep-0492.txt:1206
msgid "Async lambda functions"
msgstr ""

#: ../../pep-0492.txt:1208
msgid ""
"Syntax for asynchronous lambda functions could be provided, but this "
"construct is outside of the scope of this PEP."
msgstr ""

#: ../../pep-0492.txt:1213
msgid "Performance"
msgstr ""

#: ../../pep-0492.txt:1216
msgid "Overall Impact"
msgstr ""

#: ../../pep-0492.txt:1218
msgid ""
"This proposal introduces no observable performance impact.  Here is an "
"output of python's official set of benchmarks [4]_:"
msgstr ""

#: ../../pep-0492.txt:1245
msgid "Tokenizer modifications"
msgstr ""

#: ../../pep-0492.txt:1247
msgid ""
"There is no observable slowdown of parsing python files with the modified"
" tokenizer: parsing of one 12Mb file (``Lib/test/test_binop.py`` repeated"
" 1000 times) takes the same amount of time."
msgstr ""

#: ../../pep-0492.txt:1254
msgid "async/await"
msgstr ""

#: ../../pep-0492.txt:1256
msgid ""
"The following micro-benchmark was used to determine performance "
"difference between \"async\" functions and generators::"
msgstr ""

#: ../../pep-0492.txt:1289
msgid "The result is that there is no observable performance difference::"
msgstr ""

#: ../../pep-0492.txt:1300
msgid "Note that depth of 19 means 1,048,575 calls."
msgstr ""

#: ../../pep-0492.txt:1304
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0492.txt:1306
msgid "The reference implementation can be found here: [3]_."
msgstr ""

#: ../../pep-0492.txt:1309
msgid "List of high-level changes and new protocols"
msgstr ""

#: ../../pep-0492.txt:1311
msgid ""
"New syntax for defining coroutines: ``async def`` and new ``await`` "
"keyword."
msgstr ""

#: ../../pep-0492.txt:1314
msgid ""
"New ``__await__`` method for Future-like objects, and new "
"``tp_as_async.am_await`` slot in ``PyTypeObject``."
msgstr ""

#: ../../pep-0492.txt:1317
msgid ""
"New syntax for asynchronous context managers: ``async with``.  And "
"associated protocol with ``__aenter__`` and ``__aexit__`` methods."
msgstr ""

#: ../../pep-0492.txt:1320
msgid ""
"New syntax for asynchronous iteration: ``async for``.  And associated "
"protocol with ``__aiter__``, ``__aexit__`` and new built- in exception "
"``StopAsyncIteration``.  New ``tp_as_async.am_aiter`` and "
"``tp_as_async.am_anext`` slots in ``PyTypeObject``."
msgstr ""

#: ../../pep-0492.txt:1325
msgid ""
"New AST nodes: ``AsyncFunctionDef``, ``AsyncFor``, ``AsyncWith``, "
"``Await``."
msgstr ""

#: ../../pep-0492.txt:1328
msgid ""
"New functions: ``sys.set_coroutine_wrapper(callback)``, "
"``sys.get_coroutine_wrapper()``, ``types.coroutine(gen)``, "
"``inspect.iscoroutinefunction(func)``, ``inspect.iscoroutine(obj)``, "
"``inspect.isawaitable(obj)``, ``inspect.getcoroutinestate(coro)``, and "
"``inspect.getcoroutinelocals(coro)``."
msgstr ""

#: ../../pep-0492.txt:1334
msgid ""
"New ``CO_COROUTINE`` and ``CO_ITERABLE_COROUTINE`` bit flags for code "
"objects."
msgstr ""

#: ../../pep-0492.txt:1337
msgid ""
"New ABCs: ``collections.abc.Awaitable``, ``collections.abc.Coroutine``, "
"``collections.abc.AsyncIterable``, and ``collections.abc.AsyncIterator``."
msgstr ""

#: ../../pep-0492.txt:1341
msgid ""
"C API changes: new ``PyCoro_Type`` (exposed to Python as "
"``types.CoroutineType``) and ``PyCoroObject``. ``PyCoro_CheckExact(*o)`` "
"to test if ``o`` is a *native coroutine*."
msgstr ""

#: ../../pep-0492.txt:1346
msgid ""
"While the list of changes and new things is not short, it is important to"
" understand, that most users will not use these features directly. It is "
"intended to be used in frameworks and libraries to provide users with "
"convenient to use and unambiguous APIs with ``async def``, ``await``, "
"``async for`` and ``async with`` syntax."
msgstr ""

#: ../../pep-0492.txt:1354
msgid "Working example"
msgstr ""

#: ../../pep-0492.txt:1356
msgid "All concepts proposed in this PEP are implemented [3]_ and can be tested."
msgstr ""

#: ../../pep-0492.txt:1389
msgid "Acceptance"
msgstr ""

#: ../../pep-0492.txt:1391
msgid "PEP 492 was accepted by Guido, Tuesday, May 5, 2015 [14]_."
msgstr ""

#: ../../pep-0492.txt:1395
msgid "Implementation"
msgstr ""

#: ../../pep-0492.txt:1397
msgid ""
"The implementation is tracked in issue 24017 [15]_. It was committed on "
"May 11, 2015."
msgstr ""

#: ../../pep-0492.txt:1402
msgid "References"
msgstr ""

#: ../../pep-0492.txt:1404
msgid "https://docs.python.org/3/library/asyncio-task.html#asyncio.coroutine"
msgstr ""

#: ../../pep-0492.txt:1406
msgid "http://wiki.ecmascript.org/doku.php?id=strawman:async_functions"
msgstr ""

#: ../../pep-0492.txt:1408
msgid "https://github.com/1st1/cpython/tree/await"
msgstr ""

#: ../../pep-0492.txt:1410
msgid "https://hg.python.org/benchmarks"
msgstr ""

#: ../../pep-0492.txt:1412
msgid "https://msdn.microsoft.com/en-us/library/hh191443.aspx"
msgstr ""

#: ../../pep-0492.txt:1414
msgid "http://docs.hhvm.com/manual/en/hack.async.php"
msgstr ""

#: ../../pep-0492.txt:1416
msgid "https://www.dartlang.org/articles/await-async/"
msgstr ""

#: ../../pep-0492.txt:1418
msgid "http://docs.scala-lang.org/sips/pending/async.html"
msgstr ""

#: ../../pep-0492.txt:1420
msgid ""
"https://github.com/google/traceur-compiler/wiki/LanguageFeatures#async-"
"functions-experimental"
msgstr ""

#: ../../pep-0492.txt:1422
msgid "http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3722.pdf (PDF)"
msgstr ""

#: ../../pep-0492.txt:1424
msgid ""
"https://docs.python.org/3/reference/expressions.html#generator-iterator-"
"methods"
msgstr ""

#: ../../pep-0492.txt:1426
msgid "https://docs.python.org/3/reference/expressions.html#primaries"
msgstr ""

#: ../../pep-0492.txt:1428
msgid "https://mail.python.org/pipermail/python-dev/2015-May/139851.html"
msgstr ""

#: ../../pep-0492.txt:1430
msgid "https://mail.python.org/pipermail/python-dev/2015-May/139844.html"
msgstr ""

#: ../../pep-0492.txt:1432
msgid "http://bugs.python.org/issue24017"
msgstr ""

#: ../../pep-0492.txt:1434
msgid "https://github.com/python/asyncio/issues/233"
msgstr ""

#: ../../pep-0492.txt:1436
msgid "https://hg.python.org/cpython/rev/7a0a1a4ac639"
msgstr ""

#: ../../pep-0492.txt:1438
msgid "http://bugs.python.org/issue24400"
msgstr ""

#: ../../pep-0492.txt:1440
msgid "http://bugs.python.org/issue27243"
msgstr ""

#: ../../pep-0492.txt:1442
msgid "https://docs.python.org/3/reference/datamodel.html#async-iterators"
msgstr ""

#: ../../pep-0492.txt:1445
msgid "Acknowledgments"
msgstr ""

#: ../../pep-0492.txt:1447
msgid ""
"I thank Guido van Rossum, Victor Stinner, Elvis Pranskevichus, Andrew "
"Svetlov, ukasz Langa, Greg Ewing, Stephen J. Turnbull, Jim J. Jewett, "
"Brett Cannon, Nick Coghlan, Steven D'Aprano, Paul Moore, Nathaniel Smith,"
" Ethan Furman, Stefan Behnel, Paul Sokolovsky, Victor Petrovykh, and many"
" others for their feedback, ideas, edits, criticism, code reviews, and "
"discussions around this PEP."
msgstr ""

#: ../../pep-0492.txt:1456
msgid "Copyright"
msgstr ""

#: ../../pep-0492.txt:1458
msgid "This document has been placed in the public domain."
msgstr ""

