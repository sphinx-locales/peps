# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0346.txt
msgid "PEP"
msgstr ""

#: ../../pep-0346.txt:1
msgid "346"
msgstr ""

#: ../../pep-0346.txt
msgid "Title"
msgstr ""

#: ../../pep-0346.txt:2
msgid "User Defined (\"``with``\") Statements"
msgstr ""

#: ../../pep-0346.txt
msgid "Author"
msgstr ""

#: ../../pep-0346.txt:5
msgid "Nick Coghlan <ncoghlan@gmail.com>"
msgstr ""

#: ../../pep-0346.txt
msgid "Status"
msgstr ""

#: ../../pep-0346.txt:6
msgid "Withdrawn"
msgstr ""

#: ../../pep-0346.txt
msgid "Type"
msgstr ""

#: ../../pep-0346.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0346.txt
msgid "Created"
msgstr ""

#: ../../pep-0346.txt:9
msgid "06-May-2005"
msgstr ""

#: ../../pep-0346.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0346.txt:10
msgid "2.5"
msgstr ""

#: ../../pep-0346.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0346.txt:15
msgid "Abstract"
msgstr ""

#: ../../pep-0346.txt:17
msgid ""
"This PEP is a combination of PEP 310's \"Reliable Acquisition/Release "
"Pairs\" with the \"Anonymous Block Statements\" of Guido's PEP 340.  This"
" PEP aims to take the good parts of PEP 340, blend them with parts of PEP"
" 310 and rearrange the lot into an elegant whole.  It borrows from "
"various other PEPs in order to paint a complete picture, and is intended "
"to stand on its own."
msgstr ""

#: ../../pep-0346.txt:26
msgid "Author's Note"
msgstr ""

#: ../../pep-0346.txt:28
msgid ""
"During the discussion of PEP 340, I maintained drafts of this PEP as PEP "
"3XX on my own website (since I didn't have CVS access to update a "
"submitted PEP fast enough to track the activity on python-dev)."
msgstr ""

#: ../../pep-0346.txt:32
msgid ""
"Since the first draft of this PEP, Guido wrote PEP 343 as a simplified "
"version of PEP 340.  PEP 343 (at the time of writing) uses the exact same"
" semantics for the new statements as this PEP, but uses a slightly "
"different mechanism to allow generators to be used to write statement "
"templates.  However, Guido has indicated that he intends to accept a new "
"PEP being written by Raymond Hettinger that will integrate PEP 288 and "
"PEP 325, and will permit a generator decorator like the one described in "
"this PEP to be used to write statement templates for PEP 343. The other "
"difference was the choice of keyword ('with' versus 'do') and Guido has "
"stated he will organise a vote on that in the context of PEP 343."
msgstr ""

#: ../../pep-0346.txt:44
msgid ""
"Accordingly, the version of this PEP submitted for archiving on "
"python.org is to be WITHDRAWN immediately after submission.  PEP 343 and "
"the combined generator enhancement PEP will cover the important ideas."
msgstr ""

#: ../../pep-0346.txt:51
msgid "Introduction"
msgstr ""

#: ../../pep-0346.txt:53
msgid ""
"This PEP proposes that Python's ability to reliably manage resources be "
"enhanced by the introduction of a new ``with`` statement that allows "
"factoring out of arbitrary ``try``/``finally`` and some "
"``try``/``except``/``else`` boilerplate.  The new construct is called a "
"'user defined statement', and the associated class definitions are called"
" 'statement templates'."
msgstr ""

#: ../../pep-0346.txt:60
msgid ""
"The above is the main point of the PEP.  However, if that was all it "
"said, then PEP 310 would be sufficient and this PEP would be essentially "
"redundant. Instead, this PEP recommends additional enhancements that make"
" it natural to write these statement templates using appropriately "
"decorated generators.  A side effect of those enhancements is that it "
"becomes important to appropriately deal with the management of resources "
"inside generators."
msgstr ""

#: ../../pep-0346.txt:68
msgid ""
"This is quite similar to PEP 343, but the exceptions that occur are re-"
"raised inside the generators frame, and the issue of generator "
"finalisation needs to be addressed as a result.  The template generator "
"decorator suggested by this PEP also creates reusable templates, rather "
"than the single use templates of PEP 340."
msgstr ""

#: ../../pep-0346.txt:74
msgid ""
"In comparison to PEP 340, this PEP eliminates the ability to suppress "
"exceptions, and makes the user defined statement a non-looping construct."
"  The other main difference is the use of a decorator to turn generators "
"into statement templates, and the incorporation of ideas for addressing "
"iterator finalisation."
msgstr ""

#: ../../pep-0346.txt:80
msgid ""
"If all that seems like an ambitious operation. . . well, Guido was the "
"one to set the bar that high when he wrote PEP 340 :)"
msgstr ""

#: ../../pep-0346.txt:85
msgid "Relationship with other PEPs"
msgstr ""

#: ../../pep-0346.txt:87
msgid ""
"This PEP competes directly with PEP 310 [1]_, PEP 340 [2]_ and PEP 343 "
"[3]_, as those PEPs all describe alternative mechanisms for handling "
"deterministic resource management."
msgstr ""

#: ../../pep-0346.txt:91
msgid ""
"It does not compete with PEP 342 [4]_ which splits off PEP 340's "
"enhancements related to passing data into iterators.  The associated "
"changes to the ``for`` loop semantics would be combined with the iterator"
" finalisation changes suggested in this PEP.  User defined statements "
"would not be affected."
msgstr ""

#: ../../pep-0346.txt:97
msgid ""
"Neither does this PEP compete with the generator enhancements described "
"in PEP 288 [5]_.  While this PEP proposes the ability to inject "
"exceptions into generator frames, it is an internal implementation "
"detail, and does not require making that ability publicly available to "
"Python code.  PEP 288 is, in part, about making that implementation "
"detail easily accessible."
msgstr ""

#: ../../pep-0346.txt:104
msgid ""
"This PEP would, however, make the generator resource release support "
"described in PEP 325 [6]_ redundant - iterators which require "
"finalisation should provide an appropriate implementation of the "
"statement template protocol."
msgstr ""

#: ../../pep-0346.txt:111
msgid "User defined statements"
msgstr ""

#: ../../pep-0346.txt:113
msgid ""
"To steal the motivating example from PEP 310, correct handling of a "
"synchronisation lock currently looks like this::"
msgstr ""

#: ../../pep-0346.txt:122
msgid "Like PEP 310, this PEP proposes that such code be able to be written as::"
msgstr ""

#: ../../pep-0346.txt:128
msgid ""
"These user defined statements are primarily designed to allow easy "
"factoring of ``try`` blocks that are not easily converted to functions.  "
"This is most commonly the case when the exception handling pattern is "
"consistent, but the body of the ``try`` block changes. With a user-"
"defined statement, it is straightforward to factor out the exception "
"handling into a statement template, with the body of the ``try`` clause "
"provided inline in the user code."
msgstr ""

#: ../../pep-0346.txt:136
msgid ""
"The term 'user defined statement' reflects the fact that the meaning of a"
" ``with`` statement is governed primarily by the statement template used,"
" and programmers are free to create their own statement templates, just "
"as they are free to create their own iterators for use in ``for`` loops."
msgstr ""

#: ../../pep-0346.txt:144
msgid "Usage syntax for user defined statements"
msgstr ""

#: ../../pep-0346.txt:146
msgid "The proposed syntax is simple::"
msgstr ""

#: ../../pep-0346.txt:153
msgid "Semantics for user defined statements"
msgstr ""

#: ../../pep-0346.txt:175
msgid ""
"Other than ``VAR1``, none of the local variables shown above will be "
"visible to user code.  Like the iteration variable in a ``for`` loop, "
"``VAR1`` is visible in both ``BLOCK1`` and code following the user "
"defined statement."
msgstr ""

#: ../../pep-0346.txt:180
msgid ""
"Note that the statement template can only react to exceptions, it cannot "
"suppress them.  See `Rejected Options`_ for an explanation as to why."
msgstr ""

#: ../../pep-0346.txt:186
msgid "Statement template protocol: ``__enter__``"
msgstr ""

#: ../../pep-0346.txt:188
msgid ""
"The ``__enter__()`` method takes no arguments, and if it raises an "
"exception, ``BLOCK1`` is never executed.  If this happens, the "
"``__exit__()`` method is not called.  The value returned by this method "
"is assigned to VAR1 if the ``as`` clause is used.  Object's with no other"
" value to return should generally return ``self`` rather than ``None`` to"
" permit in-place creation in the ``with`` statement."
msgstr ""

#: ../../pep-0346.txt:195
msgid ""
"Statement templates should use this method to set up the conditions that "
"are to exist during execution of the statement (e.g. acquisition of a "
"synchronisation lock)."
msgstr ""

#: ../../pep-0346.txt:199
msgid ""
"Statement templates which are not always usable (e.g. closed file "
"objects) should raise a ``RuntimeError`` if an attempt is made to call "
"``__enter__()`` when the template is not in a valid state."
msgstr ""

#: ../../pep-0346.txt:205
msgid "Statement template protocol: ``__exit__``"
msgstr ""

#: ../../pep-0346.txt:207
msgid ""
"The ``__exit__()`` method accepts three arguments which correspond to the"
" three \"arguments\" to the ``raise`` statement: type, value, and "
"traceback.  All arguments are always supplied, and will be set to "
"``None`` if no exception occurred.  This method will be called exactly "
"once by the ``with`` statement machinery if the ``__enter__()`` method "
"completes successfully."
msgstr ""

#: ../../pep-0346.txt:214
msgid ""
"Statement templates perform their exception handling in this method. If "
"the first argument is ``None``, it indicates non-exceptional completion "
"of ``BLOCK1`` - execution either reached the end of block, or early "
"completion was forced using a ``return``, ``break`` or ``continue`` "
"statement.  Otherwise, the three arguments reflect the exception that "
"terminated ``BLOCK1``."
msgstr ""

#: ../../pep-0346.txt:221
msgid ""
"Any exceptions raised by the ``__exit__()`` method are propagated to the "
"scope containing the ``with`` statement.  If the user code in ``BLOCK1`` "
"also raised an exception, that exception would be lost, and replaced by "
"the one raised by the ``__exit__()`` method."
msgstr ""

#: ../../pep-0346.txt:228
msgid "Factoring out arbitrary exception handling"
msgstr ""

#: ../../pep-0346.txt:230
msgid "Consider the following exception handling arrangement::"
msgstr ""

#: ../../pep-0346.txt:247
msgid "It can be roughly translated to a statement template as follows::"
msgstr ""

#: ../../pep-0346.txt:276
msgid "Which can then be used as::"
msgstr ""

#: ../../pep-0346.txt:281
msgid ""
"However, there are two important semantic differences between this code "
"and the original ``try`` statement."
msgstr ""

#: ../../pep-0346.txt:284
msgid ""
"Firstly, in the original ``try`` statement, if a ``break``, ``return`` or"
" ``continue`` statement is encountered in ``TRY_BLOCK``, only "
"``FINALLY_BLOCK`` will be executed as the statement completes.  With the "
"statement template, ``ELSE_BLOCK`` will also execute, as these statements"
" are treated like any other non-exceptional block termination.  For use "
"cases where it matters, this is likely to be a good thing (see "
"``transaction`` in the Examples_), as this hole where neither the "
"``except`` nor the ``else`` clause gets executed is easy to forget when "
"writing exception handlers."
msgstr ""

#: ../../pep-0346.txt:294
msgid ""
"Secondly, the statement template will not suppress any exceptions. If, "
"for example, the original code suppressed the ``exc_type1`` and "
"``exc_type2`` exceptions, then this would still need to be done inline in"
" the user code::"
msgstr ""

#: ../../pep-0346.txt:305
msgid ""
"However, even in these cases where the suppression of exceptions needs to"
" be made explicit, the amount of boilerplate repeated at the calling site"
" is significantly reduced (See `Rejected Options`_ for further discussion"
" of this behaviour)."
msgstr ""

#: ../../pep-0346.txt:310
msgid ""
"In general, not all of the clauses will be needed.  For resource handling"
" (like files or synchronisation locks), it is possible to simply execute "
"the code that would have been part of ``FINALLY_BLOCK`` in the "
"``__exit__()`` method.  This can be seen in the following implementation "
"that makes synchronisation locks into statement templates as mentioned at"
" the beginning of this section::"
msgstr ""

#: ../../pep-0346.txt:328
msgid "Generators"
msgstr ""

#: ../../pep-0346.txt:330
msgid ""
"With their ability to suspend execution, and return control to the "
"calling frame, generators are natural candidates for writing statement "
"templates.  Adding user defined statements to the language does *not* "
"require the generator changes described in this section, thus making this"
" PEP an obvious candidate for a phased implementation (``with`` "
"statements in phase 1, generator integration in phase 2).  The suggested "
"generator updates allow arbitrary exception handling to be factored out "
"like this::"
msgstr ""

#: ../../pep-0346.txt:356
msgid ""
"Notice that, unlike the class based version, none of the blocks need to "
"be modified, as shared values are local variables of the generator's "
"internal frame, including the arguments passed in by the invoking code.  "
"The semantic differences noted earlier (all non-exceptional block "
"termination triggers the ``else`` clause, and the template is unable to "
"suppress exceptions) still apply."
msgstr ""

#: ../../pep-0346.txt:365
msgid "Default value for ``yield``"
msgstr ""

#: ../../pep-0346.txt:367
msgid ""
"When creating a statement template with a generator, the ``yield`` "
"statement will often be used solely to return control to the body of the "
"user defined statement, rather than to return a useful value."
msgstr ""

#: ../../pep-0346.txt:371
msgid ""
"Accordingly, if this PEP is accepted, ``yield``, like ``return``, will "
"supply a default value of ``None`` (i.e. ``yield`` and ``yield None`` "
"will become equivalent statements)."
msgstr ""

#: ../../pep-0346.txt:375
msgid ""
"This same change is being suggested in PEP 342.  Obviously, it would only"
" need to be implemented once if both PEPs were accepted :)"
msgstr ""

#: ../../pep-0346.txt:380
msgid "Template generator decorator: ``statement_template``"
msgstr ""

#: ../../pep-0346.txt:382
msgid ""
"As with PEP 343, a new decorator is suggested that wraps a generator in "
"an object with the appropriate statement template semantics. Unlike PEP "
"343, the templates suggested here are reusable, as the generator is "
"instantiated anew in each call to ``__enter__()``. Additionally, any "
"exceptions that occur in ``BLOCK1`` are re-raised in the generator's "
"internal frame::"
msgstr ""

#: ../../pep-0346.txt:429
msgid "Template generator wrapper: ``__enter__()`` method"
msgstr ""

#: ../../pep-0346.txt:431
msgid ""
"The template generator wrapper has an ``__enter__()`` method that creates"
" a new instance of the contained generator, and then invokes ``next()`` "
"once.  It will raise a ``RuntimeError`` if the last generator instance "
"has not been cleaned up, or if the generator terminates instead of "
"yielding a value."
msgstr ""

#: ../../pep-0346.txt:439
msgid "Template generator wrapper: ``__exit__()`` method"
msgstr ""

#: ../../pep-0346.txt:441
msgid ""
"The template generator wrapper has an ``__exit__()`` method that simply "
"invokes ``next()`` on the generator if no exception is passed in.  If an "
"exception is passed in, it is re-raised in the contained generator at the"
" point of the last ``yield`` statement."
msgstr ""

#: ../../pep-0346.txt:446
msgid ""
"In either case, the generator wrapper will raise a RuntimeError if the "
"internal frame does not terminate as a result of the operation.  The "
"``__exit__()`` method will always clean up the reference to the used "
"generator instance, permitting ``__enter__()`` to be called again."
msgstr ""

#: ../../pep-0346.txt:451
msgid ""
"A ``StopIteration`` raised by the body of the user defined statement may "
"be inadvertently suppressed inside the ``__exit__()`` method, but this is"
" unimportant, as the originally raised exception still propagates "
"correctly."
msgstr ""

#: ../../pep-0346.txt:458
msgid "Injecting exceptions into generators"
msgstr ""

#: ../../pep-0346.txt:460
msgid ""
"To implement the ``__exit__()`` method of the template generator wrapper,"
" it is necessary to inject exceptions into the internal frame of the "
"generator.  This is new implementation level behaviour that has no "
"current Python equivalent."
msgstr ""

#: ../../pep-0346.txt:465
msgid ""
"The injection mechanism (referred to as ``_inject_exception`` in this "
"PEP) raises an exception in the generator's frame with the specified "
"type, value and traceback information.  This means that the exception "
"looks like the original if it is allowed to propagate."
msgstr ""

#: ../../pep-0346.txt:470
msgid ""
"For the purposes of this PEP, there is no need to make this capability "
"available outside the Python implementation code."
msgstr ""

#: ../../pep-0346.txt:475
msgid "Generator finalisation"
msgstr ""

#: ../../pep-0346.txt:477
msgid ""
"To support resource management in template generators, this PEP will "
"eliminate the restriction on ``yield`` statements inside the ``try`` "
"block of a ``try``/``finally`` statement.  Accordingly, generators which "
"require the use of a file or some such object can ensure the object is "
"managed correctly through the use of ``try``/``finally`` or ``with`` "
"statements."
msgstr ""

#: ../../pep-0346.txt:484
msgid ""
"This restriction will likely need to be lifted globally - it would be "
"difficult to restrict it so that it was only permitted inside generators "
"used to define statement templates.  Accordingly, this PEP includes "
"suggestions designed to ensure generators which are not used as statement"
" templates are still finalised appropriately."
msgstr ""

#: ../../pep-0346.txt:492
msgid "Generator finalisation: ``TerminateIteration`` exception"
msgstr ""

#: ../../pep-0346.txt:494
msgid "A new exception is proposed::"
msgstr ""

#: ../../pep-0346.txt:498
msgid ""
"The new exception is injected into a generator in order to request "
"finalisation.  It should not be suppressed by well-behaved code."
msgstr ""

#: ../../pep-0346.txt:503
msgid "Generator finalisation: ``__del__()`` method"
msgstr ""

#: ../../pep-0346.txt:505
msgid ""
"To ensure a generator is finalised eventually (within the limits of "
"Python's garbage collection), generators will acquire a ``__del__()`` "
"method with the following semantics::"
msgstr ""

#: ../../pep-0346.txt:517
msgid "Deterministic generator finalisation"
msgstr ""

#: ../../pep-0346.txt:519
msgid ""
"There is a simple way to provide deterministic finalisation of generators"
" - give them appropriate ``__enter__()`` and ``__exit__()`` methods::"
msgstr ""

#: ../../pep-0346.txt:532
msgid ""
"Then any generator can be finalised promptly by wrapping the relevant "
"``for`` loop inside a ``with`` statement::"
msgstr ""

#: ../../pep-0346.txt:539
msgid ""
"(See the Examples_ for the definition of ``all_lines``, and the reason it"
" requires prompt finalisation)"
msgstr ""

#: ../../pep-0346.txt:542
msgid "Compare the above example to the usage of file objects::"
msgstr ""

#: ../../pep-0346.txt:550
msgid "Generators as user defined statement templates"
msgstr ""

#: ../../pep-0346.txt:552
msgid ""
"When used to implement a user defined statement, a generator should yield"
" only once on a given control path.  The result of that yield will then "
"be provided as the result of the generator's ``__enter__()`` method.  "
"Having a single ``yield`` on each control path ensures that the internal "
"frame will terminate when the generator's ``__exit__()`` method is "
"called.  Multiple ``yield`` statements on a single control path will "
"result in a ``RuntimeError`` being raised by the ``__exit__()`` method "
"when the internal frame fails to terminate correctly.  Such an error "
"indicates a bug in the statement template."
msgstr ""

#: ../../pep-0346.txt:562
msgid ""
"To respond to exceptions, or to clean up resources, it is sufficient to "
"wrap the ``yield`` statement in an appropriately constructed ``try`` "
"statement.  If execution resumes after the ``yield`` without an "
"exception, the generator knows that the body of the ``do`` statement "
"completed without incident."
msgstr ""

#: ../../pep-0346.txt:570
msgid "Examples"
msgstr ""

#: ../../pep-0346.txt:572
msgid ""
"A template for ensuring that a lock, acquired at the start of a block, is"
" released when the block is left::"
msgstr ""

#: ../../pep-0346.txt:583 ../../pep-0346.txt:602 ../../pep-0346.txt:618
#: ../../pep-0346.txt:634 ../../pep-0346.txt:651 ../../pep-0346.txt:671
#: ../../pep-0346.txt:710 ../../pep-0346.txt:726 ../../pep-0346.txt:746
#: ../../pep-0346.txt:785
msgid "Used as follows::"
msgstr ""

#: ../../pep-0346.txt:590
msgid ""
"A template for opening a file that ensures the file is closed when the "
"block is left::"
msgstr ""

#: ../../pep-0346.txt:608
msgid "A template for committing or rolling back a database transaction::"
msgstr ""

#: ../../pep-0346.txt:626
msgid "It is possible to nest blocks and combine templates::"
msgstr ""

#: ../../pep-0346.txt:640
msgid "Redirect stdout temporarily::"
msgstr ""

#: ../../pep-0346.txt:657
msgid "A variant on ``open()`` that also returns an error condition::"
msgstr ""

#: ../../pep-0346.txt:679
msgid "Find the first file with a specific header::"
msgstr ""

#: ../../pep-0346.txt:686
msgid ""
"Find the first item you can handle, holding a lock for the entire loop, "
"or just for each iteration::"
msgstr ""

#: ../../pep-0346.txt:699
msgid ""
"Hold a lock while inside a generator, but release it when returning "
"control to the outer scope::"
msgstr ""

#: ../../pep-0346.txt:717
msgid ""
"Read the lines from a collection of files (e.g. processing multiple "
"configuration sources)::"
msgstr ""

#: ../../pep-0346.txt:732
msgid "Not all uses need to involve resource management::"
msgstr ""

#: ../../pep-0346.txt:759
msgid ""
"From PEP 343, another useful example would be an operation that blocks "
"signals.  The use could be like this::"
msgstr ""

#: ../../pep-0346.txt:767
msgid ""
"An optional argument might be a list of signals to be blocked; by default"
" all signals are blocked.  The implementation is left as an exercise to "
"the reader."
msgstr ""

#: ../../pep-0346.txt:771
msgid "Another use for this feature is for Decimal contexts::"
msgstr ""

#: ../../pep-0346.txt:793
msgid "Open Issues"
msgstr ""

#: ../../pep-0346.txt:795
msgid "None, as this PEP has been withdrawn."
msgstr ""

#: ../../pep-0346.txt:799
msgid "Rejected Options"
msgstr ""

#: ../../pep-0346.txt:802
msgid "Having the basic construct be a looping construct"
msgstr ""

#: ../../pep-0346.txt:804
msgid ""
"The major issue with this idea, as illustrated by PEP 340's ``block`` "
"statements, is that it causes problems with factoring ``try`` statements "
"that are inside loops, and contain ``break`` and ``continue`` statements "
"(as these statements would then apply to the ``block`` construct, instead"
" of the original loop).  As a key goal is to be able to factor out "
"arbitrary exception handling (other than suppression) into statement "
"templates, this is a definite problem."
msgstr ""

#: ../../pep-0346.txt:812
msgid ""
"There is also an understandability problem, as can be seen in the "
"Examples_.  In the example showing acquisition of a lock either for an "
"entire loop, or for each iteration of the loop, if the user defined "
"statement was itself a loop, moving it from outside the ``for`` loop to "
"inside the ``for`` loop would have major semantic implications, beyond "
"those one would expect."
msgstr ""

#: ../../pep-0346.txt:819
msgid ""
"Finally, with a looping construct, there are significant problems with "
"TOOWTDI, as it is frequently unclear whether a particular situation "
"should be handled with a conventional ``for`` loop or the new looping "
"construct.  With the current PEP, there is no such problem - ``for`` "
"loops continue to be used for iteration, and the new ``do`` statements "
"are used to factor out exception handling."
msgstr ""

#: ../../pep-0346.txt:826
msgid ""
"Another issue, specifically with PEP 340's anonymous block statements, is"
" that they make it quite difficult to write statement templates directly "
"(i.e. not using a generator).  This problem is addressed by the current "
"proposal, as can be seen by the relative simplicity of the various class "
"based implementations of statement templates in the Examples_."
msgstr ""

#: ../../pep-0346.txt:835
msgid "Allowing statement templates to suppress exceptions"
msgstr ""

#: ../../pep-0346.txt:837
msgid ""
"Earlier versions of this PEP gave statement templates the ability to "
"suppress exceptions.  The BDFL expressed concern over the associated "
"complexity, and I agreed after reading an article by Raymond Chen about "
"the evils of hiding flow control inside macros in C code [7]_."
msgstr ""

#: ../../pep-0346.txt:842
msgid ""
"Removing the suppression ability eliminated a whole lot of complexity "
"from both the explanation and implementation of user defined statements, "
"further supporting it as the correct choice.  Older versions of the PEP "
"had to jump through some horrible hoops to avoid inadvertently "
"suppressing exceptions in ``__exit__()`` methods - that issue does not "
"exist with the current suggested semantics."
msgstr ""

#: ../../pep-0346.txt:849
msgid ""
"There was one example (``auto_retry``) that actually used the ability to "
"suppress exceptions.  This use case, while not quite as elegant, has "
"significantly more obvious control flow when written out in full in the "
"user code::"
msgstr ""

#: ../../pep-0346.txt:864
msgid "For what it's worth, the perverse could still write this as::"
msgstr ""

#: ../../pep-0346.txt:873
msgid ""
"To protect the innocent, the code to actually support that is not "
"included here."
msgstr ""

#: ../../pep-0346.txt:878
msgid "Differentiating between non-exceptional exits"
msgstr ""

#: ../../pep-0346.txt:880
msgid ""
"Earlier versions of this PEP allowed statement templates to distinguish "
"between exiting the block normally, and exiting via a ``return``, "
"``break`` or ``continue`` statement.  The BDFL flirted with a similar "
"idea in PEP 343 and its associated discussion.  This added significant "
"complexity to the description of the semantics, and it required each and "
"every statement template to decide whether or not those statements should"
" be treated like exceptions, or like a normal mechanism for exiting the "
"block."
msgstr ""

#: ../../pep-0346.txt:889
msgid ""
"This template-by-template decision process raised great potential for "
"confusion - consider if one database connector provided a transaction "
"template that treated early exits like an exception, whereas a second "
"connector treated them as normal block termination."
msgstr ""

#: ../../pep-0346.txt:894
msgid ""
"Accordingly, this PEP now uses the simplest solution - early exits appear"
" identical to normal block termination as far as the statement template "
"is concerned."
msgstr ""

#: ../../pep-0346.txt:900
msgid "Not injecting raised exceptions into generators"
msgstr ""

#: ../../pep-0346.txt:902
msgid ""
"PEP 343 suggests simply invoking next() unconditionally on generators "
"used to define statement templates.  This means the template generators "
"end up looking rather unintuitive, and the retention of the ban against "
"yielding inside ``try``/``finally`` means that Python's exception "
"handling capabilities cannot be used to deal with management of multiple "
"resources."
msgstr ""

#: ../../pep-0346.txt:909
msgid ""
"The alternative which this PEP advocates (injecting raised exceptions "
"into the generator frame), means that multiple resources can be managed "
"elegantly as shown by ``lock_opening`` in the Examples_"
msgstr ""

#: ../../pep-0346.txt:915
msgid "Making all generators statement templates"
msgstr ""

#: ../../pep-0346.txt:917
msgid ""
"Separating the template object from the generator itself makes it "
"possible to have reusable generator templates.  That is, the following "
"code will work correctly if this PEP is accepted::"
msgstr ""

#: ../../pep-0346.txt:929
msgid ""
"The second benefit is that iterator generators and template generators "
"are very different things - the decorator keeps that distinction clear, "
"and prevents one being used where the other is required."
msgstr ""

#: ../../pep-0346.txt:933
msgid ""
"Finally, requiring the decorator allows the native methods of generator "
"objects to be used to implement generator finalisation."
msgstr ""

#: ../../pep-0346.txt:938
msgid "Using ``do`` as the keyword"
msgstr ""

#: ../../pep-0346.txt:940
msgid ""
"``do`` was an alternative keyword proposed during the PEP 340 discussion."
"  It reads well with appropriately named functions, but it reads poorly "
"when used with methods, or with objects that provide native statement "
"template support."
msgstr ""

#: ../../pep-0346.txt:945
msgid ""
"When ``do`` was first suggested, the BDFL had rejected PEP 310's ``with``"
" keyword, based on a desire to use it for a Pascal/Delphi style ``with`` "
"statement.  Since then, the BDFL has retracted this objection, as he no "
"longer intends to provide such a statement.  This change of heart was "
"apparently based on the C# developers reasons for not providing the "
"feature [8]_."
msgstr ""

#: ../../pep-0346.txt:954
msgid "Not having a keyword"
msgstr ""

#: ../../pep-0346.txt:956
msgid ""
"This is an interesting option, and can be made to read quite well. "
"However, it's awkward to look up in the documentation for new users, and "
"strikes some as being too magical.  Accordingly, this PEP goes with a "
"keyword based suggestion."
msgstr ""

#: ../../pep-0346.txt:963
msgid "Enhancing ``try`` statements"
msgstr ""

#: ../../pep-0346.txt:965
msgid ""
"This suggestion involves give bare ``try`` statements a signature similar"
" to that proposed for ``with`` statements."
msgstr ""

#: ../../pep-0346.txt:968
msgid ""
"I think that trying to write a ``with`` statement as an enhanced ``try`` "
"statement makes as much sense as trying to write a ``for`` loop as an "
"enhanced ``while`` loop.  That is, while the semantics of the former can "
"be explained as a particular way of using the latter, the former is not "
"an *instance* of the latter.  The additional semantics added around the "
"more fundamental statement result in a new construct, and the two "
"different statements shouldn't be confused."
msgstr ""

#: ../../pep-0346.txt:976
msgid ""
"This can be seen by the fact that the 'enhanced' ``try`` statement still "
"needs to be explained in terms of a 'non-enhanced' ``try`` statement.  If"
" it's something different, it makes more sense to give it a different "
"name."
msgstr ""

#: ../../pep-0346.txt:983
msgid "Having the template protocol directly reflect ``try`` statements"
msgstr ""

#: ../../pep-0346.txt:985
msgid ""
"One suggestion was to have separate methods in the protocol to cover "
"different parts of the structure of a generalised ``try`` statement. "
"Using the terms ``try``, ``except``, ``else`` and ``finally``, we would "
"have something like::"
msgstr ""

#: ../../pep-0346.txt:1015
msgid ""
"Aside from preferring the addition of two method slots rather than four, "
"I consider it significantly easier to be able to simply reproduce a "
"slightly modified version of the original ``try`` statement code in the "
"``__exit__()`` method (as shown in `Factoring out arbitrary exception "
"handling`_), rather than have to split the functionality amongst several "
"different methods (or figure out which method to use if not all clauses "
"are used by the template)."
msgstr ""

#: ../../pep-0346.txt:1023
msgid ""
"To make this discussion less theoretical, here is the ``transaction`` "
"example implemented using both the two method and the four method "
"protocols instead of a generator.  Both implementations guarantee a "
"commit if a ``break``, ``return`` or ``continue`` statement is "
"encountered (as does the generator-based implementation in the Examples_ "
"section)::"
msgstr ""

#: ../../pep-0346.txt:1065
msgid ""
"There are two more minor points, relating to the specific method names in"
" the suggestion.  The name of the ``__try__()`` method is misleading, as "
"``SETUP_BLOCK`` executes *before* the ``try`` statement is entered, and "
"the name of the ``__else__()`` method is unclear in isolation, as "
"numerous other Python statements include an ``else`` clause."
msgstr ""

#: ../../pep-0346.txt:1074
msgid "Iterator finalisation (WITHDRAWN)"
msgstr ""

#: ../../pep-0346.txt:1076
msgid ""
"The ability to use user defined statements inside generators is likely to"
" increase the need for deterministic finalisation of iterators, as "
"resource management is pushed inside the generators, rather than being "
"handled externally as is currently the case."
msgstr ""

#: ../../pep-0346.txt:1081
msgid ""
"The PEP currently suggests handling this by making all generators "
"statement templates, and using ``with`` statements to handle "
"finalisation.  However, earlier versions of this PEP suggested the "
"following, more complex, solution, that allowed the *author* of a "
"generator to flag the need for finalisation, and have ``for`` loops deal "
"with it automatically.  It is included here as a long, detailed rejected "
"option."
msgstr ""

#: ../../pep-0346.txt:1091
msgid "Iterator protocol addition: ``__finish__``"
msgstr ""

#: ../../pep-0346.txt:1093
msgid ""
"An optional new method for iterators is proposed, called "
"``__finish__()``.  It takes no arguments, and should not return anything."
msgstr ""

#: ../../pep-0346.txt:1097
msgid ""
"The ``__finish__`` method is expected to clean up all resources the "
"iterator has open.  Iterators with a ``__finish__()`` method are called "
"'finishable iterators' for the remainder of the PEP."
msgstr ""

#: ../../pep-0346.txt:1103
msgid "Best effort finalisation"
msgstr ""

#: ../../pep-0346.txt:1105
msgid ""
"A finishable iterator should ensure that it provides a ``__del__`` method"
" that also performs finalisation (e.g. by invoking the ``__finish__()`` "
"method).  This allows Python to still make a best effort at finalisation "
"in the event that deterministic finalisation is not applied to the "
"iterator."
msgstr ""

#: ../../pep-0346.txt:1113
msgid "Deterministic finalisation"
msgstr ""

#: ../../pep-0346.txt:1115
msgid ""
"If the iterator used in a ``for`` loop has a ``__finish__()`` method, the"
" enhanced ``for`` loop semantics will guarantee that that method will be "
"executed, regardless of the means of exiting the loop.  This is important"
" for iterator generators that utilise `user defined statements`_ or the "
"now permitted ``try``/``finally`` statements, or for new iterators that "
"rely on timely finalisation to release allocated resources (e.g. "
"releasing a thread or database connection back into a pool)."
msgstr ""

#: ../../pep-0346.txt:1126
msgid "``for`` loop syntax"
msgstr ""

#: ../../pep-0346.txt:1128
msgid ""
"No changes are suggested to ``for`` loop syntax.  This is just to define "
"the statement parts needed for the description of the semantics::"
msgstr ""

#: ../../pep-0346.txt:1139
msgid "Updated ``for`` loop semantics"
msgstr ""

#: ../../pep-0346.txt:1141
msgid ""
"When the target iterator does not have a ``__finish__()`` method, a "
"``for`` loop will execute as follows (i.e. no change from the status "
"quo)::"
msgstr ""

#: ../../pep-0346.txt:1157
msgid ""
"When the target iterator has a ``__finish__()`` method, a ``for`` loop "
"will execute as follows::"
msgstr ""

#: ../../pep-0346.txt:1175
msgid ""
"The implementation will need to take some care to avoid incurring the "
"``try``/``finally`` overhead when the iterator does not have a "
"``__finish__()`` method."
msgstr ""

#: ../../pep-0346.txt:1181
msgid "Generator iterator finalisation: ``__finish__()`` method"
msgstr ""

#: ../../pep-0346.txt:1183
msgid ""
"When enabled with the appropriate decorator, generators will have a "
"``__finish__()`` method that raises ``TerminateIteration`` in the "
"internal frame::"
msgstr ""

#: ../../pep-0346.txt:1193
msgid ""
"A decorator (e.g. ``needs_finish()``) is required to enable this feature,"
" so that existing generators (which are not expecting finalisation) "
"continue to work as expected."
msgstr ""

#: ../../pep-0346.txt:1199
msgid "Partial iteration of finishable iterators"
msgstr ""

#: ../../pep-0346.txt:1201
msgid ""
"Partial iteration of a finishable iterator is possible, although it "
"requires some care to ensure the iterator is still finalised promptly (it"
" was made finishable for a reason!).  First, we need a class to enable "
"partial iteration of a finishable iterator by hiding the iterator's "
"``__finish__()`` method from the ``for`` loop::"
msgstr ""

#: ../../pep-0346.txt:1218
msgid ""
"Secondly, an appropriate statement template is needed to ensure the "
"iterator is finished eventually::"
msgstr ""

#: ../../pep-0346.txt:1233
msgid "This can then be used as follows::"
msgstr ""

#: ../../pep-0346.txt:1243
msgid ""
"Note that none of the above is needed for an iterator that is not "
"finishable - without a ``__finish__()`` method, it will not be promptly "
"finalised by the ``for`` loop, and hence inherently allows partial "
"iteration.  Allowing partial iteration of non-finishable iterators as the"
" default behaviour is a key element in keeping this addition to the "
"iterator protocol backwards compatible."
msgstr ""

#: ../../pep-0346.txt:1252
msgid "Acknowledgements"
msgstr ""

#: ../../pep-0346.txt:1254
msgid ""
"The acknowledgements section for PEP 340 applies, since this text grew "
"out of the discussion of that PEP, but additional thanks go to Michael "
"Hudson, Paul Moore and Guido van Rossum for writing PEP 310 and PEP 340 "
"in the first place, and to (in no meaningful order) Fredrik Lundh, "
"Phillip J. Eby, Steven Bethard, Josiah Carlson, Greg Ewing, Tim Delaney "
"and Arnold deVos for prompting particular ideas that made their way into "
"this text."
msgstr ""

#: ../../pep-0346.txt:1264
msgid "References"
msgstr ""

#: ../../pep-0346.txt:1266
msgid ""
"Reliable Acquisition/Release Pairs "
"(http://www.python.org/dev/peps/pep-0310/)"
msgstr ""

#: ../../pep-0346.txt:1269
msgid "Anonymous block statements (http://www.python.org/dev/peps/pep-0340/)"
msgstr ""

#: ../../pep-0346.txt:1272
msgid "Anonymous blocks, redux (http://www.python.org/dev/peps/pep-0343/)"
msgstr ""

#: ../../pep-0346.txt:1275
msgid "Enhanced Iterators (http://www.python.org/dev/peps/pep-0342/)"
msgstr ""

#: ../../pep-0346.txt:1278
msgid ""
"Generator Attributes and Exceptions "
"(http://www.python.org/dev/peps/pep-0288/)"
msgstr ""

#: ../../pep-0346.txt:1281
msgid ""
"Resource-Release Support for Generators "
"(http://www.python.org/dev/peps/pep-0325/)"
msgstr ""

#: ../../pep-0346.txt:1284
msgid ""
"A rant against flow control macros "
"(http://blogs.msdn.com/oldnewthing/archive/2005/01/06/347666.aspx)"
msgstr ""

#: ../../pep-0346.txt:1287
msgid ""
"Why doesn't C# have a 'with' statement? "
"(http://msdn.microsoft.com/vcsharp/programming/language/ask/withstatement/)"
msgstr ""

#: ../../pep-0346.txt:1292
msgid "Copyright"
msgstr ""

#: ../../pep-0346.txt:1294
msgid "This document has been placed in the public domain."
msgstr ""

