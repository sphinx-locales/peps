# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0544.txt
msgid "PEP"
msgstr ""

#: ../../pep-0544.txt:1
msgid "544"
msgstr ""

#: ../../pep-0544.txt
msgid "Title"
msgstr ""

#: ../../pep-0544.txt:2
msgid "Protocols: Structural subtyping (static duck typing)"
msgstr ""

#: ../../pep-0544.txt
msgid "Author"
msgstr ""

#: ../../pep-0544.txt:5
msgid ""
"Ivan Levkivskyi <levkivskyi@gmail.com>, Jukka Lehtosalo "
"<jukka.lehtosalo@iki.fi>, ≈Åukasz Langa <lukasz@python.org>"
msgstr ""

#: ../../pep-0544.txt
msgid "BDFL-Delegate"
msgstr ""

#: ../../pep-0544.txt:6
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../../pep-0544.txt
msgid "Discussions-To"
msgstr ""

#: ../../pep-0544.txt:7
msgid "Python-Dev <python-dev@python.org>"
msgstr ""

#: ../../pep-0544.txt
msgid "Status"
msgstr ""

#: ../../pep-0544.txt:8
msgid "Accepted"
msgstr ""

#: ../../pep-0544.txt
msgid "Type"
msgstr ""

#: ../../pep-0544.txt:9
msgid "Standards Track"
msgstr ""

#: ../../pep-0544.txt
msgid "Created"
msgstr ""

#: ../../pep-0544.txt:11
msgid "05-Mar-2017"
msgstr ""

#: ../../pep-0544.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0544.txt:12
msgid "3.8"
msgstr ""

#: ../../pep-0544.txt
msgid "Resolution"
msgstr ""

#: ../../pep-0544.txt:13
msgid ""
"https://mail.python.org/archives/list/typing-"
"sig@python.org/message/FDO4KFYWYQEP3U2HVVBEBR3SXPHQSHYR/"
msgstr ""

#: ../../pep-0544.txt:17
msgid "Abstract"
msgstr ""

#: ../../pep-0544.txt:19
msgid ""
"Type hints introduced in PEP 484 can be used to specify type metadata for"
" static type checkers and other third party tools. However, PEP 484 only "
"specifies the semantics of *nominal* subtyping. In this PEP we specify "
"static and runtime semantics of protocol classes that will provide a "
"support for *structural* subtyping (static duck typing)."
msgstr ""

#: ../../pep-0544.txt:29
msgid "Rationale and Goals"
msgstr ""

#: ../../pep-0544.txt:31
msgid ""
"Currently, PEP 484 and the ``typing`` module [typing]_ define abstract "
"base classes for several common Python protocols such as ``Iterable`` and"
" ``Sized``. The problem with them is that a class has to be explicitly "
"marked to support them, which is unpythonic and unlike what one would "
"normally do in idiomatic dynamically typed Python code. For example, this"
" conforms to PEP 484::"
msgstr ""

#: ../../pep-0544.txt:45
msgid ""
"The same problem appears with user-defined ABCs: they must be explicitly "
"subclassed or registered. This is particularly difficult to do with "
"library types as the type objects may be hidden deep in the "
"implementation of the library. Also, extensive use of ABCs might impose "
"additional runtime costs."
msgstr ""

#: ../../pep-0544.txt:51
msgid ""
"The intention of this PEP is to solve all these problems by allowing "
"users to write the above code without explicit base classes in the class "
"definition, allowing ``Bucket`` to be implicitly considered a subtype of "
"both ``Sized`` and ``Iterable[int]`` by static type checkers using "
"structural [wiki-structural]_ subtyping::"
msgstr ""

#: ../../pep-0544.txt:67
msgid ""
"Note that ABCs in ``typing`` module already provide structural behavior "
"at runtime, ``isinstance(Bucket(), Iterable)`` returns ``True``. The main"
" goal of this proposal is to support such behavior statically. The same "
"functionality will be provided for user-defined protocols, as specified "
"below. The above code with a protocol class matches common Python "
"conventions much better. It is also automatically extensible and works "
"with additional, unrelated classes that happen to implement the required "
"protocol."
msgstr ""

#: ../../pep-0544.txt:78
msgid "Nominal vs structural subtyping"
msgstr ""

#: ../../pep-0544.txt:80
msgid ""
"Structural subtyping is natural for Python programmers since it matches "
"the runtime semantics of duck typing: an object that has certain "
"properties is treated independently of its actual runtime class. However,"
" as discussed in PEP 483, both nominal and structural subtyping have "
"their strengths and weaknesses. Therefore, in this PEP we *do not "
"propose* to replace the nominal subtyping described by PEP 484 with "
"structural subtyping completely. Instead, protocol classes as specified "
"in this PEP complement normal classes, and users are free to choose where"
" to apply a particular solution. See section on `rejected`_ ideas at the "
"end of this PEP for additional motivation."
msgstr ""

#: ../../pep-0544.txt:93
msgid "Non-goals"
msgstr ""

#: ../../pep-0544.txt:95
msgid ""
"At runtime, protocol classes will be simple ABCs. There is no intent to "
"provide sophisticated runtime instance and class checks against protocol "
"classes. This would be difficult and error-prone and will contradict the "
"logic of PEP 484. As well, following PEP 484 and PEP 526 we state that "
"protocols are **completely optional**:"
msgstr ""

#: ../../pep-0544.txt:101
msgid ""
"No runtime semantics will be imposed for variables or parameters "
"annotated with a protocol class."
msgstr ""

#: ../../pep-0544.txt:103
msgid ""
"Any checks will be performed only by third-party type checkers and other "
"tools."
msgstr ""

#: ../../pep-0544.txt:105
msgid "Programmers are free to not use them even if they use type annotations."
msgstr ""

#: ../../pep-0544.txt:106
msgid "There is no intent to make protocols non-optional in the future."
msgstr ""

#: ../../pep-0544.txt:108
msgid ""
"To reiterate, providing complex runtime semantics for protocol classes is"
" not a goal of this PEP, the main goal is to provide a support and "
"standards for *static* structural subtyping. The possibility to use "
"protocols in the runtime context as ABCs is rather a minor bonus that "
"exists mostly to provide a seamless transition for projects that already "
"use ABCs."
msgstr ""

#: ../../pep-0544.txt:116
msgid "Existing Approaches to Structural Subtyping"
msgstr ""

#: ../../pep-0544.txt:118
msgid ""
"Before describing the actual specification, we review and comment on "
"existing approaches related to structural subtyping in Python and other "
"languages:"
msgstr ""

#: ../../pep-0544.txt:121
msgid ""
"``zope.interface`` [zope-interfaces]_ was one of the first widely used "
"approaches to structural subtyping in Python. It is implemented by "
"providing special classes to distinguish interface classes from normal "
"classes, to mark interface attributes, and to explicitly declare "
"implementation. For example::"
msgstr ""

#: ../../pep-0544.txt:144
msgid ""
"Zope interfaces support various contracts and constraints for interface "
"classes. For example::"
msgstr ""

#: ../../pep-0544.txt:161
msgid ""
"Even more detailed invariants are supported. However, Zope interfaces "
"rely entirely on runtime validation. Such focus on runtime properties "
"goes beyond the scope of the current proposal, and static support for "
"invariants might be difficult to implement. However, the idea of marking "
"an interface class with a special base class is reasonable and easy to "
"implement both statically and at runtime."
msgstr ""

#: ../../pep-0544.txt:168
msgid ""
"Python abstract base classes [abstract-classes]_ are the standard library"
" tool to provide some functionality similar to structural subtyping. The "
"drawback of this approach is the necessity to either subclass the "
"abstract class or register an implementation explicitly::"
msgstr ""

#: ../../pep-0544.txt:183
msgid ""
"As mentioned in the `rationale`_, we want to avoid such necessity, "
"especially in static context. However, in a runtime context, ABCs are "
"good candidates for protocol classes and they are already used "
"extensively in the ``typing`` module."
msgstr ""

#: ../../pep-0544.txt:188
msgid ""
"Abstract classes defined in ``collections.abc`` module [collections-abc]_"
" are slightly more advanced since they implement a custom "
"``__subclasshook__()`` method that allows runtime structural checks "
"without explicit registration::"
msgstr ""

#: ../../pep-0544.txt:201
msgid ""
"Such behavior seems to be a perfect fit for both runtime and static "
"behavior of protocols. As discussed in `rationale`_, we propose to add "
"static support for such behavior. In addition, to allow users to achieve "
"such runtime behavior for *user-defined* protocols a special "
"``@runtime_checkable`` decorator will be provided, see detailed "
"`discussion`_ below."
msgstr ""

#: ../../pep-0544.txt:207
msgid ""
"TypeScript [typescript]_ provides support for user-defined classes and "
"interfaces. Explicit implementation declaration is not required and "
"structural subtyping is verified statically. For example::"
msgstr ""

#: ../../pep-0544.txt:223
msgid ""
"Note that optional interface members are supported. Also, TypeScript "
"prohibits redundant members in implementations. While the idea of "
"optional members looks interesting, it would complicate this proposal and"
" it is not clear how useful it will be. Therefore, it is proposed to "
"postpone this; see `rejected`_ ideas. In general, the idea of static "
"protocol checking without runtime implications looks reasonable, and "
"basically this proposal follows the same line."
msgstr ""

#: ../../pep-0544.txt:231
msgid ""
"Go [golang]_ uses a more radical approach and makes interfaces the "
"primary way to provide type information. Also, assignments are used to "
"explicitly ensure implementation::"
msgstr ""

#: ../../pep-0544.txt:243
msgid ""
"Both these ideas are questionable in the context of this proposal. See "
"the section on `rejected`_ ideas."
msgstr ""

#: ../../pep-0544.txt:250
msgid "Specification"
msgstr ""

#: ../../pep-0544.txt:253
msgid "Terminology"
msgstr ""

#: ../../pep-0544.txt:255
msgid ""
"We propose to use the term *protocols* for types supporting structural "
"subtyping. The reason is that the term *iterator protocol*, for example, "
"is widely understood in the community, and coming up with a new term for "
"this concept in a statically typed context would just create confusion."
msgstr ""

#: ../../pep-0544.txt:261
msgid ""
"This has the drawback that the term *protocol* becomes overloaded with "
"two subtly different meanings: the first is the traditional, well-known "
"but slightly fuzzy concept of protocols such as iterator; the second is "
"the more explicitly defined concept of protocols in statically typed "
"code. The distinction is not important most of the time, and in other "
"cases we propose to just add a qualifier such as *protocol classes* when "
"referring to the static type concept."
msgstr ""

#: ../../pep-0544.txt:269
msgid ""
"If a class includes a protocol in its MRO, the class is called an "
"*explicit* subclass of the protocol. If a class is a structural subtype "
"of a protocol, it is said to implement the protocol and to be compatible "
"with a protocol. If a class is compatible with a protocol but the "
"protocol is not included in the MRO, the class is an *implicit* subtype "
"of the protocol. (Note that one can explicitly subclass a protocol and "
"still not implement it if a protocol attribute is set to ``None`` in the "
"subclass, see Python [data-model]_ for details.)"
msgstr ""

#: ../../pep-0544.txt:278
msgid ""
"The attributes (variables and methods) of a protocol that are mandatory "
"for other class in order to be considered a structural subtype are called"
" protocol members."
msgstr ""

#: ../../pep-0544.txt:286
msgid "Defining a protocol"
msgstr ""

#: ../../pep-0544.txt:288
msgid ""
"Protocols are defined by including a special new class "
"``typing.Protocol`` (an instance of ``abc.ABCMeta``) in the base classes "
"list, typically at the end of the list. Here is a simple example::"
msgstr ""

#: ../../pep-0544.txt:298
msgid ""
"Now if one defines a class ``Resource`` with a ``close()`` method that "
"has a compatible signature, it would implicitly be a subtype of "
"``SupportsClose``, since the structural subtyping is used for protocol "
"types::"
msgstr ""

#: ../../pep-0544.txt:309
msgid ""
"Apart from few restrictions explicitly mentioned below, protocol types "
"can be used in every context where a normal types can::"
msgstr ""

#: ../../pep-0544.txt:321
msgid ""
"Note that both the user-defined class ``Resource`` and the built-in "
"``IO`` type (the return type of ``open()``) are considered subtypes of "
"``SupportsClose``, because they provide a ``close()`` method with a "
"compatible type signature."
msgstr ""

#: ../../pep-0544.txt:328
msgid "Protocol members"
msgstr ""

#: ../../pep-0544.txt:330
msgid ""
"All methods defined in the protocol class body are protocol members, both"
" normal and decorated with ``@abstractmethod``. If any parameters of a "
"protocol method are not annotated, then their types are assumed to be "
"``Any`` (see PEP 484). Bodies of protocol methods are type checked. An "
"abstract method that should not be called via ``super()`` ought to raise "
"``NotImplementedError``. Example::"
msgstr ""

#: ../../pep-0544.txt:348
msgid ""
"Static methods, class methods, and properties are equally allowed in "
"protocols."
msgstr ""

#: ../../pep-0544.txt:351
msgid ""
"To define a protocol variable, one can use PEP 526 variable annotations "
"in the class body. Additional attributes *only* defined in the body of a "
"method by assignment via ``self`` are not allowed. The rationale for this"
" is that the protocol class implementation is often not shared by "
"subtypes, so the interface should not depend on the default "
"implementation. Examples::"
msgstr ""

#: ../../pep-0544.txt:377
msgid ""
"To distinguish between protocol class variables and protocol instance "
"variables, the special ``ClassVar`` annotation should be used as "
"specified by PEP 526. By default, protocol variables as defined above are"
" considered readable and writable. To define a read-only protocol "
"variable, one can use an (abstract) property."
msgstr ""

#: ../../pep-0544.txt:385
msgid "Explicitly declaring implementation"
msgstr ""

#: ../../pep-0544.txt:387
msgid ""
"To explicitly declare that a certain class implements a given protocol, "
"it can be used as a regular base class. In this case a class could use "
"default implementations of protocol members. Static analysis tools are "
"expected to automatically detect that a class implements a given "
"protocol. So while it's possible to subclass a protocol explicitly, it's "
"*not necessary* to do so for the sake of type-checking."
msgstr ""

#: ../../pep-0544.txt:394
msgid ""
"The default implementations cannot be used if the subtype relationship is"
" implicit and only via structural subtyping -- the semantics of "
"inheritance is not changed. Examples::"
msgstr ""

#: ../../pep-0544.txt:428
msgid ""
"Note that there is little difference between explicit and implicit "
"subtypes, the main benefit of explicit subclassing is to get some "
"protocol methods \"for free\". In addition, type checkers can statically "
"verify that the class actually implements the protocol correctly::"
msgstr ""

#: ../../pep-0544.txt:446
msgid ""
"A class can explicitly inherit from multiple protocols and also from "
"normal classes. In this case methods are resolved using normal MRO and a "
"type checker verifies that all subtyping are correct. The semantics of "
"``@abstractmethod`` is not changed, all of them must be implemented by an"
" explicit subclass before it can be instantiated."
msgstr ""

#: ../../pep-0544.txt:454
msgid "Merging and extending protocols"
msgstr ""

#: ../../pep-0544.txt:456
msgid ""
"The general philosophy is that protocols are mostly like regular ABCs, "
"but a static type checker will handle them specially. Subclassing a "
"protocol class would not turn the subclass into a protocol unless it also"
" has ``typing.Protocol`` as an explicit base class. Without this base, "
"the class is \"downgraded\" to a regular ABC that cannot be used with "
"structural subtyping. The rationale for this rule is that we don't want "
"to accidentally have some class act as a protocol just because one of its"
" base classes happens to be one. We still slightly prefer nominal "
"subtyping over structural subtyping in the static typing world."
msgstr ""

#: ../../pep-0544.txt:466
msgid ""
"A subprotocol can be defined by having *both* one or more protocols as "
"immediate base classes and also having ``typing.Protocol`` as an "
"immediate base class::"
msgstr ""

#: ../../pep-0544.txt:476
msgid ""
"Now the protocol ``SizedAndClosable`` is a protocol with two methods, "
"``__len__`` and ``close``. If one omits ``Protocol`` in the base class "
"list, this would be a regular (non-protocol) class that must implement "
"``Sized``. Alternatively, one can implement ``SizedAndClosable`` protocol"
" by merging the ``SupportsClose`` protocol from the example in the "
"`definition`_ section with ``typing.Sized``::"
msgstr ""

#: ../../pep-0544.txt:492
msgid ""
"The two definitions of ``SizedAndClosable`` are equivalent. Subclass "
"relationships between protocols are not meaningful when considering "
"subtyping, since structural compatibility is the criterion, not the MRO."
msgstr ""

#: ../../pep-0544.txt:497
msgid ""
"If ``Protocol`` is included in the base class list, all the other base "
"classes must be protocols. A protocol can't extend a regular class, see "
"`rejected`_ ideas for rationale. Note that rules around explicit "
"subclassing are different from regular ABCs, where abstractness is simply"
" defined by having at least one abstract method being unimplemented. "
"Protocol classes must be marked *explicitly*."
msgstr ""

#: ../../pep-0544.txt:506
msgid "Generic protocols"
msgstr ""

#: ../../pep-0544.txt:508
msgid ""
"Generic protocols are important. For example, ``SupportsAbs``, "
"``Iterable`` and ``Iterator`` are generic protocols. They are defined "
"similar to normal non-protocol generic types::"
msgstr ""

#: ../../pep-0544.txt:517
msgid ""
"``Protocol[T, S, ...]`` is allowed as a shorthand for ``Protocol, "
"Generic[T, S, ...]``."
msgstr ""

#: ../../pep-0544.txt:520
msgid ""
"User-defined generic protocols support explicitly declared variance. Type"
" checkers will warn if the inferred variance is different from the "
"declared variance. Examples::"
msgstr ""

#: ../../pep-0544.txt:551
msgid ""
"Note that unlike nominal classes, de facto covariant protocols cannot be "
"declared as invariant, since this can break transitivity of subtyping "
"(see `rejected`_ ideas for details). For example::"
msgstr ""

#: ../../pep-0544.txt:563
msgid "Recursive protocols"
msgstr ""

#: ../../pep-0544.txt:565
msgid ""
"Recursive protocols are also supported. Forward references to the "
"protocol class names can be given as strings as specified by PEP 484. "
"Recursive protocols are useful for representing self-referential data "
"structures like trees in an abstract fashion::"
msgstr ""

#: ../../pep-0544.txt:574
msgid ""
"Note that for recursive protocols, a class is considered a subtype of the"
" protocol in situations where the decision depends on itself. Continuing "
"the previous example::"
msgstr ""

#: ../../pep-0544.txt:595
msgid "Self-types in protocols"
msgstr ""

#: ../../pep-0544.txt:597
msgid ""
"The self-types in protocols follow the corresponding specification [self-"
"types]_ of PEP 484. For example::"
msgstr ""

#: ../../pep-0544.txt:619
msgid "Callback protocols"
msgstr ""

#: ../../pep-0544.txt:621
msgid ""
"Protocols can be used to define flexible callback types that are hard (or"
" even impossible) to express using the ``Callable[...]`` syntax specified"
" by PEP 484, such as variadic, overloaded, and complex generic callbacks."
" They can be defined as protocols with a ``__call__`` member::"
msgstr ""

#: ../../pep-0544.txt:641
msgid ""
"Callback protocols and ``Callable[...]`` types can be used "
"interchangeably."
msgstr ""

#: ../../pep-0544.txt:645
msgid "Using Protocols"
msgstr ""

#: ../../pep-0544.txt:648
msgid "Subtyping relationships with other types"
msgstr ""

#: ../../pep-0544.txt:650
msgid ""
"Protocols cannot be instantiated, so there are no values whose runtime "
"type is a protocol. For variables and parameters with protocol types, "
"subtyping relationships are subject to the following rules:"
msgstr ""

#: ../../pep-0544.txt:654
msgid "A protocol is never a subtype of a concrete type."
msgstr ""

#: ../../pep-0544.txt:655
msgid ""
"A concrete type ``X`` is a subtype of protocol ``P`` if and only if ``X``"
" implements all protocol members of ``P`` with compatible types. In other"
" words, subtyping with respect to a protocol is always structural."
msgstr ""

#: ../../pep-0544.txt:659
msgid ""
"A protocol ``P1`` is a subtype of another protocol ``P2`` if ``P1`` "
"defines all protocol members of ``P2`` with compatible types."
msgstr ""

#: ../../pep-0544.txt:662
msgid ""
"Generic protocol types follow the same rules of variance as non-protocol "
"types. Protocol types can be used in all contexts where any other types "
"can be used, such as in ``Union``, ``ClassVar``, type variables bounds, "
"etc. Generic protocols follow the rules for generic abstract classes, "
"except for using structural compatibility instead of compatibility "
"defined by inheritance relationships."
msgstr ""

#: ../../pep-0544.txt:669
msgid ""
"Static type checkers will recognize protocol implementations, even if the"
" corresponding protocols are *not imported*::"
msgstr ""

#: ../../pep-0544.txt:697
msgid "Unions and intersections of protocols"
msgstr ""

#: ../../pep-0544.txt:699
msgid ""
"``Union`` of protocol classes behaves the same way as for non-protocol "
"classes. For example::"
msgstr ""

#: ../../pep-0544.txt:719
msgid ""
"One can use multiple inheritance to define an intersection of protocols. "
"Example::"
msgstr ""

#: ../../pep-0544.txt:731
msgid ""
"If this will prove to be a widely used scenario, then a special "
"intersection type construct could be added in future as specified by PEP "
"483, see `rejected`_ ideas for more details."
msgstr ""

#: ../../pep-0544.txt:737
msgid "``Type[]`` and class objects vs protocols"
msgstr ""

#: ../../pep-0544.txt:739
msgid ""
"Variables and parameters annotated with ``Type[Proto]`` accept only "
"concrete (non-protocol) subtypes of ``Proto``. The main reason for this "
"is to allow instantiation of parameters with such type. For example::"
msgstr ""

#: ../../pep-0544.txt:756
msgid "The same rule applies to variables::"
msgstr ""

#: ../../pep-0544.txt:763
msgid ""
"Assigning an ABC or a protocol class to a variable is allowed if it is "
"not explicitly typed, and such assignment creates a type alias. For "
"normal (non-abstract) classes, the behavior of ``Type[]`` is not changed."
msgstr ""

#: ../../pep-0544.txt:768
msgid ""
"A class object is considered an implementation of a protocol if accessing"
" all members on it results in types compatible with the protocol members."
" For example::"
msgstr ""

#: ../../pep-0544.txt:787
msgid "``NewType()`` and type aliases"
msgstr ""

#: ../../pep-0544.txt:789
msgid ""
"Protocols are essentially anonymous. To emphasize this point, static type"
" checkers might refuse protocol classes inside ``NewType()`` to avoid an "
"illusion that a distinct type is provided::"
msgstr ""

#: ../../pep-0544.txt:801
msgid ""
"In contrast, type aliases are fully supported, including generic type "
"aliases::"
msgstr ""

#: ../../pep-0544.txt:813
msgid "Modules as implementations of protocols"
msgstr ""

#: ../../pep-0544.txt:815
msgid ""
"A module object is accepted where a protocol is expected if the public "
"interface of the given module is compatible with the expected protocol. "
"For example::"
msgstr ""

#: ../../pep-0544.txt:838
msgid ""
"To determine compatibility of module level functions, the ``self`` "
"argument of the corresponding protocol methods is dropped. For example::"
msgstr ""

#: ../../pep-0544.txt:863
msgid "``@runtime_checkable`` decorator and narrowing types by ``isinstance()``"
msgstr ""

#: ../../pep-0544.txt:865
msgid ""
"The default semantics is that ``isinstance()`` and ``issubclass()`` fail "
"for protocol types. This is in the spirit of duck typing -- protocols "
"basically would be used to model duck typing statically, not explicitly "
"at runtime."
msgstr ""

#: ../../pep-0544.txt:870
msgid ""
"However, it should be possible for protocol types to implement custom "
"instance and class checks when this makes sense, similar to how "
"``Iterable`` and other ABCs in ``collections.abc`` and ``typing`` already"
" do it, but this is limited to non-generic and unsubscripted generic "
"protocols (``Iterable`` is statically equivalent to ``Iterable[Any]``). "
"The ``typing`` module will define a special ``@runtime_checkable`` class "
"decorator that provides the same semantics for class and instance checks "
"as for ``collections.abc`` classes, essentially making them \"runtime "
"protocols\"::"
msgstr ""

#: ../../pep-0544.txt:888
#, python-format
msgid ""
"Note that instance checks are not 100% reliable statically, this is why "
"this behavior is opt-in, see section on `rejected`_ ideas for examples. "
"The most type checkers can do is to treat ``isinstance(obj, Iterator)`` "
"roughly as a simpler way to write ``hasattr(x, '__iter__') and hasattr(x,"
" '__next__')``. To minimize the risks for this feature, the following "
"rules are applied."
msgstr ""

#: ../../pep-0544.txt:895
msgid "**Definitions**:"
msgstr ""

#: ../../pep-0544.txt:897
msgid ""
"*Data, and non-data protocols*: A protocol is called non-data protocol if"
" it only contains methods as members (for example ``Sized``, "
"``Iterator``, etc). A protocol that contains at least one non-method "
"member (like ``x: int``) is called a data protocol."
msgstr ""

#: ../../pep-0544.txt:901
msgid ""
"*Unsafe overlap*: A type ``X`` is called unsafely overlapping with a "
"protocol ``P``, if ``X`` is not a subtype of ``P``, but it is a subtype "
"of the type erased version of ``P`` where all members have type ``Any``. "
"In addition, if at least one element of a union unsafely overlaps with a "
"protocol ``P``, then the whole union is unsafely overlapping with ``P``."
msgstr ""

#: ../../pep-0544.txt:907
msgid "**Specification**:"
msgstr ""

#: ../../pep-0544.txt:909
msgid ""
"A protocol can be used as a second argument in ``isinstance()`` and "
"``issubclass()`` only if it is explicitly opt-in by "
"``@runtime_checkable`` decorator. This requirement exists because "
"protocol checks are not type safe in case of dynamically set attributes, "
"and because type checkers can only prove that an ``isinstance()`` check "
"is safe only for a given class, not for all its subclasses."
msgstr ""

#: ../../pep-0544.txt:915
msgid ""
"``isinstance()`` can be used with both data and non-data protocols, while"
" ``issubclass()`` can be used only with non-data protocols. This "
"restriction exists because some data attributes can be set on an instance"
" in constructor and this information is not always available on the class"
" object."
msgstr ""

#: ../../pep-0544.txt:919
msgid ""
"Type checkers should reject an ``isinstance()`` or ``issubclass()`` call,"
" if there is an unsafe overlap between the type of the first argument and"
" the protocol."
msgstr ""

#: ../../pep-0544.txt:922
msgid ""
"Type checkers should be able to select a correct element from a union "
"after a safe ``isinstance()`` or ``issubclass()`` call. For narrowing "
"from non-union types, type checkers can use their best judgement (this is"
" intentionally unspecified, since a precise specification would require "
"intersection types)."
msgstr ""

#: ../../pep-0544.txt:929
msgid "Using Protocols in Python 2.7 - 3.5"
msgstr ""

#: ../../pep-0544.txt:931
msgid ""
"Variable annotation syntax was added in Python 3.6, so that the syntax "
"for defining protocol variables proposed in `specification`_ section "
"can't be used if support for earlier versions is needed. To define these "
"in a manner compatible with older versions of Python one can use "
"properties. Properties can be settable and/or abstract if needed::"
msgstr ""

#: ../../pep-0544.txt:946
msgid ""
"Also function type comments can be used as per PEP 484 (for example to "
"provide compatibility with Python 2). The ``typing`` module changes "
"proposed in this PEP will also be backported to earlier versions via the "
"backport currently available on PyPI."
msgstr ""

#: ../../pep-0544.txt:953
msgid "Runtime Implementation of Protocol Classes"
msgstr ""

#: ../../pep-0544.txt:956
msgid "Implementation details"
msgstr ""

#: ../../pep-0544.txt:958
msgid ""
"The runtime implementation could be done in pure Python without any "
"effects on the core interpreter and standard library except in the "
"``typing`` module, and a minor update to ``collections.abc``:"
msgstr ""

#: ../../pep-0544.txt:962
msgid "Define class ``typing.Protocol`` similar to ``typing.Generic``."
msgstr ""

#: ../../pep-0544.txt:963
msgid ""
"Implement functionality to detect whether a class is a protocol or not. "
"Add a class attribute ``_is_protocol = True`` if that is the case. Verify"
" that a protocol class only has protocol base classes in the MRO (except "
"for object)."
msgstr ""

#: ../../pep-0544.txt:967
msgid ""
"Implement ``@runtime_checkable`` that allows ``__subclasshook__()`` "
"performing structural instance and subclass checks as in "
"``collections.abc`` classes."
msgstr ""

#: ../../pep-0544.txt:970
msgid ""
"All structural subtyping checks will be performed by static type "
"checkers, such as ``mypy`` [mypy]_. No additional support for protocol "
"validation will be provided at runtime."
msgstr ""

#: ../../pep-0544.txt:976
msgid "Changes in the typing module"
msgstr ""

#: ../../pep-0544.txt:978
msgid "The following classes in ``typing`` module will be protocols:"
msgstr ""

#: ../../pep-0544.txt:980
msgid "``Callable``"
msgstr ""

#: ../../pep-0544.txt:981
msgid "``Awaitable``"
msgstr ""

#: ../../pep-0544.txt:982
msgid "``Iterable``, ``Iterator``"
msgstr ""

#: ../../pep-0544.txt:983
msgid "``AsyncIterable``, ``AsyncIterator``"
msgstr ""

#: ../../pep-0544.txt:984
msgid "``Hashable``"
msgstr ""

#: ../../pep-0544.txt:985
msgid "``Sized``"
msgstr ""

#: ../../pep-0544.txt:986
msgid "``Container``"
msgstr ""

#: ../../pep-0544.txt:987
msgid "``Collection``"
msgstr ""

#: ../../pep-0544.txt:988
msgid "``Reversible``"
msgstr ""

#: ../../pep-0544.txt:989
msgid "``ContextManager``, ``AsyncContextManager``"
msgstr ""

#: ../../pep-0544.txt:990
msgid "``SupportsAbs`` (and other ``Supports*`` classes)"
msgstr ""

#: ../../pep-0544.txt:992
msgid ""
"Most of these classes are small and conceptually simple. It is easy to "
"see what are the methods these protocols implement, and immediately "
"recognize the corresponding runtime protocol counterpart. Practically, "
"few changes will be needed in ``typing`` since some of these classes "
"already behave the necessary way at runtime. Most of these will need to "
"be updated only in the corresponding ``typeshed`` stubs [typeshed]_."
msgstr ""

#: ../../pep-0544.txt:999
msgid ""
"All other concrete generic classes such as ``List``, ``Set``, ``IO``, "
"``Deque``, etc are sufficiently complex that it makes sense to keep them "
"non-protocols (i.e. require code to be explicit about them). Also, it is "
"too easy to leave some methods unimplemented by accident, and explicitly "
"marking the subclass relationship allows type checkers to pinpoint the "
"missing implementations."
msgstr ""

#: ../../pep-0544.txt:1008
msgid "Introspection"
msgstr ""

#: ../../pep-0544.txt:1010
msgid ""
"The existing class introspection machinery (``dir``, ``__annotations__`` "
"etc) can be used with protocols. In addition, all introspection tools "
"implemented in the ``typing`` module will support protocols. Since all "
"attributes need to be defined in the class body based on this proposal, "
"protocol classes will have even better perspective for introspection than"
" regular classes where attributes can be defined implicitly -- protocol "
"attributes can't be initialized in ways that are not visible to "
"introspection (using ``setattr()``, assignment via ``self``, etc.). "
"Still, some things like types of attributes will not be visible at "
"runtime in Python 3.5 and earlier, but this looks like a reasonable "
"limitation."
msgstr ""

#: ../../pep-0544.txt:1021
msgid ""
"There will be only limited support of ``isinstance()`` and "
"``issubclass()`` as discussed above (these will *always* fail with "
"``TypeError`` for subscripted generic protocols, since a reliable answer "
"could not be given at runtime in this case). But together with other "
"introspection tools this give a reasonable perspective for runtime type "
"checking tools."
msgstr ""

#: ../../pep-0544.txt:1031
msgid "Rejected/Postponed Ideas"
msgstr ""

#: ../../pep-0544.txt:1033
msgid ""
"The ideas in this section were previously discussed in [several]_ "
"[discussions]_ [elsewhere]_."
msgstr ""

#: ../../pep-0544.txt:1037
msgid "Make every class a protocol by default"
msgstr ""

#: ../../pep-0544.txt:1039
msgid ""
"Some languages such as Go make structural subtyping the only or the "
"primary form of subtyping. We could achieve a similar result by making "
"all classes protocols by default (or even always). However we believe "
"that it is better to require classes to be explicitly marked as "
"protocols, for the following reasons:"
msgstr ""

#: ../../pep-0544.txt:1045
msgid ""
"Protocols don't have some properties of regular classes. In particular, "
"``isinstance()``, as defined for normal classes, is based on the nominal "
"hierarchy. In order to make everything a protocol by default, and have "
"``isinstance()`` work would require changing its semantics, which won't "
"happen."
msgstr ""

#: ../../pep-0544.txt:1050
msgid ""
"Protocol classes should generally not have many method implementations, "
"as they describe an interface, not an implementation. Most classes have "
"many method implementations, making them bad protocol classes."
msgstr ""

#: ../../pep-0544.txt:1054
msgid ""
"Experience suggests that many classes are not practical as protocols "
"anyway, mainly because their interfaces are too large, complex or "
"implementation-oriented (for example, they may include de facto private "
"attributes and methods without a ``__`` prefix)."
msgstr ""

#: ../../pep-0544.txt:1058
msgid ""
"Most actually useful protocols in existing Python code seem to be "
"implicit. The ABCs in ``typing`` and ``collections.abc`` are rather an "
"exception, but even they are recent additions to Python and most "
"programmers do not use them yet."
msgstr ""

#: ../../pep-0544.txt:1062
msgid ""
"Many built-in functions only accept concrete instances of ``int`` (and "
"subclass instances), and similarly for other built-in classes. Making "
"``int`` a structural type wouldn't be safe without major changes to the "
"Python runtime, which won't happen."
msgstr ""

#: ../../pep-0544.txt:1069
msgid "Protocols subclassing normal classes"
msgstr ""

#: ../../pep-0544.txt:1071
msgid ""
"The main rationale to prohibit this is to preserve transitivity of "
"subtyping, consider this example::"
msgstr ""

#: ../../pep-0544.txt:1088
msgid ""
"Now, ``C`` is a subtype of ``Proto``, and ``Proto`` is a subtype of "
"``Base``. But ``C`` cannot be a subtype of ``Base`` (since the latter is "
"not a protocol). This situation would be really weird. In addition, there"
" is an ambiguity about whether attributes of ``Base`` should become "
"protocol members of ``Proto``."
msgstr ""

#: ../../pep-0544.txt:1096
msgid "Support optional protocol members"
msgstr ""

#: ../../pep-0544.txt:1098
msgid ""
"We can come up with examples where it would be handy to be able to say "
"that a method or data attribute does not need to be present in a class "
"implementing a protocol, but if it is present, it must conform to a "
"specific signature or type. One could use a ``hasattr()`` check to "
"determine whether they can use the attribute on a particular instance."
msgstr ""

#: ../../pep-0544.txt:1104
msgid ""
"Languages such as TypeScript have similar features and apparently they "
"are pretty commonly used. The current realistic potential use cases for "
"protocols in Python don't require these. In the interest of simplicity, "
"we propose to not support optional methods or attributes. We can always "
"revisit this later if there is an actual need."
msgstr ""

#: ../../pep-0544.txt:1112
msgid "Allow only protocol methods and force use of getters and setters"
msgstr ""

#: ../../pep-0544.txt:1114
msgid ""
"One could argue that protocols typically only define methods, but not "
"variables. However, using getters and setters in cases where only a "
"simple variable is needed would be quite unpythonic. Moreover, the "
"widespread use of properties (that often act as type validators) in large"
" code bases is partially due to previous absence of static type checkers "
"for Python, the problem that PEP 484 and this PEP are aiming to solve. "
"For example::"
msgstr ""

#: ../../pep-0544.txt:1140
msgid "Support non-protocol members"
msgstr ""

#: ../../pep-0544.txt:1142
msgid ""
"There was an idea to make some methods \"non-protocol\" (i.e. not "
"necessary to implement, and inherited in explicit subclassing), but it "
"was rejected, since this complicates things. For example, consider this "
"situation::"
msgstr ""

#: ../../pep-0544.txt:1156
msgid ""
"The question is should this be an error? We think most people would "
"expect this to be valid. Therefore, to be on the safe side, we need to "
"require both methods to be implemented in implicit subclasses. In "
"addition, if one looks at definitions in ``collections.abc``, there are "
"very few methods that could be considered \"non-protocol\". Therefore, it"
" was decided to not introduce \"non-protocol\" methods."
msgstr ""

#: ../../pep-0544.txt:1163
msgid ""
"There is only one downside to this: it will require some boilerplate for "
"implicit subtypes of \"large\" protocols. But, this doesn't apply to "
"\"built-in\" protocols that are all \"small\" (i.e. have only few "
"abstract methods). Also, such style is discouraged for user-defined "
"protocols. It is recommended to create compact protocols and combine "
"them."
msgstr ""

#: ../../pep-0544.txt:1171
msgid "Make protocols interoperable with other approaches"
msgstr ""

#: ../../pep-0544.txt:1173
msgid ""
"The protocols as described here are basically a minimal extension to the "
"existing concept of ABCs. We argue that this is the way they should be "
"understood, instead of as something that *replaces* Zope interfaces, for "
"example. Attempting such interoperabilities will significantly complicate"
" both the concept and the implementation."
msgstr ""

#: ../../pep-0544.txt:1179
msgid ""
"On the other hand, Zope interfaces are conceptually a superset of "
"protocols defined here, but using an incompatible syntax to define them, "
"because before PEP 526 there was no straightforward way to annotate "
"attributes. In the 3.6+ world, ``zope.interface`` might potentially adopt"
" the ``Protocol`` syntax. In this case, type checkers could be taught to "
"recognize interfaces as protocols and make simple structural checks with "
"respect to them."
msgstr ""

#: ../../pep-0544.txt:1188
msgid "Use assignments to check explicitly that a class implements a protocol"
msgstr ""

#: ../../pep-0544.txt:1190
msgid ""
"In the Go language the explicit checks for implementation are performed "
"via dummy assignments [golang]_. Such a way is also possible with the "
"current proposal. Example::"
msgstr ""

#: ../../pep-0544.txt:1201
msgid ""
"This approach moves the check away from the class definition and it "
"almost requires a comment as otherwise the code probably would not make "
"any sense to an average reader -- it looks like dead code. Besides, in "
"the simplest form it requires one to construct an instance of ``A``, "
"which could be problematic if this requires accessing or allocating some "
"resources such as files or sockets. We could work around the latter by "
"using a cast, for example, but then the code would be ugly. Therefore, we"
" discourage the use of this pattern."
msgstr ""

#: ../../pep-0544.txt:1212
msgid "Support ``isinstance()`` checks by default"
msgstr ""

#: ../../pep-0544.txt:1214
msgid ""
"The problem with this is instance checks could be unreliable, except for "
"situations where there is a common signature convention such as "
"``Iterable``. For example::"
msgstr ""

#: ../../pep-0544.txt:1230
msgid ""
"Another potentially problematic case is assignment of attributes *after* "
"instantiation::"
msgstr ""

#: ../../pep-0544.txt:1255
msgid ""
"We argue that requiring an explicit class decorator would be better, "
"since one can then attach warnings about problems like this in the "
"documentation. The user would be able to evaluate whether the benefits "
"outweigh the potential for confusion for each protocol and explicitly opt"
" in -- but the default behavior would be safer. Finally, it will be easy "
"to make this behavior default if necessary, while it might be problematic"
" to make it opt-in after being default."
msgstr ""

#: ../../pep-0544.txt:1265
msgid "Provide a special intersection type construct"
msgstr ""

#: ../../pep-0544.txt:1267
msgid ""
"There was an idea to allow ``Proto = All[Proto1, Proto2, ...]`` as a "
"shorthand for::"
msgstr ""

#: ../../pep-0544.txt:1273
msgid ""
"However, it is not yet clear how popular/useful it will be and "
"implementing this in type checkers for non-protocol classes could be "
"difficult. Finally, it will be very easy to add this later if needed."
msgstr ""

#: ../../pep-0544.txt:1279
msgid "Prohibit explicit subclassing of protocols by non-protocols"
msgstr ""

#: ../../pep-0544.txt:1281
msgid "This was rejected for the following reasons:"
msgstr ""

#: ../../pep-0544.txt:1283
msgid ""
"Backward compatibility: People are already using ABCs, including generic "
"ABCs from ``typing`` module. If we prohibit explicit subclassing of these"
" ABCs, then quite a lot of code will break."
msgstr ""

#: ../../pep-0544.txt:1287
msgid ""
"Convenience: There are existing protocol-like ABCs (that may be turned "
"into protocols) that have many useful \"mix-in\" (non-abstract) methods. "
"For example, in the case of ``Sequence`` one only needs to implement "
"``__getitem__`` and ``__len__`` in an explicit subclass, and one gets "
"``__iter__``, ``__contains__``, ``__reversed__``, ``index``, and "
"``count`` for free."
msgstr ""

#: ../../pep-0544.txt:1294
msgid ""
"Explicit subclassing makes it explicit that a class implements a "
"particular protocol, making subtyping relationships easier to see."
msgstr ""

#: ../../pep-0544.txt:1297
msgid ""
"Type checkers can warn about missing protocol members or members with "
"incompatible types more easily, without having to use hacks like dummy "
"assignments discussed above in this section."
msgstr ""

#: ../../pep-0544.txt:1301
msgid ""
"Explicit subclassing makes it possible to force a class to be considered "
"a subtype of a protocol (by using ``# type: ignore`` together with an "
"explicit base class) when it is not strictly compatible, such as when it "
"has an unsafe override."
msgstr ""

#: ../../pep-0544.txt:1308
msgid "Covariant subtyping of mutable attributes"
msgstr ""

#: ../../pep-0544.txt:1310
msgid ""
"Rejected because covariant subtyping of mutable attributes is not safe. "
"Consider this example::"
msgstr ""

#: ../../pep-0544.txt:1327
msgid ""
"It was initially proposed to allow this for practical reasons, but it was"
" subsequently rejected, since this may mask some hard to spot bugs."
msgstr ""

#: ../../pep-0544.txt:1332
msgid "Overriding inferred variance of protocol classes"
msgstr ""

#: ../../pep-0544.txt:1334
msgid ""
"It was proposed to allow declaring protocols as invariant if they are "
"actually covariant or contravariant (as it is possible for nominal "
"classes, see PEP 484). However, it was decided not to do this because of "
"several downsides:"
msgstr ""

#: ../../pep-0544.txt:1338
msgid ""
"Declared protocol invariance breaks transitivity of sub-typing. Consider "
"this situation::"
msgstr ""

#: ../../pep-0544.txt:1353
msgid ""
"Now we have that ``D`` is a subtype of ``C``, and ``C`` is a subtype of "
"``P[float]``. But ``D`` is *not* a subtype of ``P[float]`` since ``D`` "
"implements ``P[int]``, and ``P`` is invariant. There is a possibility to "
"\"cure\" this by looking for protocol implementations in MROs but this "
"will be too complex in a general case, and this \"cure\" requires "
"abandoning simple idea of purely structural subtyping for protocols."
msgstr ""

#: ../../pep-0544.txt:1360
msgid ""
"Subtyping checks will always require type inference for protocols. In the"
" above example a user may complain: \"Why did you infer ``P[int]`` for my"
" ``D``? It implements ``P[float]``!\". Normally, inference can be "
"overruled by an explicit annotation, but here this will require explicit "
"subclassing, defeating the purpose of using protocols."
msgstr ""

#: ../../pep-0544.txt:1366
msgid ""
"Allowing overriding variance will make impossible more detailed error "
"messages in type checkers citing particular conflicts in member type "
"signatures."
msgstr ""

#: ../../pep-0544.txt:1370
msgid ""
"Finally, explicit is better than implicit in this case. Requiring user to"
" declare correct variance will simplify understanding the code and will "
"avoid unexpected errors at the point of use."
msgstr ""

#: ../../pep-0544.txt:1376
msgid "Support adapters and adaptation"
msgstr ""

#: ../../pep-0544.txt:1378
msgid ""
"Adaptation was proposed by PEP 246 (rejected) and is supported by "
"``zope.interface``, see "
"https://docs.zope.org/zope.interface/adapter.html. Adapters is quite an "
"advanced concept, and PEP 484 supports unions and generic aliases that "
"can be used instead of adapters. This can be illustrated with an example "
"of ``Iterable`` protocol, there is another way of supporting iteration by"
" providing ``__getitem__`` and ``__len__``. If a function supports both "
"this way and the now standard ``__iter__`` method, then it could be "
"annotated by a union type::"
msgstr ""

#: ../../pep-0544.txt:1404
msgid ""
"Since there is a reasonable alternative for such cases with existing "
"tooling, it is therefore proposed not to include adaptation in this PEP."
msgstr ""

#: ../../pep-0544.txt:1409
msgid "Call structural base types \"interfaces\""
msgstr ""

#: ../../pep-0544.txt:1411
msgid ""
"\"Protocol\" is a term already widely used in Python to describe duck "
"typing contracts such as the iterator protocol (providing ``__iter__`` "
"and ``__next__``), and the descriptor protocol (providing ``__get__``, "
"``__set__``, and ``__delete__``). In addition to this and other reasons "
"given in `specification`_, protocols are different from Java interfaces "
"in several aspects: protocols don't require explicit declaration of "
"implementation (they are mainly oriented on duck-typing), protocols can "
"have default implementations of members and store state."
msgstr ""

#: ../../pep-0544.txt:1422
msgid "Make protocols special objects at runtime rather than normal ABCs"
msgstr ""

#: ../../pep-0544.txt:1424
msgid ""
"Making protocols non-ABCs will make the backwards compatibility "
"problematic if possible at all. For example, ``collections.abc.Iterable``"
" is already an ABC, and lots of existing code use patterns like "
"``isinstance(obj, collections.abc.Iterable)`` and similar checks with "
"other ABCs (also in a structural manner, i.e., via ``__subclasshook__``)."
" Disabling this behavior will cause breakages. If we keep this behavior "
"for ABCs in ``collections.abc`` but will not provide a similar runtime "
"behavior for protocols in ``typing``, then a smooth transition to "
"protocols will be not possible. In addition, having two parallel "
"hierarchies may cause confusions."
msgstr ""

#: ../../pep-0544.txt:1437
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0544.txt:1439
msgid "This PEP is fully backwards compatible."
msgstr ""

#: ../../pep-0544.txt:1443
msgid "Implementation"
msgstr ""

#: ../../pep-0544.txt:1445
msgid ""
"The ``mypy`` type checker fully supports protocols (modulo a few known "
"bugs). This includes treating all the builtin protocols, such as "
"``Iterable`` structurally. The runtime implementation of protocols is "
"available in ``typing_extensions`` module on PyPI."
msgstr ""

#: ../../pep-0544.txt:1452
msgid "References"
msgstr ""

#: ../../pep-0544.txt:1455
msgid "https://docs.python.org/3/library/typing.html"
msgstr ""

#: ../../pep-0544.txt:1458
msgid "https://en.wikipedia.org/wiki/Structural_type_system"
msgstr ""

#: ../../pep-0544.txt:1461
msgid "https://zopeinterface.readthedocs.io/en/latest/"
msgstr ""

#: ../../pep-0544.txt:1464
msgid "https://docs.python.org/3/library/abc.html"
msgstr ""

#: ../../pep-0544.txt:1467
msgid "https://docs.python.org/3/library/collections.abc.html"
msgstr ""

#: ../../pep-0544.txt:1470
msgid "https://www.typescriptlang.org/docs/handbook/interfaces.html"
msgstr ""

#: ../../pep-0544.txt:1473
msgid "https://golang.org/doc/effective_go.html#interfaces_and_types"
msgstr ""

#: ../../pep-0544.txt:1476
msgid "https://docs.python.org/3/reference/datamodel.html#special-method-names"
msgstr ""

#: ../../pep-0544.txt:1479
msgid "https://github.com/python/typeshed/"
msgstr ""

#: ../../pep-0544.txt:1482
msgid "http://github.com/python/mypy/"
msgstr ""

#: ../../pep-0544.txt:1485
msgid ""
"https://mail.python.org/pipermail/python-"
"ideas/2015-September/thread.html#35859"
msgstr ""

#: ../../pep-0544.txt:1488
msgid "https://github.com/python/typing/issues/11"
msgstr ""

#: ../../pep-0544.txt:1491
msgid "https://github.com/python/peps/pull/224"
msgstr ""

#: ../../pep-0544.txt:1494
msgid ""
"https://www.python.org/dev/peps/pep-0484/#annotating-instance-and-class-"
"methods"
msgstr ""

#: ../../pep-0544.txt:1498
msgid "Copyright"
msgstr ""

#: ../../pep-0544.txt:1500
msgid "This document has been placed in the public domain."
msgstr ""

