# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0543.rst
msgid "PEP"
msgstr ""

#: ../../pep-0543.rst:1
msgid "543"
msgstr ""

#: ../../pep-0543.rst
msgid "Title"
msgstr ""

#: ../../pep-0543.rst:2
msgid "A Unified TLS API for Python"
msgstr ""

#: ../../pep-0543.rst
msgid "Author"
msgstr ""

#: ../../pep-0543.rst:5
msgid "Cory Benfield <cory@lukasa.co.uk>, Christian Heimes <christian@python.org>"
msgstr ""

#: ../../pep-0543.rst
msgid "Status"
msgstr ""

#: ../../pep-0543.rst:7
msgid "Withdrawn"
msgstr ""

#: ../../pep-0543.rst
msgid "Type"
msgstr ""

#: ../../pep-0543.rst:8
msgid "Standards Track"
msgstr ""

#: ../../pep-0543.rst
msgid "Created"
msgstr ""

#: ../../pep-0543.rst:10
msgid "17-Oct-2016"
msgstr ""

#: ../../pep-0543.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0543.rst:11
msgid "3.7"
msgstr ""

#: ../../pep-0543.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0543.rst:12
msgid "11-Jan-2017, 19-Jan-2017, 02-Feb-2017, 09-Feb-2017"
msgstr ""

#: ../../pep-0543.rst:16
msgid "Abstract"
msgstr ""

#: ../../pep-0543.rst:18
msgid ""
"This PEP would define a standard TLS interface in the form of a "
"collection of abstract base classes. This interface would allow Python "
"implementations and third-party libraries to provide bindings to TLS "
"libraries other than OpenSSL that can be used by tools that expect the "
"interface provided by the Python standard library, with the goal of "
"reducing the dependence of the Python ecosystem on OpenSSL."
msgstr ""

#: ../../pep-0543.rst:27
msgid "Resolution"
msgstr ""

#: ../../pep-0543.rst:29
msgid ""
"2020-06-25: With contemporary agreement with one author, and past "
"agreement with another, this PEP is withdrawn due to changes in the APIs "
"of the underlying operating systems."
msgstr ""

#: ../../pep-0543.rst:35
msgid "Rationale"
msgstr ""

#: ../../pep-0543.rst:37
msgid ""
"In the 21st century it has become increasingly clear that robust and "
"user-friendly TLS support is an extremely important part of the ecosystem"
" of any popular programming language. For most of its lifetime, this role"
" in the Python ecosystem has primarily been served by the `ssl module`_, "
"which provides a Python API to the `OpenSSL library`_."
msgstr ""

#: ../../pep-0543.rst:43
msgid ""
"Because the ``ssl`` module is distributed with the Python standard "
"library, it has become the overwhelmingly most-popular method for "
"handling TLS in Python. An extraordinary majority of Python libraries, "
"both in the standard library and on the Python Package Index, rely on the"
" ``ssl`` module for their TLS connectivity."
msgstr ""

#: ../../pep-0543.rst:49
msgid ""
"Unfortunately, the preeminence of the ``ssl`` module has had a number of "
"unforeseen side-effects that have had the effect of tying the entire "
"Python ecosystem tightly to OpenSSL. This has forced Python users to use "
"OpenSSL even in situations where it may provide a worse user experience "
"than alternative TLS implementations, which imposes a cognitive burden "
"and makes it hard to provide \"platform-native\" experiences."
msgstr ""

#: ../../pep-0543.rst:58
msgid "Problems"
msgstr ""

#: ../../pep-0543.rst:60
msgid ""
"The fact that the ``ssl`` module is built into the standard library has "
"meant that all standard-library Python networking libraries are entirely "
"reliant on the OpenSSL that the Python implementation has been linked "
"against. This leads to the following issues:"
msgstr ""

#: ../../pep-0543.rst:65
msgid ""
"It is difficult to take advantage of new, higher-security TLS without "
"recompiling Python to get a new OpenSSL. While there are third-party "
"bindings to OpenSSL (e.g. `pyOpenSSL`_), these need to be shimmed into a "
"format that the standard library understands, forcing projects that want "
"to use them to maintain substantial compatibility layers."
msgstr ""

#: ../../pep-0543.rst:71
msgid ""
"For Windows distributions of Python, they need to be shipped with a copy "
"of OpenSSL. This puts the CPython development team in the position of "
"being OpenSSL redistributors, potentially needing to ship security "
"updates to the Windows Python distributions when OpenSSL vulnerabilities "
"are released."
msgstr ""

#: ../../pep-0543.rst:76
msgid ""
"For macOS distributions of Python, they need either to be shipped with a "
"copy of OpenSSL or linked against the system OpenSSL library. Apple has "
"formally deprecated linking against the system OpenSSL library, and even "
"if they had not, that library version has been unsupported by upstream "
"for nearly one year as of the time of writing. The CPython development "
"team has started shipping newer OpenSSLs with the Python available from "
"python.org, but this has the same problem as with Windows."
msgstr ""

#: ../../pep-0543.rst:84
msgid ""
"Many systems, including but not limited to Windows and macOS, do not make"
" their system certificate stores available to OpenSSL. This forces users "
"to either obtain their trust roots from elsewhere (e.g. `certifi`_) or to"
" attempt to export their system trust stores in some form."
msgstr ""

#: ../../pep-0543.rst:89
msgid ""
"Relying on `certifi`_ is less than ideal, as most system administrators "
"do not expect to receive security-critical software updates from PyPI. "
"Additionally, it is not easy to extend the `certifi`_ trust bundle to "
"include custom roots, or to centrally manage trust using the `certifi`_ "
"model."
msgstr ""

#: ../../pep-0543.rst:94
msgid ""
"Even in situations where the system certificate stores are made available"
" to OpenSSL in some form, the experience is still sub-standard, as "
"OpenSSL will perform different validation checks than the platform-native"
" TLS implementation. This can lead to users experiencing different "
"behaviour on their browsers or other platform-native tools than they "
"experience in Python, with little or no recourse to resolve the problem."
msgstr ""

#: ../../pep-0543.rst:101
msgid ""
"Users may wish to integrate with TLS libraries other than OpenSSL for "
"many other reasons, such as OpenSSL missing features (e.g. TLS 1.3 "
"support), or because OpenSSL is simply too large and unwieldy for the "
"platform (e.g. for embedded Python). Those users are left with the "
"requirement to use third-party networking libraries that can interact "
"with their preferred TLS library or to shim their preferred library into "
"the OpenSSL-specific ``ssl`` module API."
msgstr ""

#: ../../pep-0543.rst:109
msgid ""
"Additionally, the ``ssl`` module as implemented today limits the ability "
"of CPython itself to add support for alternative TLS backends, or remove "
"OpenSSL support entirely, should either of these become necessary or "
"useful. The ``ssl`` module exposes too many OpenSSL-specific function "
"calls and features to easily map to an alternative TLS backend."
msgstr ""

#: ../../pep-0543.rst:117
msgid "Proposal"
msgstr ""

#: ../../pep-0543.rst:119
msgid ""
"This PEP proposes to introduce a few new Abstract Base Classes in Python "
"3.7 to provide TLS functionality that is not so strongly tied to OpenSSL."
" It also proposes to update standard library modules to use only the "
"interface exposed by these abstract base classes wherever possible. There"
" are three goals here:"
msgstr ""

#: ../../pep-0543.rst:124
msgid ""
"To provide a common API surface for both core and third-party developers "
"to target their TLS implementations to. This allows TLS developers to "
"provide interfaces that can be used by most Python code, and allows "
"network developers to have an interface that they can target that will "
"work with a wide range of TLS implementations."
msgstr ""

#: ../../pep-0543.rst:129
msgid ""
"To provide an API that has few or no OpenSSL-specific concepts leak "
"through. The ``ssl`` module today has a number of warts caused by leaking"
" OpenSSL concepts through to the API: the new ABCs would remove those "
"specific concepts."
msgstr ""

#: ../../pep-0543.rst:133
msgid ""
"To provide a path for the core development team to make OpenSSL one of "
"many possible TLS backends, rather than requiring that it be present on a"
" system in order for Python to have TLS support."
msgstr ""

#: ../../pep-0543.rst:137
msgid "The proposed interface is laid out below."
msgstr ""

#: ../../pep-0543.rst:141
msgid "Interfaces"
msgstr ""

#: ../../pep-0543.rst:143
msgid ""
"There are several interfaces that require standardisation. Those "
"interfaces are:"
msgstr ""

#: ../../pep-0543.rst:146
msgid ""
"Configuring TLS, currently implemented by the `SSLContext`_ class in the "
"``ssl`` module."
msgstr ""

#: ../../pep-0543.rst:148
msgid ""
"Providing an in-memory buffer for doing in-memory encryption or "
"decryption with no actual I/O (necessary for asynchronous I/O models), "
"currently implemented by the `SSLObject`_ class in the ``ssl`` module."
msgstr ""

#: ../../pep-0543.rst:151
msgid ""
"Wrapping a socket object, currently implemented by the `SSLSocket`_ class"
" in the ``ssl`` module."
msgstr ""

#: ../../pep-0543.rst:153
msgid ""
"Applying TLS configuration to the wrapping objects in (2) and (3). "
"Currently this is also implemented by the `SSLContext`_ class in the "
"``ssl`` module."
msgstr ""

#: ../../pep-0543.rst:155
msgid ""
"Specifying TLS cipher suites. There is currently no code for doing this "
"in the standard library: instead, the standard library uses OpenSSL "
"cipher suite strings."
msgstr ""

#: ../../pep-0543.rst:158
msgid ""
"Specifying application-layer protocols that can be negotiated during the "
"TLS handshake."
msgstr ""

#: ../../pep-0543.rst:160
msgid "Specifying TLS versions."
msgstr ""

#: ../../pep-0543.rst:161
msgid ""
"Reporting errors to the caller, currently implemented by the `SSLError`_ "
"class in the ``ssl`` module."
msgstr ""

#: ../../pep-0543.rst:163
msgid "Specifying certificates to load, either as client or server certificates."
msgstr ""

#: ../../pep-0543.rst:164
msgid ""
"Specifying which trust database should be used to validate certificates "
"presented by a remote peer."
msgstr ""

#: ../../pep-0543.rst:166
msgid "Finding a way to get hold of these interfaces at run time."
msgstr ""

#: ../../pep-0543.rst:168
msgid ""
"For the sake of simplicity, this PEP proposes to take a unified approach "
"to (2) and (3) (that is, buffers and sockets). The Python socket API is a"
" sizeable one, and implementing a wrapped socket that has the same "
"behaviour as a regular Python socket is a subtle and tricky thing to do. "
"However, it is entirely possible to implement a *generic* wrapped socket "
"in terms of wrapped buffers: that is, it is possible to write a wrapped "
"socket (3) that will work for any implementation that provides (2). For "
"this reason, this PEP proposes to provide an ABC for wrapped buffers (2) "
"but a concrete class for wrapped sockets (3)."
msgstr ""

#: ../../pep-0543.rst:178
msgid ""
"This decision has the effect of making it impossible to bind a small "
"number of TLS libraries to this ABC, because those TLS libraries *cannot*"
" provide a wrapped buffer implementation. The most notable of these at "
"this time appears to be Amazon's `s2n`_, which currently does not provide"
" an I/O abstraction layer. However, even this library consider this a "
"missing feature and are `working to add it`_. For this reason, it is safe"
" to assume that a concrete implementation of (3) in terms of (2) will be "
"a substantial effort-saving device and a great tool for correctness. "
"Therefore, this PEP proposes doing just that."
msgstr ""

#: ../../pep-0543.rst:188
msgid ""
"Obviously, (5) doesn't require an abstract base class: instead, it "
"requires a richer API for configuring supported cipher suites that can be"
" easily updated with supported cipher suites for different "
"implementations."
msgstr ""

#: ../../pep-0543.rst:192
msgid ""
"(9) is a thorny problem, because in an ideal world the private keys "
"associated with these certificates would never end up in-memory in the "
"Python process (that is, the TLS library would collaborate with a "
"Hardware Security Module (HSM) to provide the private key in such a way "
"that it cannot be extracted from process memory). Thus, we need to "
"provide an extensible model of providing certificates that allows "
"concrete implementations the ability to provide this higher level of "
"security, while also allowing a lower bar for those implementations that "
"cannot. This lower bar would be the same as the status quo: that is, the "
"certificate may be loaded from an in-memory buffer or from a file on "
"disk."
msgstr ""

#: ../../pep-0543.rst:203
msgid ""
"(10) also represents an issue because different TLS implementations vary "
"wildly in how they allow users to select trust stores. Some "
"implementations have specific trust store formats that only they can use "
"(such as the OpenSSL CA directory format that is created by "
"``c_rehash``), and others may not allow you to specify a trust store that"
" does not include their default trust store."
msgstr ""

#: ../../pep-0543.rst:209
msgid ""
"For this reason, we need to provide a model that assumes very little "
"about the form that trust stores take. The \"Trust Store\" section below "
"goes into more detail about how this is achieved."
msgstr ""

#: ../../pep-0543.rst:213
msgid ""
"Finally, this API will split the responsibilities currently assumed by "
"the `SSLContext`_ object: specifically, the responsibility for holding "
"and managing configuration and the responsibility for using that "
"configuration to build wrapper objects."
msgstr ""

#: ../../pep-0543.rst:218
msgid ""
"This is necessarily primarily for supporting functionality like Server "
"Name Indication (SNI). In OpenSSL (and thus in the ``ssl`` module), the "
"server has the ability to modify the TLS configuration in response to the"
" client telling the server what hostname it is trying to reach. This is "
"mostly used to change certificate chain so as to present the correct TLS "
"certificate chain for the given hostname. The specific mechanism by which"
" this is done is by returning a new `SSLContext`_ object with the "
"appropriate configuration."
msgstr ""

#: ../../pep-0543.rst:226
msgid ""
"This is not a model that maps well to other TLS implementations. Instead,"
" we need to make it possible to provide a return value from the SNI "
"callback that can be used to indicate what configuration changes should "
"be made. This means providing an object that can hold TLS configuration. "
"This object needs to be applied to specific TLSWrappedBuffer, and "
"TLSWrappedSocket objects."
msgstr ""

#: ../../pep-0543.rst:232
msgid ""
"For this reason, we split the responsibility of `SSLContext`_ into two "
"separate objects. The ``TLSConfiguration`` object is an object that acts "
"as container for TLS configuration: the ``ClientContext`` and "
"``ServerContext`` objects are objects that are instantiated with a "
"``TLSConfiguration`` object. All three objects would be immutable."
msgstr ""

#: ../../pep-0543.rst:238
msgid ""
"The following API declarations uniformly use type hints to aid reading. "
"Some of these type hints cannot actually be used in practice because they"
" are circularly referential. Consider them more a guideline than a "
"reflection of the final code in the module."
msgstr ""

#: ../../pep-0543.rst:244
msgid "Configuration"
msgstr ""

#: ../../pep-0543.rst:246
msgid ""
"The ``TLSConfiguration`` concrete class defines an object that can hold "
"and manage TLS configuration. The goals of this class are as follows:"
msgstr ""

#: ../../pep-0543.rst:249
msgid ""
"To provide a method of specifying TLS configuration that avoids the risk "
"of errors in typing (this excludes the use of a simple dictionary)."
msgstr ""

#: ../../pep-0543.rst:251
msgid ""
"To provide an object that can be safely compared to other configuration "
"objects to detect changes in TLS configuration, for use with the SNI "
"callback."
msgstr ""

#: ../../pep-0543.rst:255
msgid ""
"This class is not an ABC, primarily because it is not expected to have "
"implementation-specific behaviour. The responsibility for transforming a "
"``TLSConfiguration`` object into a useful set of configuration for a "
"given TLS implementation belongs to the Context objects discussed below."
msgstr ""

#: ../../pep-0543.rst:260
msgid ""
"This class has one other notable property: it is immutable. This is a "
"desirable trait for a few reasons. The most important one is that it "
"allows these objects to be used as dictionary keys, which is potentially "
"extremely valuable for certain TLS backends and their SNI configuration. "
"On top of this, it frees implementations from needing to worry about "
"their configuration objects being changed under their feet, which allows "
"them to avoid needing to carefully synchronize changes between their "
"concrete data structures and the configuration object."
msgstr ""

#: ../../pep-0543.rst:269
msgid ""
"This object is extendable: that is, future releases of Python may add "
"configuration fields to this object as they become useful. For backwards-"
"compatibility purposes, new fields are only appended to this object. "
"Existing fields will never be removed, renamed, or reordered."
msgstr ""

#: ../../pep-0543.rst:274
msgid "The ``TLSConfiguration`` object would be defined by the following code::"
msgstr ""

#: ../../pep-0543.rst:450
msgid "Context"
msgstr ""

#: ../../pep-0543.rst:452
msgid ""
"We define two Context abstract base classes. These ABCs define objects "
"that allow configuration of TLS to be applied to specific connections. "
"They can be thought of as factories for ``TLSWrappedSocket`` and "
"``TLSWrappedBuffer`` objects."
msgstr ""

#: ../../pep-0543.rst:457
msgid ""
"Unlike the current ``ssl`` module, we provide two context classes instead"
" of one. Specifically, we provide the ``ClientContext`` and "
"``ServerContext`` classes. This simplifies the APIs (for example, there "
"is no sense in the server providing the ``server_hostname`` parameter to "
"``ssl.SSLContext.wrap_socket``, but because there is only one context "
"class that parameter is still available), and ensures that "
"implementations know as early as possible which side of a TLS connection "
"they will serve. Additionally, it allows implementations to opt-out of "
"one or either side of the connection. For example, SecureTransport on "
"macOS is not really intended for server use and has an enormous amount of"
" functionality missing for server-side use. This would allow "
"SecureTransport implementations to simply not define a concrete subclass "
"of ``ServerContext`` to signal their lack of support."
msgstr ""

#: ../../pep-0543.rst:470
msgid ""
"One of the other major differences to the current ``ssl`` module is that "
"a number of flags and options have been removed. Most of these are self-"
"evident, but it is worth noting that ``auto_handshake`` has been removed "
"from ``wrap_socket``. This was removed because it fundamentally "
"represents an odd design wart that saves very minimal effort at the cost "
"of a complexity increase both for users and implementers. This PEP "
"requires that all users call ``do_handshake`` explicitly after "
"connecting."
msgstr ""

#: ../../pep-0543.rst:478
msgid ""
"As much as possible implementers should aim to make these classes "
"immutable: that is, they should prefer not to allow users to mutate their"
" internal state directly, instead preferring to create new contexts from "
"new TLSConfiguration objects. Obviously, the ABCs cannot enforce this "
"constraint, and so they do not attempt to."
msgstr ""

#: ../../pep-0543.rst:484
msgid "The ``Context`` abstract base class has the following class definition::"
msgstr ""

#: ../../pep-0543.rst:585
msgid "Buffer"
msgstr ""

#: ../../pep-0543.rst:587
msgid ""
"The buffer-wrapper ABC will be defined by the ``TLSWrappedBuffer`` ABC, "
"which has the following definition::"
msgstr ""

#: ../../pep-0543.rst:743
msgid "Socket"
msgstr ""

#: ../../pep-0543.rst:745
msgid ""
"The socket-wrapper class will be a concrete class that accepts two items "
"in its constructor: a regular socket object, and a ``TLSWrappedBuffer`` "
"object. This object will be too large to recreate in this PEP, but will "
"be submitted as part of the work to build the module."
msgstr ""

#: ../../pep-0543.rst:750
msgid ""
"The wrapped socket will implement all of the socket API, though it will "
"have stub implementations of methods that only work for sockets with "
"types other than ``SOCK_STREAM`` (e.g. ``sendto``/``recvfrom``). That "
"limitation can be lifted as-and-when support for DTLS is added to this "
"module."
msgstr ""

#: ../../pep-0543.rst:755
msgid ""
"In addition, the socket class will include the following *extra* methods "
"on top of the regular socket methods::"
msgstr ""

#: ../../pep-0543.rst:814
msgid "Cipher Suites"
msgstr ""

#: ../../pep-0543.rst:816
msgid ""
"Supporting cipher suites in a truly library-agnostic fashion is a "
"remarkably difficult undertaking. Different TLS implementations often "
"have *radically* different APIs for specifying cipher suites, but more "
"problematically these APIs frequently differ in capability as well as in "
"style. Some examples are shown below:"
msgstr ""

#: ../../pep-0543.rst:823
msgid "OpenSSL"
msgstr ""

#: ../../pep-0543.rst:825
msgid ""
"OpenSSL uses a well-known cipher string format. This format has been "
"adopted as a configuration language by most products that use OpenSSL, "
"including Python. This format is relatively easy to read, but has a "
"number of downsides: it is a string, which makes it remarkably easy to "
"provide bad inputs; it lacks much detailed validation, meaning that it is"
" possible to configure OpenSSL in a way that doesn't allow it to "
"negotiate any cipher at all; and it allows specifying cipher suites in a "
"number of different ways that make it tricky to parse. The biggest "
"problem with this format is that there is no formal specification for it,"
" meaning that the only way to parse a given string the way OpenSSL would "
"is to get OpenSSL to parse it."
msgstr ""

#: ../../pep-0543.rst:836
msgid "OpenSSL's cipher strings can look like this::"
msgstr ""

#: ../../pep-0543.rst:840
msgid ""
"This string demonstrates some of the complexity of the OpenSSL format. "
"For example, it is possible for one entry to specify multiple cipher "
"suites: the entry ``ECDH+AESGCM`` means \"all ciphers suites that include"
" both elliptic-curve Diffie-Hellman key exchange and AES in Galois "
"Counter Mode\". More explicitly, that will expand to four cipher suites::"
msgstr ""

#: ../../pep-0543.rst:848
msgid ""
"That makes parsing a complete OpenSSL cipher string extremely tricky. Add"
" to the fact that there are other meta-characters, such as \"!\" (exclude"
" all cipher suites that match this criterion, even if they would "
"otherwise be included: \"!MD5\" means that no cipher suites using the MD5"
" hash algorithm should be included), \"-\" (exclude matching ciphers if "
"they were already included, but allow them to be re-added later if they "
"get included again), and \"+\" (include the matching ciphers, but place "
"them at the end of the list), and you get an *extremely* complex format "
"to parse. On top of this complexity it should be noted that the actual "
"result depends on the OpenSSL version, as an OpenSSL cipher string is "
"valid so long as it contains at least one cipher that OpenSSL recognises."
msgstr ""

#: ../../pep-0543.rst:860
msgid ""
"OpenSSL also uses different names for its ciphers than the names used in "
"the relevant specifications. See the manual page for ``ciphers(1)`` for "
"more details."
msgstr ""

#: ../../pep-0543.rst:864
msgid "The actual API inside OpenSSL for the cipher string is simple::"
msgstr ""

#: ../../pep-0543.rst:869
msgid ""
"This means that any format that is used by this module must be able to be"
" converted to an OpenSSL cipher string for use with OpenSSL."
msgstr ""

#: ../../pep-0543.rst:873
msgid "SecureTransport"
msgstr ""

#: ../../pep-0543.rst:875
msgid ""
"SecureTransport is the macOS system TLS library. This library is "
"substantially more restricted than OpenSSL in many ways, as it has a much"
" more restricted class of users. One of these substantial restrictions is"
" in controlling supported cipher suites."
msgstr ""

#: ../../pep-0543.rst:880
msgid ""
"Ciphers in SecureTransport are represented by a C ``enum``. This enum has"
" one entry per cipher suite, with no aggregate entries, meaning that it "
"is not possible to reproduce the meaning of an OpenSSL cipher string like"
" \"ECDH+AESGCM\" without hand-coding which categories each enum member "
"falls into."
msgstr ""

#: ../../pep-0543.rst:885
msgid ""
"However, the names of most of the enum members are in line with the "
"formal names of the cipher suites: that is, the cipher suite that OpenSSL"
" calls \"ECDHE-ECDSA-AES256-GCM-SHA384\" is called "
"\"TLS_ECDHE_ECDHSA_WITH_AES_256_GCM_SHA384\" in SecureTransport."
msgstr ""

#: ../../pep-0543.rst:890
msgid "The API for configuring cipher suites inside SecureTransport is simple::"
msgstr ""

#: ../../pep-0543.rst:896
msgid "SChannel"
msgstr ""

#: ../../pep-0543.rst:898
msgid "SChannel is the Windows system TLS library."
msgstr ""

#: ../../pep-0543.rst:900
msgid ""
"SChannel has extremely restrictive support for controlling available TLS "
"cipher suites, and additionally adopts a third method of expressing what "
"TLS cipher suites are supported."
msgstr ""

#: ../../pep-0543.rst:904
msgid ""
"Specifically, SChannel defines a set of ``ALG_ID`` constants (C unsigned "
"ints). Each of these constants does not refer to an entire cipher suite, "
"but instead an individual algorithm. Some examples are ``CALG_3DES`` and "
"``CALG_AES_256``, which refer to the bulk encryption algorithm used in a "
"cipher suite, ``CALG_DH_EPHEM`` and ``CALG_RSA_KEYX`` which refer to part"
" of the key exchange algorithm used in a cipher suite, ``CALG_SHA1`` and "
"``CALG_MD5`` which refer to the message authentication code used in a "
"cipher suite, and ``CALG_ECDSA`` and ``CALG_RSA_SIGN`` which refer to the"
" signing portions of the key exchange algorithm."
msgstr ""

#: ../../pep-0543.rst:914
msgid ""
"This can be thought of as the half of OpenSSL's functionality that "
"SecureTransport doesn't have: SecureTransport only allows specifying "
"exact cipher suites, while SChannel only allows specifying *parts* of the"
" cipher suite, while OpenSSL allows both."
msgstr ""

#: ../../pep-0543.rst:919
msgid ""
"Determining which cipher suites are allowed on a given connection is done"
" by providing a pointer to an array of these ``ALG_ID`` constants. This "
"means that any suitable API must allow the Python code to determine which"
" ``ALG_ID`` constants must be provided."
msgstr ""

#: ../../pep-0543.rst:926
msgid "Network Security Services (NSS)"
msgstr ""

#: ../../pep-0543.rst:928
msgid ""
"NSS is Mozilla's crypto and TLS library. It's used in Firefox, "
"Thunderbird, and as alternative to OpenSSL in multiple libraries, e.g. "
"curl."
msgstr ""

#: ../../pep-0543.rst:931
msgid ""
"By default, NSS comes with secure configuration of allowed ciphers. On "
"some platforms such as Fedora, the list of enabled ciphers is globally "
"configured in a system policy. Generally, applications should not modify "
"cipher suites unless they have specific reasons to do so."
msgstr ""

#: ../../pep-0543.rst:936
msgid ""
"NSS has both process global and per-connection settings for cipher "
"suites. It does not have a concept of SSLContext like OpenSSL. A "
"SSLContext-like behavior can be easily emulated. Specifically, ciphers "
"can be enabled or disabled globally with "
"``SSL_CipherPrefSetDefault(PRInt32 cipher, PRBool enabled)``, and "
"``SSL_CipherPrefSet(PRFileDesc *fd, PRInt32 cipher, PRBool enabled)`` for"
" a connection. The cipher ``PRInt32`` number is a signed 32bit integer "
"that directly corresponds to an registered IANA id, e.g. ``0x1301`` is "
"``TLS_AES_128_GCM_SHA256``. Contrary to OpenSSL, the preference order of "
"ciphers is fixed and cannot be modified at runtime."
msgstr ""

#: ../../pep-0543.rst:946
msgid ""
"Like SecureTransport, NSS has no API for aggregated entries. Some "
"consumers of NSS have implemented custom mappings from OpenSSL cipher "
"names and rules to NSS ciphers, e.g. ``mod_nss``."
msgstr ""

#: ../../pep-0543.rst:952
msgid "Proposed Interface"
msgstr ""

#: ../../pep-0543.rst:954
msgid ""
"The proposed interface for the new module is influenced by the combined "
"set of limitations of the above implementations. Specifically, as every "
"implementation *except* OpenSSL requires that each individual cipher be "
"provided, there is no option but to provide that lowest-common "
"denominator approach."
msgstr ""

#: ../../pep-0543.rst:959
msgid ""
"The simplest approach is to provide an enumerated type that includes a "
"large subset of the cipher suites defined for TLS. The values of the enum"
" members will be their two-octet cipher identifier as used in the TLS "
"handshake, stored as a 16 bit integer. The names of the enum members will"
" be their IANA-registered cipher suite names."
msgstr ""

#: ../../pep-0543.rst:965
msgid ""
"As of now, the `IANA cipher suite registry`_ contains over 320 cipher "
"suites. A large portion of the cipher suites are irrelevant for TLS "
"connections to network services. Other suites specify deprecated and "
"insecure algorithms that are no longer provided by recent versions of "
"implementations. The enum does not contain ciphers with:"
msgstr ""

#: ../../pep-0543.rst:971
msgid ""
"key exchange: NULL, Kerberos (KRB5), pre-shared key (PSK), secure remote "
"transport (TLS-SRP)"
msgstr ""

#: ../../pep-0543.rst:973
msgid ""
"authentication: NULL, anonymous, export grade, Kerberos (KRB5), pre-"
"shared key (PSK), secure remote transport (TLS-SRP), DSA cert (DSS)"
msgstr ""

#: ../../pep-0543.rst:975
msgid "encryption: NULL, ARIA, DES, RC2, export grade 40bit"
msgstr ""

#: ../../pep-0543.rst:976
msgid "PRF: MD5"
msgstr ""

#: ../../pep-0543.rst:977
msgid "SCSV cipher suites"
msgstr ""

#: ../../pep-0543.rst:979
msgid ""
"3DES, RC4, SEED, and IDEA are included for legacy applications. Further "
"more five additional cipher suites from the TLS 1.3 draft (draft-ietf-"
"tls-tls13-18) are included, too. TLS 1.3 does not share any cipher suites"
" with TLS 1.2 and earlier. The resulting enum will contain roughly 110 "
"suites."
msgstr ""

#: ../../pep-0543.rst:984
msgid ""
"Because of these limitations, and because the enum doesn't contain every "
"defined cipher, and also to allow for forward-looking applications, all "
"parts of this API that accept ``CipherSuite`` objects will also accept "
"raw 16-bit integers directly."
msgstr ""

#: ../../pep-0543.rst:989
msgid ""
"Rather than populate this enum by hand, we have a `TLS enum script`_ that"
" builds it from Christian Heimes' `tlsdb JSON file`_ (warning: large "
"file) and `IANA cipher suite registry`_. The TLSDB also opens up the "
"possibility of extending the API with additional querying function, such "
"as determining which TLS versions support which ciphers, if that "
"functionality is found to be useful or necessary."
msgstr ""

#: ../../pep-0543.rst:996
msgid ""
"If users find this approach to be onerous, a future extension to this API"
" can provide helpers that can reintroduce OpenSSL's aggregation "
"functionality."
msgstr ""

#: ../../pep-0543.rst:1116
msgid "Enum members can be mapped to OpenSSL cipher names::"
msgstr ""

#: ../../pep-0543.rst:1126
msgid ""
"For SecureTransport, these enum members directly refer to the values of "
"the cipher suite constants. For example, SecureTransport defines the "
"cipher suite enum member ``TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384`` as "
"having the value ``0xC02C``. Not coincidentally, that is identical to its"
" value in the above enum. This makes mapping between SecureTransport and "
"the above enum very easy indeed."
msgstr ""

#: ../../pep-0543.rst:1133
msgid ""
"For SChannel there is no easy direct mapping, due to the fact that "
"SChannel configures ciphers, instead of cipher suites. This represents an"
" ongoing concern with SChannel, which is that it is very difficult to "
"configure in a specific manner compared to other TLS implementations."
msgstr ""

#: ../../pep-0543.rst:1138
msgid ""
"For the purposes of this PEP, any SChannel implementation will need to "
"determine which ciphers to choose based on the enum members. This may be "
"more open than the actual cipher suite list actually wants to allow, or "
"it may be more restrictive, depending on the choices of the "
"implementation. This PEP recommends that it be more restrictive, but of "
"course this cannot be enforced."
msgstr ""

#: ../../pep-0543.rst:1146
msgid "Protocol Negotiation"
msgstr ""

#: ../../pep-0543.rst:1148
msgid ""
"Both NPN and ALPN allow for protocol negotiation as part of the HTTP/2 "
"handshake. While NPN and ALPN are, at their fundamental level, built on "
"top of bytestrings, string-based APIs are frequently problematic as they "
"allow for errors in typing that can be hard to detect."
msgstr ""

#: ../../pep-0543.rst:1153
msgid ""
"For this reason, this module would define a type that protocol "
"negotiation implementations can pass and be passed. This type would wrap "
"a bytestring to allow for aliases for well-known protocols. This allows "
"us to avoid the problems inherent in typos for well-known protocols, "
"while allowing the full extensibility of the protocol negotiation layer "
"if needed by letting users pass byte strings directly."
msgstr ""

#: ../../pep-0543.rst:1173
msgid "TLS Versions"
msgstr ""

#: ../../pep-0543.rst:1175
msgid ""
"It is often useful to be able to restrict the versions of TLS you're "
"willing to support. There are many security advantages in refusing to use"
" old versions of TLS, and some misbehaving servers will mishandle TLS "
"clients advertising support for newer versions."
msgstr ""

#: ../../pep-0543.rst:1180
msgid ""
"The following enumerated type can be used to gate TLS versions. Forward-"
"looking applications should almost never set a maximum TLS version unless"
" they absolutely must, as a TLS backend that is newer than the Python "
"that uses it may support TLS versions that are not in this enumerated "
"type."
msgstr ""

#: ../../pep-0543.rst:1185
msgid ""
"Additionally, this enumerated type defines two additional flags that can "
"always be used to request either the lowest or highest TLS version "
"supported by an implementation."
msgstr ""

#: ../../pep-0543.rst:1203
msgid "Errors"
msgstr ""

#: ../../pep-0543.rst:1205
msgid ""
"This module would define four base classes for use with error handling. "
"Unlike many of the other classes defined here, these classes are not "
"abstract, as they have no behaviour. They exist simply to signal certain "
"common behaviours. Backends should subclass these exceptions in their own"
" packages, but needn't define any behaviour for them."
msgstr ""

#: ../../pep-0543.rst:1211
msgid ""
"In general, concrete implementations should subclass these exceptions "
"rather than throw them directly. This makes it moderately easier to "
"determine which concrete TLS implementation is in use during debugging of"
" unexpected errors. However, this is not mandatory."
msgstr ""

#: ../../pep-0543.rst:1216
msgid "The definitions of the errors are below::"
msgstr ""

#: ../../pep-0543.rst:1269
msgid "Certificates"
msgstr ""

#: ../../pep-0543.rst:1271
msgid ""
"This module would define an abstract X509 certificate class. This class "
"would have almost no behaviour, as the goal of this module is not to "
"provide all possible relevant cryptographic functionality that could be "
"provided by X509 certificates. Instead, all we need is the ability to "
"signal the source of a certificate to a concrete implementation."
msgstr ""

#: ../../pep-0543.rst:1277
msgid ""
"For that reason, this certificate implementation defines only "
"constructors. In essence, the certificate object in this module could be "
"as abstract as a handle that can be used to locate a specific "
"certificate."
msgstr ""

#: ../../pep-0543.rst:1281
msgid ""
"Concrete implementations may choose to provide alternative constructors, "
"e.g. to load certificates from HSMs. If a common interface emerges for "
"doing this, this module may be updated to provide a standard constructor "
"for this use-case as well."
msgstr ""

#: ../../pep-0543.rst:1286
msgid ""
"Concrete implementations should aim to have Certificate objects be "
"hashable if at all possible. This will help ensure that TLSConfiguration "
"objects used with an individual concrete implementation are also "
"hashable."
msgstr ""

#: ../../pep-0543.rst:1317
msgid "Private Keys"
msgstr ""

#: ../../pep-0543.rst:1319
msgid ""
"This module would define an abstract private key class. Much like the "
"Certificate class, this class has almost no behaviour in order to give as"
" much freedom as possible to the concrete implementations to treat keys "
"carefully."
msgstr ""

#: ../../pep-0543.rst:1323
msgid "This class has all the caveats of the ``Certificate`` class."
msgstr ""

#: ../../pep-0543.rst:1369
msgid "Trust Store"
msgstr ""

#: ../../pep-0543.rst:1371
msgid ""
"As discussed above, loading a trust store represents an issue because "
"different TLS implementations vary wildly in how they allow users to "
"select trust stores. For this reason, we need to provide a model that "
"assumes very little about the form that trust stores take."
msgstr ""

#: ../../pep-0543.rst:1376
msgid ""
"This problem is the same as the one that the Certificate and PrivateKey "
"types need to solve. For this reason, we use the exact same model, by "
"creating an opaque type that can encapsulate the various means that TLS "
"backends may open a trust store."
msgstr ""

#: ../../pep-0543.rst:1381
msgid ""
"A given TLS implementation is not required to implement all of the "
"constructors. However, it is strongly recommended that a given TLS "
"implementation provide the ``system`` constructor if at all possible, as "
"this is the most common validation trust store that is used. Concrete "
"implementations may also add their own constructors."
msgstr ""

#: ../../pep-0543.rst:1387
msgid ""
"Concrete implementations should aim to have TrustStore objects be "
"hashable if at all possible. This will help ensure that TLSConfiguration "
"objects used with an individual concrete implementation are also "
"hashable."
msgstr ""

#: ../../pep-0543.rst:1409
msgid "Runtime Access"
msgstr ""

#: ../../pep-0543.rst:1411
msgid ""
"A not-uncommon use case for library users is to want to allow the library"
" to control the TLS configuration, but to want to select what backend is "
"in use. For example, users of Requests may want to be able to select "
"between OpenSSL or a platform-native solution on Windows and macOS, or "
"between OpenSSL and NSS on some Linux platforms. These users, however, "
"may not care about exactly how their TLS configuration is done."
msgstr ""

#: ../../pep-0543.rst:1418
msgid ""
"This poses a problem: given an arbitrary concrete implementation, how can"
" a library work out how to load certificates into the trust store? There "
"are two options: either all concrete implementations can be required to "
"fit into a specific naming scheme, or we can provide an API that makes it"
" possible to grab these objects."
msgstr ""

#: ../../pep-0543.rst:1424
msgid ""
"This PEP proposes that we use the second approach. This grants the "
"greatest freedom to concrete implementations to structure their code as "
"they see fit, requiring only that they provide a single object that has "
"the appropriate properties in place. Users can then pass this \"backend\""
" object to libraries that support it, and those libraries can take care "
"of configuring and using the concrete implementation."
msgstr ""

#: ../../pep-0543.rst:1431
msgid ""
"All concrete implementations must provide a method of obtaining a "
"``Backend`` object. The ``Backend`` object can be a global singleton or "
"can be created by a callable if there is an advantage in doing that."
msgstr ""

#: ../../pep-0543.rst:1435
msgid "The ``Backend`` object has the following definition::"
msgstr ""

#: ../../pep-0543.rst:1443
msgid ""
"Each of the properties must provide the concrete implementation of the "
"relevant ABC. This ensures that code like this will work for any "
"backend::"
msgstr ""

#: ../../pep-0543.rst:1450
msgid "Changes to the Standard Library"
msgstr ""

#: ../../pep-0543.rst:1452
msgid ""
"The portions of the standard library that interact with TLS should be "
"revised to use these ABCs. This will allow them to function with other "
"TLS backends. This includes the following modules:"
msgstr ""

#: ../../pep-0543.rst:1456
msgid "asyncio"
msgstr ""

#: ../../pep-0543.rst:1457
msgid "ftplib"
msgstr ""

#: ../../pep-0543.rst:1458
msgid "http"
msgstr ""

#: ../../pep-0543.rst:1459
msgid "imaplib"
msgstr ""

#: ../../pep-0543.rst:1460
msgid "nntplib"
msgstr ""

#: ../../pep-0543.rst:1461
msgid "poplib"
msgstr ""

#: ../../pep-0543.rst:1462
msgid "smtplib"
msgstr ""

#: ../../pep-0543.rst:1463
msgid "urllib"
msgstr ""

#: ../../pep-0543.rst:1467
msgid "Migration of the ssl module"
msgstr ""

#: ../../pep-0543.rst:1469
msgid ""
"Naturally, we will need to extend the ``ssl`` module itself to conform to"
" these ABCs. This extension will take the form of new classes, "
"potentially in an entirely new module. This will allow applications that "
"take advantage of the current ``ssl`` module to continue to do so, while "
"enabling the new APIs for applications and libraries that want to use "
"them."
msgstr ""

#: ../../pep-0543.rst:1475
msgid ""
"In general, migrating from the ``ssl`` module to the new ABCs is not "
"expected to be one-to-one. This is normally acceptable: most tools that "
"use the ``ssl`` module hide it from the user, and so refactoring to use "
"the new module should be invisible."
msgstr ""

#: ../../pep-0543.rst:1480
msgid ""
"However, a specific problem comes from libraries or applications that "
"leak exceptions from the ``ssl`` module, either as part of their defined "
"API or by accident (which is easily done). Users of those tools may have "
"written code that tolerates and handles exceptions from the ``ssl`` "
"module being raised: migrating to the ABCs presented here would "
"potentially cause the exceptions defined above to be thrown instead, and "
"existing ``except`` blocks will not catch them."
msgstr ""

#: ../../pep-0543.rst:1488
msgid ""
"For this reason, part of the migration of the ``ssl`` module would "
"require that the exceptions in the ``ssl`` module alias those defined "
"above. That is, they would require the following statements to all "
"succeed::"
msgstr ""

#: ../../pep-0543.rst:1496
msgid ""
"The exact mechanics of how this will be done are beyond the scope of this"
" PEP, as they are made more complex due to the fact that the current "
"``ssl`` exceptions are defined in C code, but more details can be found "
"in `an email sent to the Security-SIG by Christian Heimes`_."
msgstr ""

#: ../../pep-0543.rst:1503
msgid "Future"
msgstr ""

#: ../../pep-0543.rst:1505
msgid ""
"Major future TLS features may require revisions of these ABCs. These "
"revisions should be made cautiously: many backends may not be able to "
"move forward swiftly, and will be invalidated by changes in these ABCs. "
"This is acceptable, but wherever possible features that are specific to "
"individual implementations should not be added to the ABCs. The ABCs "
"should restrict themselves to high-level descriptions of IETF-specified "
"features."
msgstr ""

#: ../../pep-0543.rst:1512
msgid ""
"However, well-justified extensions to this API absolutely should be made."
" The focus of this API is to provide a unifying lowest-common-denominator"
" configuration option for the Python community. TLS is not a static "
"target, and as TLS evolves so must this API."
msgstr ""

#: ../../pep-0543.rst:1519
msgid "Credits"
msgstr ""

#: ../../pep-0543.rst:1521
msgid ""
"This document has received extensive review from a number of individuals "
"in the community who have substantially helped shape it. Detailed review "
"was provided by:"
msgstr ""

#: ../../pep-0543.rst:1525
msgid "Alex Chan"
msgstr ""

#: ../../pep-0543.rst:1526
msgid "Alex Gaynor"
msgstr ""

#: ../../pep-0543.rst:1527
msgid "Antoine Pitrou"
msgstr ""

#: ../../pep-0543.rst:1528
msgid "Ashwini Oruganti"
msgstr ""

#: ../../pep-0543.rst:1529
msgid "Donald Stufft"
msgstr ""

#: ../../pep-0543.rst:1530
msgid "Ethan Furman"
msgstr ""

#: ../../pep-0543.rst:1531
msgid "Glyph"
msgstr ""

#: ../../pep-0543.rst:1532
msgid "Hynek Schlawack"
msgstr ""

#: ../../pep-0543.rst:1533
msgid "Jim J Jewett"
msgstr ""

#: ../../pep-0543.rst:1534
msgid "Nathaniel J. Smith"
msgstr ""

#: ../../pep-0543.rst:1535
msgid "Nick Coghlan"
msgstr ""

#: ../../pep-0543.rst:1536
msgid "Paul Kehrer"
msgstr ""

#: ../../pep-0543.rst:1537
msgid "Steve Dower"
msgstr ""

#: ../../pep-0543.rst:1538
msgid "Steven Fackler"
msgstr ""

#: ../../pep-0543.rst:1539
msgid "Wes Turner"
msgstr ""

#: ../../pep-0543.rst:1540
msgid "Will Bond"
msgstr ""

#: ../../pep-0543.rst:1542
msgid ""
"Further review was provided by the Security-SIG and python-ideas mailing "
"lists."
msgstr ""

#: ../../pep-0543.rst:1546
msgid "Copyright"
msgstr ""

#: ../../pep-0543.rst:1548
msgid "This document has been placed in the public domain."
msgstr ""

