# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0218.txt
msgid "PEP"
msgstr ""

#: ../../pep-0218.txt:1
msgid "218"
msgstr ""

#: ../../pep-0218.txt
msgid "Title"
msgstr ""

#: ../../pep-0218.txt:2
msgid "Adding a Built-In Set Object Type"
msgstr ""

#: ../../pep-0218.txt
msgid "Author"
msgstr ""

#: ../../pep-0218.txt:5
msgid "gvwilson@ddj.com (Greg Wilson), python@rcn.com (Raymond Hettinger)"
msgstr ""

#: ../../pep-0218.txt
msgid "Status"
msgstr ""

#: ../../pep-0218.txt:6
msgid "Final"
msgstr ""

#: ../../pep-0218.txt
msgid "Type"
msgstr ""

#: ../../pep-0218.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0218.txt
msgid "Created"
msgstr ""

#: ../../pep-0218.txt:9
msgid "31-Jul-2000"
msgstr ""

#: ../../pep-0218.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0218.txt:10
msgid "2.2"
msgstr ""

#: ../../pep-0218.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0218.txt:15
msgid "Introduction"
msgstr ""

#: ../../pep-0218.txt:17
msgid ""
"This PEP proposes adding a Set module to the standard Python library, and"
" to then make sets a built-in Python type if that module is widely used."
"  After explaining why sets are desirable, and why the common idiom of "
"using dictionaries in their place is inadequate, we describe how we "
"intend built-in sets to work, and then how the preliminary Set module "
"will behave.  The last section discusses the mutability (or otherwise) of"
" sets and set elements, and the solution which the Set module will "
"implement."
msgstr ""

#: ../../pep-0218.txt:28
msgid "Rationale"
msgstr ""

#: ../../pep-0218.txt:30
msgid ""
"Sets are a fundamental mathematical structure, and are very commonly used"
" in algorithm specifications.  They are much less frequently used in "
"implementations, even when they are the \"right\" structure.  Programmers"
" frequently use lists instead, even when the ordering information in "
"lists is irrelevant, and by-value lookups are frequent.  (Most medium-"
"sized C programs contain a depressing number of start-to-end searches "
"through malloc'd vectors to determine whether particular items are "
"present or not...)"
msgstr ""

#: ../../pep-0218.txt:40
msgid ""
"Programmers are often told that they can implement sets as dictionaries "
"with \"don't care\" values.  Items can be added to these \"sets\" by "
"assigning the \"don't care\" value to them; membership can be tested "
"using ``dict.has_key``; and items can be deleted using ``del``.  However,"
" the other main operations on sets (union, intersection, and difference) "
"are not directly supported by this representation, since their meaning is"
" ambiguous for dictionaries containing key/value pairs."
msgstr ""

#: ../../pep-0218.txt:51
msgid "Proposal"
msgstr ""

#: ../../pep-0218.txt:53
msgid ""
"The long-term goal of this PEP is to add a built-in set type to Python.  "
"This type will be an unordered collection of unique values, just as a "
"dictionary is an unordered collection of key/value pairs."
msgstr ""

#: ../../pep-0218.txt:58
msgid ""
"Iteration and comprehension will be implemented in the obvious ways, so "
"that::"
msgstr ""

#: ../../pep-0218.txt:63
msgid "will step through the elements of S in arbitrary order, while::"
msgstr ""

#: ../../pep-0218.txt:67
msgid ""
"will produce a set containing the squares of all elements in S, "
"Membership will be tested using ``in`` and ``not in``, and basic set "
"operations will be implemented by a mixture of overloaded operators:"
msgstr ""

#: ../../pep-0218.txt:73
msgid "``|``"
msgstr ""

#: ../../pep-0218.txt:73
msgid "union"
msgstr ""

#: ../../pep-0218.txt:74
msgid "``&``"
msgstr ""

#: ../../pep-0218.txt:74
msgid "intersection"
msgstr ""

#: ../../pep-0218.txt:75
msgid "``^``"
msgstr ""

#: ../../pep-0218.txt:75
msgid "symmetric difference"
msgstr ""

#: ../../pep-0218.txt:76
msgid "``-``"
msgstr ""

#: ../../pep-0218.txt:76
msgid "asymmetric difference"
msgstr ""

#: ../../pep-0218.txt:77
msgid "``== !=``"
msgstr ""

#: ../../pep-0218.txt:77
msgid "equality and inequality tests"
msgstr ""

#: ../../pep-0218.txt:78
msgid "``< <= >= >``"
msgstr ""

#: ../../pep-0218.txt:78
msgid "subset and superset tests"
msgstr ""

#: ../../pep-0218.txt:81
msgid "and methods:"
msgstr ""

#: ../../pep-0218.txt:84
msgid "``S.add(x)``"
msgstr ""

#: ../../pep-0218.txt:84
msgid "Add \"x\" to the set."
msgstr ""

#: ../../pep-0218.txt:86
msgid "``S.update(s)``"
msgstr ""

#: ../../pep-0218.txt:86
msgid "Add all elements of sequence \"s\" to the set."
msgstr ""

#: ../../pep-0218.txt:88
msgid "``S.remove(x)``"
msgstr ""

#: ../../pep-0218.txt:88
msgid ""
"Remove \"x\" from the set.  If \"x\" is not present, this method raises a"
" ``LookupError`` exception."
msgstr ""

#: ../../pep-0218.txt:92
msgid "``S.discard(x)``"
msgstr ""

#: ../../pep-0218.txt:92
msgid "Remove \"x\" from the set if it is present, or do nothing if it is not."
msgstr ""

#: ../../pep-0218.txt:95
msgid "``S.pop()``"
msgstr ""

#: ../../pep-0218.txt:95
msgid ""
"Remove and return an arbitrary element, raising a ``LookupError`` if the "
"element is not present."
msgstr ""

#: ../../pep-0218.txt:99
msgid "``S.clear()``"
msgstr ""

#: ../../pep-0218.txt:99
msgid "Remove all elements from this set."
msgstr ""

#: ../../pep-0218.txt:101
msgid "``S.copy()``"
msgstr ""

#: ../../pep-0218.txt:101
msgid "Make a new set."
msgstr ""

#: ../../pep-0218.txt:103
msgid "``s.issuperset()``"
msgstr ""

#: ../../pep-0218.txt:103
msgid "Check for a superset relationship."
msgstr ""

#: ../../pep-0218.txt:105
msgid "``s.issubset()``"
msgstr ""

#: ../../pep-0218.txt:105
msgid "Check for a subset relationship."
msgstr ""

#: ../../pep-0218.txt:108
msgid "and two new built-in conversion functions:"
msgstr ""

#: ../../pep-0218.txt:111
msgid "``set(x)``"
msgstr ""

#: ../../pep-0218.txt:111
msgid "Create a set containing the elements of the collection \"x\"."
msgstr ""

#: ../../pep-0218.txt:114
msgid "``frozenset(x)``"
msgstr ""

#: ../../pep-0218.txt:114
msgid "Create an immutable set containing the elements of the collection \"x\"."
msgstr ""

#: ../../pep-0218.txt:118
msgid "Notes:"
msgstr ""

#: ../../pep-0218.txt:120
msgid ""
"We propose using the bitwise operators \"``|&``\" for intersection and "
"union.  While \"``+``\" for union would be intuitive, \"``*``\" for "
"intersection is not (very few of the people asked guessed what it did "
"correctly)."
msgstr ""

#: ../../pep-0218.txt:125
msgid ""
"We considered using \"``+``\" to add elements to a set, rather than "
"\"add\".  However, Guido van Rossum pointed out that \"``+``\" is "
"symmetric for other built-in types (although \"``*``\" is not).  Use of "
"\"add\" will also avoid confusion between that operation and set union."
msgstr ""

#: ../../pep-0218.txt:133
msgid "Set Notation"
msgstr ""

#: ../../pep-0218.txt:135
msgid ""
"The PEP originally proposed ``{1,2,3}`` as the set notation and ``{-}`` "
"for the empty set.  Experience with Python 2.3's ``sets.py`` showed that "
"the notation was not necessary.  Also, there was some risk of making "
"dictionaries less instantly recognizable."
msgstr ""

#: ../../pep-0218.txt:140
msgid ""
"It was also contemplated that the braced notation would support set "
"comprehensions; however, Python 2.4 provided generator expressions which "
"fully met that need and did so it a more general way. (See PEP 289 for "
"details on generator expressions)."
msgstr ""

#: ../../pep-0218.txt:145
msgid ""
"So, Guido ruled that there would not be a set syntax; however, the issue "
"could be revisited for Python 3000 (see PEP 3000)."
msgstr ""

#: ../../pep-0218.txt:150
msgid "History"
msgstr ""

#: ../../pep-0218.txt:152
msgid ""
"To gain experience with sets, a pure python module was introduced in "
"Python 2.3.  Based on that implementation, the set and frozenset types "
"were introduced in Python 2.4.  The improvements are:"
msgstr ""

#: ../../pep-0218.txt:156
msgid "Better hash algorithm for frozensets"
msgstr ""

#: ../../pep-0218.txt:157
msgid ""
"More compact pickle format (storing only an element list instead of a "
"dictionary of key:value pairs where the value is always ``True``)."
msgstr ""

#: ../../pep-0218.txt:160
msgid "Use a ``__reduce__`` function so that deep copying is automatic."
msgstr ""

#: ../../pep-0218.txt:161
msgid "The BaseSet concept was eliminated."
msgstr ""

#: ../../pep-0218.txt:162
msgid "The ``union_update()`` method became just ``update()``."
msgstr ""

#: ../../pep-0218.txt:163
msgid "Auto-conversion between mutable and immutable sets was dropped."
msgstr ""

#: ../../pep-0218.txt:164
msgid ""
"The ``_repr`` method was dropped (the need is met by the new ``sorted()``"
" built-in function)."
msgstr ""

#: ../../pep-0218.txt:167
msgid ""
"Tim Peters believes that the class's constructor should take a single "
"sequence as an argument, and populate the set with that sequence's "
"elements.  His argument is that in most cases, programmers will be "
"creating sets from pre-existing sequences, so that this case should be "
"the common one.  However, this would require users to remember an extra "
"set of parentheses when initializing a set with known values::"
msgstr ""

#: ../../pep-0218.txt:177
msgid ""
"On the other hand, feedback from a small number of novice Python users "
"(all of whom were very experienced with other languages) indicates that "
"people will find a \"parenthesis-free\" syntax more natural::"
msgstr ""

#: ../../pep-0218.txt:184
msgid ""
"Ultimately, we adopted the first strategy in which the initializer takes "
"a single iterable argument."
msgstr ""

#: ../../pep-0218.txt:189
msgid "Mutability"
msgstr ""

#: ../../pep-0218.txt:191
msgid ""
"The most difficult question to resolve in this proposal was whether sets "
"ought to be able to contain mutable elements.  A dictionary's keys must "
"be immutable in order to support fast, reliable lookup.  While it would "
"be easy to require set elements to be immutable, this would preclude sets"
" of sets (which are widely used in graph algorithms and other "
"applications)."
msgstr ""

#: ../../pep-0218.txt:198
msgid ""
"Earlier drafts of PEP 218 had only a single set type, but the ``sets.py``"
" implementation in Python 2.3 has two, Set and ImmutableSet.  For Python "
"2.4, the new built-in types were named ``set`` and ``frozenset`` which "
"are slightly less cumbersome."
msgstr ""

#: ../../pep-0218.txt:203
msgid ""
"There are two classes implemented in the \"sets\" module.  Instances of "
"the Set class can be modified by the addition or removal of elements, and"
" the ImmutableSet class is \"frozen\", with an unchangeable collection of"
" elements.  Therefore, an ImmutableSet may be used as a dictionary key or"
" as a set element, but cannot be updated.  Both types of set require that"
" their elements are immutable, hashable objects.  Parallel comments apply"
" to the \"set\" and \"frozenset\" built-in types."
msgstr ""

#: ../../pep-0218.txt:214
msgid "Copyright"
msgstr ""

#: ../../pep-0218.txt:216
msgid "This document has been placed in the Public Domain."
msgstr ""

