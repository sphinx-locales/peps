# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0635.rst
msgid "PEP"
msgstr ""

#: ../../pep-0635.rst:1
msgid "635"
msgstr ""

#: ../../pep-0635.rst
msgid "Title"
msgstr ""

#: ../../pep-0635.rst:2
msgid "Structural Pattern Matching: Motivation and Rationale"
msgstr ""

#: ../../pep-0635.rst
msgid "Author"
msgstr ""

#: ../../pep-0635.rst:5
msgid "Tobias Kohn <kohnt@tobiaskohn.ch>, Guido van Rossum <guido@python.org>"
msgstr ""

#: ../../pep-0635.rst
msgid "BDFL-Delegate"
msgstr ""

#: ../../pep-0635.rst
msgid "Discussions-To"
msgstr ""

#: ../../pep-0635.rst:8
msgid "Python-Dev <python-dev@python.org>"
msgstr ""

#: ../../pep-0635.rst
msgid "Status"
msgstr ""

#: ../../pep-0635.rst:9
msgid "Final"
msgstr ""

#: ../../pep-0635.rst
msgid "Type"
msgstr ""

#: ../../pep-0635.rst:10
msgid "Informational"
msgstr ""

#: ../../pep-0635.rst
msgid "Created"
msgstr ""

#: ../../pep-0635.rst:12
msgid "12-Sep-2020"
msgstr ""

#: ../../pep-0635.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0635.rst:13
msgid "3.10"
msgstr ""

#: ../../pep-0635.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0635.rst:14
msgid "22-Oct-2020, 08-Feb-2021"
msgstr ""

#: ../../pep-0635.rst
msgid "Resolution"
msgstr ""

#: ../../pep-0635.rst:15
msgid ""
"https://mail.python.org/archives/list/python-"
"committers@python.org/message/SQC2FTLFV5A7DV7RCEAR2I2IKJKGK7W3"
msgstr ""

#: ../../pep-0635.rst:19
msgid "Abstract"
msgstr ""

#: ../../pep-0635.rst:21
msgid ""
"This PEP provides the motivation and rationale for PEP 634 (\"Structural "
"Pattern Matching: Specification\").  First-time readers are encouraged to"
" start with PEP 636, which provides a gentler introduction to the "
"concepts, syntax and semantics of patterns."
msgstr ""

#: ../../pep-0635.rst:28
msgid "Motivation"
msgstr ""

#: ../../pep-0635.rst:30
msgid ""
"(Structural) pattern matching syntax is found in many languages, from "
"Haskell, Erlang and Scala to Elixir and Ruby.  (A proposal for JavaScript"
" is also under consideration.)"
msgstr ""

#: ../../pep-0635.rst:34
msgid ""
"Python already supports a limited form of this through sequence unpacking"
" assignments, which the new proposal leverages."
msgstr ""

#: ../../pep-0635.rst:37
msgid "Several other common Python idioms are also relevant:"
msgstr ""

#: ../../pep-0635.rst:39
msgid ""
"The ``if ... elif ... elif ... else`` idiom is often used to find out the"
" type or shape of an object in an ad-hoc fashion, using one or more "
"checks like ``isinstance(x, cls)``, ``hasattr(x, \"attr\")``, ``len(x) =="
" n`` or ``\"key\" in x`` as guards to select an applicable block.  The "
"block can then assume ``x`` supports the interface checked by the guard."
"  For example::"
msgstr ""

#: ../../pep-0635.rst:53
msgid "Code like this is more elegantly rendered using ``match``::"
msgstr ""

#: ../../pep-0635.rst:62
msgid ""
"AST traversal code often looks for nodes matching a given pattern, for "
"example the code to detect a node of the shape \"A + B * C\" might look "
"like this::"
msgstr ""

#: ../../pep-0635.rst:71
msgid "Using ``match`` this becomes more readable::"
msgstr ""

#: ../../pep-0635.rst:77
msgid ""
"We believe that adding pattern matching to Python will enable Python "
"users to write cleaner, more readable code for examples like those above,"
" and many others."
msgstr ""

#: ../../pep-0635.rst:81
msgid "For a more academic discussion to this proposal, see [1]_."
msgstr ""

#: ../../pep-0635.rst:85
msgid "Pattern Matching and OO"
msgstr ""

#: ../../pep-0635.rst:87
msgid ""
"Pattern matching is complimentary to the object-oriented paradigm. Using "
"OO and inheritance we can easily define a method on a base class that "
"defines default behavior for a specific operation on that class, and we "
"can override this default behavior in subclasses.  We can also use the "
"Visitor pattern to separate actions from data."
msgstr ""

#: ../../pep-0635.rst:93
msgid ""
"But this is not sufficient for all situations.  For example, a code "
"generator may consume an AST, and have many operations where the "
"generated code needs to vary based not just on the class of a node, but "
"also on the value of some class attributes, like the ``BinOp`` example "
"above.  The Visitor pattern is insufficiently flexible for this: it can "
"only select based on the class."
msgstr ""

#: ../../pep-0635.rst:100
msgid ""
"For a complete example, see "
"https://github.com/gvanrossum/patma/blob/master/examples/expr.py#L231"
msgstr ""

#: ../../pep-0635.rst:103
msgid ""
"Like the Visitor pattern, pattern matching allows for a strict separation"
" of concerns: specific actions or data processing is independent of the "
"class hierarchy or manipulated objects.  When dealing with predefined or "
"even built-in classes, in particular, it is often impossible to add "
"further methods to the individual classes.  Pattern matching not only "
"relieves the programmer or class designer from the burden of the "
"boilerplate code needed for the Visitor pattern, but is also flexible "
"enough to directly work with built-in types.  It naturally distinguishes "
"between sequences of different lengths, which might all share the same "
"class despite obviously differing structures.  Moreover, pattern matching"
" automatically takes inheritance into account: a class *D* inheriting "
"from *C* will be handled by a pattern that targets *C* by default."
msgstr ""

#: ../../pep-0635.rst:116
msgid ""
"Object oriented programming is geared towards single-dispatch: it is a "
"single instance (or the type thereof) that determines which method is to "
"be called.  This leads to a somewhat artificial situation in case of "
"binary operators where both objects might play an equal role in deciding "
"which implementation to use (Python addresses this through the use of "
"reversed binary methods).  Pattern matching is structurally better suited"
" to handle such situations of multi-dispatch, where the action to be "
"taken depends on the types of several objects to equal parts."
msgstr ""

#: ../../pep-0635.rst:127
msgid "Patterns and Functional Style"
msgstr ""

#: ../../pep-0635.rst:129
msgid ""
"Many Python applications and libraries are not written in a consistent OO"
" style -- unlike Java, Python encourages defining functions at the top-"
"level of a module, and for simple data structures, tuples (or named "
"tuples or lists) and dictionaries are often used exclusively or mixed "
"with classes or data classes."
msgstr ""

#: ../../pep-0635.rst:135
msgid ""
"Pattern matching is particularly suitable for picking apart such data "
"structures.  As an extreme example, it's easy to write code that picks a "
"JSON data structure using ``match``::"
msgstr ""

#: ../../pep-0635.rst:147
msgid ""
"Functional programming generally prefers a declarative style with a focus"
" on relationships in data.  Side effects are avoided whenever possible. "
"Pattern matching thus naturally fits and highly supports functional "
"programming style."
msgstr ""

#: ../../pep-0635.rst:154
msgid "Rationale"
msgstr ""

#: ../../pep-0635.rst:156
msgid ""
"This section provides the rationale for individual design decisions. It "
"takes the place of \"Rejected ideas\" in the standard PEP format. It is "
"organized in sections corresponding to the specification (PEP 634)."
msgstr ""

#: ../../pep-0635.rst:162
msgid "Overview and Terminology"
msgstr ""

#: ../../pep-0635.rst:164
msgid ""
"Much of the power of pattern matching comes from the nesting of "
"subpatterns. That the success of a pattern match depends directly on the "
"success of subpattern is thus a cornerstone of the design.  However, "
"although a pattern like ``P(Q(), R())`` succeeds only if both subpatterns"
" ``Q()`` and ``R()`` succeed (i.e. the success of pattern ``P`` depends "
"on ``Q`` and ``R``), the pattern ``P`` is checked first.  If ``P`` fails,"
" neither ``Q()`` nor ``R()`` will be tried (this is a direct consequence "
"of the fact that if ``P`` fails, there are no subjects to match against "
"``Q()`` and ``R()`` in the first place)."
msgstr ""

#: ../../pep-0635.rst:174
msgid ""
"Also note that patterns bind names to values rather than performing an "
"assignment.  This reflects the fact that patterns aim to not have side "
"effects, which also means that Capture or AS patterns cannot assign a "
"value to an attribute or subscript.  We thus consistently use the term "
"'bind' instead of 'assign' to emphasise this subtle difference between "
"traditional assignments and name binding in patterns."
msgstr ""

#: ../../pep-0635.rst:183
msgid "The Match Statement"
msgstr ""

#: ../../pep-0635.rst:185
msgid ""
"The match statement evaluates an expression to produce a subject, finds "
"the first pattern that matches the subject, and executes the associated "
"block of code.  Syntactically, the match statement thus takes an "
"expression and a sequence of case clauses, where each case clause "
"comprises a pattern and a block of code."
msgstr ""

#: ../../pep-0635.rst:191
msgid ""
"Since case clauses comprise a block of code, they adhere to the existing "
"indentation scheme with the syntactic structure of ``<keyword> ...: "
"<(indented) block>``, which resembles a compound statement.  The keyword "
"``case`` reflects its widespread use in pattern matching languages, "
"ignoring those languages that use other syntactic means such as a symbol "
"like ``|``, because it would not fit established Python structures.  The "
"syntax of patterns following the keyword is discussed below."
msgstr ""

#: ../../pep-0635.rst:200
msgid ""
"Given that the case clauses follow the structure of a compound statement,"
" the match statement itself naturally becomes a compound statement itself"
" as well, following the same syntactic structure.  This naturally leads "
"to ``match <expr>: <case_clause>+``.  Note that the match statement "
"determines a quasi-scope in which the evaluated subject is kept alive "
"(although not in a local variable), similar to how a with statement might"
" keep a resource alive during execution of its block.  Furthermore, "
"control flows from the match statement to a case clause and then leaves "
"the block of the match statement.  The block of the match statement thus "
"has both syntactic and semantic meaning."
msgstr ""

#: ../../pep-0635.rst:211
msgid ""
"Various suggestions have sought to eliminate or avoid the naturally "
"arising \"double indentation\" of a case clause's code block.  "
"Unfortunately, all such proposals of *flat indentation schemes* come at "
"the expense of violating Python's established structural paradigm, "
"leading to additional syntactic rules:"
msgstr ""

#: ../../pep-0635.rst:217
msgid ""
"*Unindented case clauses.* The idea is to align case clauses with the "
"``match``, i.e.::"
msgstr ""

#: ../../pep-0635.rst:226
msgid ""
"This may look awkward to the eye of a Python programmer, because "
"everywhere else a colon is followed by an indent.  The ``match`` would "
"neither follow the syntactic scheme of simple nor composite statements "
"but rather establish a category of its own."
msgstr ""

#: ../../pep-0635.rst:231
msgid ""
"*Putting the expression on a separate line after \"match\".* The idea is "
"to use the expression yielding the subject as a statement to avoid the "
"singularity of ``match`` having no actual block despite the colons::"
msgstr ""

#: ../../pep-0635.rst:243
msgid ""
"This was ultimately rejected because the first block would be another "
"novelty in Python's grammar: a block whose only content is a single "
"expression rather than a sequence of statements.  Attempts to amend this "
"issue by adding or repurposing yet another keyword along the lines of "
"``match: return expression`` did not yield any satisfactory solution."
msgstr ""

#: ../../pep-0635.rst:249
msgid ""
"Although flat indentation would save some horizontal space, the cost of "
"increased complexity or unusual rules is too high.  It would also "
"complicate life for simple-minded code editors. Finally, the horizontal "
"space issue can be alleviated by allowing \"half-indent\" (i.e. two "
"spaces instead of four) for match statements (though we do not recommend "
"this)."
msgstr ""

#: ../../pep-0635.rst:255
msgid ""
"In sample programs using ``match``, written as part of the development of"
" this PEP, a noticeable improvement in code brevity is observed, more "
"than making up for the additional indentation level."
msgstr ""

#: ../../pep-0635.rst:260
msgid ""
"*Statement vs. Expression.*  Some suggestions centered around the idea of"
" making ``match`` an expression rather than a statement.  However, this "
"would fit poorly with Python's statement-oriented nature and lead to "
"unusually long and complex expressions and the need to invent new "
"syntactic constructs or break well established syntactic rules.  An "
"obvious consequence of ``match`` as an expression would be that case "
"clauses could no longer have arbitrary blocks of code attached, but only "
"a single expression.  Overall, the strong limitations could in no way "
"offset the slight simplification in some special use cases."
msgstr ""

#: ../../pep-0635.rst:271
msgid ""
"*Hard vs. Soft Keyword.*  There were options to make match a hard "
"keyword, or choose a different keyword. Although using a hard keyword "
"would simplify life for simple-minded syntax highlighters, we decided not"
" to use hard keyword for several reasons:"
msgstr ""

#: ../../pep-0635.rst:276
msgid ""
"Most importantly, the new parser doesn't require us to do this. Unlike "
"with ``async`` that caused hardships with being a soft keyword for few "
"releases, here we can make ``match`` a permanent soft keyword."
msgstr ""

#: ../../pep-0635.rst:280
msgid ""
"``match`` is so commonly used in existing code, that it would break "
"almost every existing program and will put a burden to fix code on many "
"people who may not even benefit from the new syntax."
msgstr ""

#: ../../pep-0635.rst:284
msgid ""
"It is hard to find an alternative keyword that would not be commonly used"
" in existing programs as an identifier, and would still clearly reflect "
"the meaning of the statement."
msgstr ""

#: ../../pep-0635.rst:289
msgid ""
"**Use \"as\" or \"|\" instead of \"case\" for case clauses.** The pattern"
" matching proposed here is a combination of multi-branch control flow (in"
" line with ``switch`` in Algol-derived languages or ``cond`` in Lisp) and"
" object-deconstruction as found in functional languages.  While the "
"proposed keyword ``case`` highlights the multi-branch aspect, alternative"
" keywords such as ``as`` would equally be possible, highlighting the "
"deconstruction aspect. ``as`` or ``with``, for instance, also have the "
"advantage of already being keywords in Python.  However, since ``case`` "
"as a keyword can only occur as a leading keyword inside  a ``match`` "
"statement, it is easy for a parser to distinguish between its use as a "
"keyword or as a variable."
msgstr ""

#: ../../pep-0635.rst:300
msgid ""
"Other variants would use a symbol like ``|`` or ``=>``, or go entirely "
"without special marker."
msgstr ""

#: ../../pep-0635.rst:303
msgid ""
"Since Python is a statement-oriented language in the tradition of Algol, "
"and as each composite statement starts with an identifying keyword, "
"``case`` seemed to be most in line with Python's style and traditions."
msgstr ""

#: ../../pep-0635.rst:309
msgid "Match Semantics"
msgstr ""

#: ../../pep-0635.rst:311
msgid ""
"The patterns of different case clauses might overlap in that more than "
"one case clause would match a given subject.  The first-to-match rule "
"ensures that the selection of a case clause for a given subject is "
"unambiguous.  Furthermore, case clauses can have increasingly general "
"patterns matching wider sets of subjects.  The first-to-match rule then "
"ensures that the most precise pattern can be chosen (although it is the "
"programmer's responsibility to order the case clauses correctly)."
msgstr ""

#: ../../pep-0635.rst:319
msgid ""
"In a statically typed language, the match statement would be compiled to "
"a decision tree to select a matching pattern quickly and very "
"efficiently. This would, however, require that all patterns be purely "
"declarative and static, running against the established dynamic semantics"
" of Python.  The proposed semantics thus represent a path incorporating "
"the best of both worlds: patterns are tried in a strictly sequential "
"order so that each case clause constitutes an actual statement.  At the "
"same time, we allow the interpreter to cache any information about the "
"subject or change the order in which subpatterns are tried.  In other "
"words: if the interpreter has found that the subject is not an instance "
"of a class ``C``, it can directly skip case clauses testing for this "
"again, without having to perform repeated instance-checks.  If a guard "
"stipulates that a variable ``x`` must be positive, say (i.e. ``if x > "
"0``), the interpreter might check this directly after binding ``x`` and "
"before any further subpatterns are considered."
msgstr ""

#: ../../pep-0635.rst:336
msgid ""
"*Binding and scoping.*  In many pattern matching implementations, each "
"case clause would establish a separate scope of its own.  Variables bound"
" by a pattern would then only be visible inside the corresponding case "
"block. In Python, however, this does not make sense.  Establishing "
"separate scopes would essentially mean that each case clause is a "
"separate function without direct access to the variables in the "
"surrounding scope (without having to resort to ``nonlocal`` that is).  "
"Moreover, a case clause could no longer influence any surrounding control"
" flow through standard statement such as ``return`` or ``break``.  Hence,"
" such strict scoping would lead to unintuitive and surprising behavior."
msgstr ""

#: ../../pep-0635.rst:347
msgid ""
"A direct consequence of this is that any variable bindings outlive the "
"respective case or match statements.  Even patterns that only match a "
"subject partially might bind local variables (this is, in fact, necessary"
" for guards to function properly).  However, these semantics for variable"
" binding are in line with existing Python structures such as for loops "
"and with statements."
msgstr ""

#: ../../pep-0635.rst:356
msgid "Guards"
msgstr ""

#: ../../pep-0635.rst:358
msgid ""
"Some constraints cannot be adequately expressed through patterns alone. "
"For instance, a 'less' or 'greater than' relationship defies the usual "
"'equal' semantics of patterns.  Moreover, different subpatterns are "
"independent and cannot refer to each other.  The addition of *guards* "
"addresses these restrictions: a guard is an arbitrary expression attached"
" to a pattern and that must evaluate to a \"truthy\" value for the "
"pattern to succeed."
msgstr ""

#: ../../pep-0635.rst:365
msgid ""
"For example, ``case [x, y] if x < y:`` uses a guard (``if x < y``) to "
"express a 'less than' relationship between two otherwise disjoint capture"
" patterns ``x`` and ``y``."
msgstr ""

#: ../../pep-0635.rst:369
msgid ""
"From a conceptual point of view, patterns describe structural constraints"
" on the subject in a declarative style, ideally without any side-effects."
" Recall, in particular, that patterns are clearly distinct from "
"expressions, following different objectives and semantics.  Guards then "
"enhance case blocks in a highly controlled way with arbitrary expressions"
" (that might have side effects).  Splitting the overall functionality "
"into a static structural and a dynamically evaluated part not only helps "
"with readability, but can also introduce dramatic potential for compiler "
"optimizations.  To keep this clear separation, guards are only supported "
"on the level of case clauses and not for individual patterns."
msgstr ""

#: ../../pep-0635.rst:380
msgid "**Example** using guards::"
msgstr ""

#: ../../pep-0635.rst:403
msgid "Patterns"
msgstr ""

#: ../../pep-0635.rst:405
msgid ""
"Patterns fulfill two purposes: they impose (structural) constraints on "
"the subject and they specify which data values should be extracted from "
"the subject and bound to variables.  In iterable unpacking, which can be "
"seen as a prototype to pattern matching in Python, there is only one "
"*structural pattern* to express sequences while there is a rich set of "
"*binding patterns* to assign a value to a specific variable or field. "
"Full pattern matching differs from this in that there is more variety in "
"structural patterns but only a minimum of binding patterns."
msgstr ""

#: ../../pep-0635.rst:414
msgid ""
"Patterns differ from assignment targets (as in iterable unpacking) in two"
" ways: they impose additional constraints on the structure of the "
"subject, and a subject may safely fail to match a specific pattern at any"
" point (in iterable unpacking, this constitutes an error).  The latter "
"means that pattern should avoid side effects wherever possible."
msgstr ""

#: ../../pep-0635.rst:420
msgid ""
"This desire to avoid side effects is one reason why capture patterns "
"don't allow binding values to attributes or subscripts: if the containing"
" pattern were to fail in a later step, it would be hard to revert such "
"bindings."
msgstr ""

#: ../../pep-0635.rst:425
msgid ""
"A cornerstone of pattern matching is the possibility of arbitrarily "
"*nesting patterns*.  The nesting allows expressing deep tree structures "
"(for an example of nested class patterns, see the motivation section "
"above) as well as alternatives."
msgstr ""

#: ../../pep-0635.rst:430
msgid ""
"Although patterns might superficially look like expressions, it is "
"important to keep in mind that there is a clear distinction.  In fact, no"
" pattern is or contains an expression.  It is more productive to think of"
" patterns as declarative elements similar to the formal parameters in a "
"function definition."
msgstr ""

#: ../../pep-0635.rst:438
msgid "AS Patterns"
msgstr ""

#: ../../pep-0635.rst:440
msgid ""
"Patterns fall into two categories: most patterns impose a (structural) "
"constraint that the subject needs to fulfill, whereas the capture pattern"
" binds the subject to a name without regard for the subject's structure "
"or actual value.  Consequently, a pattern can either express a constraint"
" or bind a value, but not both.  AS patterns fill this gap in that they "
"allow the user to specify a general pattern as well as capture the "
"subject in a variable."
msgstr ""

#: ../../pep-0635.rst:448
msgid ""
"Typical use cases for the AS pattern include OR and Class patterns "
"together with a binding name as in, e.g., ``case BinOp('+'|'-' as op, "
"...):`` or ``case [int() as first, int() as second]:``.  The latter could"
" be understood as saying that the subject must fulfil two distinct "
"pattern: ``[first, second]`` as well as ``[int(), int()]``.  The AS "
"pattern can thus be seen as a special case of an 'and' pattern (see OR "
"patterns below for an additional discussion of 'and' patterns)."
msgstr ""

#: ../../pep-0635.rst:456
msgid ""
"In an earlier version, the AS pattern was devised as a 'Walrus pattern', "
"written as ``case [first:=int(), second:=int()]``.  However, using ``as``"
" offers some advantages over ``:=``:"
msgstr ""

#: ../../pep-0635.rst:460
msgid ""
"The walrus operator ``:=`` is used to capture the result of an expression"
" on the right hand side, whereas ``as`` generally indicates some form of "
"'processing' as in ``import foo as bar`` or ``except E as err:``.  "
"Indeed, the pattern ``P as x`` does not assign the pattern ``P`` to "
"``x``, but rather the subject that successfully matches ``P``."
msgstr ""

#: ../../pep-0635.rst:466
msgid ""
"``as`` allows for a more consistent data flow from left to right (the "
"attributes in Class patterns also follow a left-to-right data flow)."
msgstr ""

#: ../../pep-0635.rst:469
msgid ""
"The walrus operator looks very similar to the syntax for matching "
"attributes in the Class pattern, potentially leading to some confusion."
msgstr ""

#: ../../pep-0635.rst:472
msgid "**Example** using the AS pattern::"
msgstr ""

#: ../../pep-0635.rst:487
msgid "OR Patterns"
msgstr ""

#: ../../pep-0635.rst:489
msgid ""
"The OR pattern allows you to combine 'structurally equivalent' "
"alternatives into a new pattern, i.e. several patterns can share a common"
" handler.  If any of an OR pattern's subpatterns matches the subject, the"
" entire OR pattern succeeds."
msgstr ""

#: ../../pep-0635.rst:494
msgid ""
"Statically typed languages prohibit the binding of names (capture "
"patterns) inside an OR pattern because of potential conflicts concerning "
"the types of variables.  As a dynamically typed language, Python can be "
"less restrictive here and allow capture patterns inside OR patterns.  "
"However, each subpattern must bind the same set of variables so as not to"
" leave potentially undefined names.  With two alternatives ``P | Q``, "
"this means that if *P* binds the variables *u* and *v*, *Q* must bind "
"exactly the same variables *u* and *v*."
msgstr ""

#: ../../pep-0635.rst:502
msgid ""
"There was some discussion on whether to use the bar symbol ``|`` or the "
"``or`` keyword to separate alternatives.  The OR pattern does not fully "
"fit the existing semantics and usage of either of these two symbols.  "
"However, ``|`` is the symbol of choice in all programming languages with "
"support of the OR pattern and is used in that capacity for regular "
"expressions in Python as well.  It is also the traditional separator "
"between alternatives in formal grammars (including Python's). Moreover, "
"``|`` is not only used for bitwise OR, but also for set unions and dict "
"merging (:pep:`584`)."
msgstr ""

#: ../../pep-0635.rst:512
msgid ""
"Other alternatives were considered as well, but none of these would allow"
" OR-patterns to be nested inside other patterns:"
msgstr ""

#: ../../pep-0635.rst:515
msgid "*Using a comma*::"
msgstr ""

#: ../../pep-0635.rst:520
msgid ""
"This looks too much like a tuple -- we would have to find a different way"
" to spell tuples, and the construct would have to be parenthesized inside"
" the argument list of a class pattern. In general, commas already have "
"many different meanings in Python, we shouldn't add more."
msgstr ""

#: ../../pep-0635.rst:525
msgid "*Using stacked cases*::"
msgstr ""

#: ../../pep-0635.rst:532
msgid ""
"This is how this would be done in *C*, using its fall-through semantics "
"for cases. However, we don't want to mislead people into thinking that "
"match/case uses fall-through semantics (which are a common source of bugs"
" in *C*). Also, this would be a novel indentation pattern, which might "
"make it harder to support in IDEs and such (it would break the simple "
"rule \"add an indentation level after a line ending in a colon\").  "
"Finally, this would not support OR patterns nested inside other patterns,"
" either."
msgstr ""

#: ../../pep-0635.rst:540
msgid "*Using \"case in\" followed by a comma-separated list*::"
msgstr ""

#: ../../pep-0635.rst:545
msgid "This would not work for OR patterns nested inside other patterns, like::"
msgstr ""

#: ../../pep-0635.rst:551
msgid "**AND and NOT Patterns**"
msgstr ""

#: ../../pep-0635.rst:553
msgid ""
"Since this proposal defines an OR-pattern (``|``) to match one of several"
" alternates, why not also an AND-pattern (``&``) or even a NOT-pattern "
"(``!``)? Especially given that some other languages (``F#`` for example) "
"support AND-patterns."
msgstr ""

#: ../../pep-0635.rst:558
msgid ""
"However, it is not clear how useful this would be. The semantics for "
"matching dictionaries, objects and sequences already incorporates an "
"implicit 'and': all attributes and elements mentioned must be present for"
" the match to succeed. Guard conditions can also support many of the use "
"cases that a hypothetical 'and' operator would be used for."
msgstr ""

#: ../../pep-0635.rst:564
msgid ""
"A negation of a match pattern using the operator ``!`` as a prefix would "
"match exactly if the pattern itself does not match.  For instance, ``!(3 "
"| 4)`` would match anything except ``3`` or ``4``. However, there is "
"`evidence from other languages "
"<https://dl.acm.org/doi/abs/10.1145/2480360.2384582>`_ that this is "
"rarely useful, and primarily used as double negation ``!!`` to control "
"variable scopes and prevent variable bindings (which does not apply to "
"Python).  Other use cases are better expressed using guards."
msgstr ""

#: ../../pep-0635.rst:573
msgid ""
"In the end, it was decided that this would make the syntax more complex "
"without adding a significant benefit.  It can always be added later."
msgstr ""

#: ../../pep-0635.rst:576
msgid "**Example** using the OR pattern::"
msgstr ""

#: ../../pep-0635.rst:592
msgid "Literal Patterns"
msgstr ""

#: ../../pep-0635.rst:594
msgid ""
"Literal patterns are a convenient way for imposing constraints on the "
"value of a subject, rather than its type or structure.  They also allow "
"you to emulate a switch statement using pattern matching."
msgstr ""

#: ../../pep-0635.rst:598
msgid ""
"Generally, the subject is compared to a literal pattern by means of "
"standard equality (``x == y`` in Python syntax).  Consequently, the "
"literal patterns ``1.0`` and ``1`` match exactly the same set of objects,"
" i.e. ``case 1.0:`` and ``case 1:`` are fully interchangeable.  In "
"principle, ``True`` would also match the same set of objects because "
"``True == 1`` holds.  However, we believe that many users would be "
"surprised finding that ``case True:`` matched the subject ``1.0``, "
"resulting in some subtle bugs and convoluted workarounds.  We therefore "
"adopted the rule that the three singleton patterns ``None``, ``False`` "
"and ``True`` match by identity (``x is y`` in Python syntax) rather than "
"equality.  Hence, ``case True:`` will match only ``True`` and nothing "
"else.  Note that ``case 1:`` would still match ``True``, though, because "
"the literal pattern ``1`` works by equality and not identity."
msgstr ""

#: ../../pep-0635.rst:611
msgid ""
"Early ideas to induce a hierarchy on numbers so that ``case 1.0`` would "
"match both the integer ``1`` and the floating point number ``1.0``, "
"whereas ``case 1:`` would only match the integer ``1`` were eventually "
"dropped in favor of the simpler and more consistent rule based on "
"equality.  Moreover, any additional checks whether the subject is an "
"instance of ``numbers.Integral`` would come at a high runtime cost to "
"introduce what would essentially be a novel idea in Python.  When needed,"
" the explicit syntax ``case int(1):`` can be used."
msgstr ""

#: ../../pep-0635.rst:620
msgid ""
"Recall that literal patterns are *not* expressions, but directly denote a"
" specific value.  From a pragmatic point of view, we want to allow using "
"negative and even complex values as literal patterns, but they are not "
"atomic literals (only unsigned real and imaginary numbers are).  E.g., "
"``-3+4j`` is syntactically an expression of the form ``BinOp(UnaryOp('-',"
" 3), '+', 4j)``.  Since expressions are not part of patterns, we had to "
"add explicit syntactic support for such values without having to resort "
"to full expressions."
msgstr ""

#: ../../pep-0635.rst:629
msgid ""
"Interpolated *f*-strings, on the other hand, are not literal values, "
"despite their appearance and can therefore not be used as literal "
"patterns (string concatenation, however, is supported)."
msgstr ""

#: ../../pep-0635.rst:634
msgid ""
"Literal patterns not only occur as patterns in their own right, but also "
"as keys in *mapping patterns*."
msgstr ""

#: ../../pep-0635.rst:638
msgid ""
"**Range matching patterns.** This would allow patterns such as ``1...6``."
" However, there are a host of ambiguities:"
msgstr ""

#: ../../pep-0635.rst:642
msgid ""
"Is the range open, half-open, or closed? (I.e. is ``6`` included in the "
"above example or not?)"
msgstr ""

#: ../../pep-0635.rst:644
msgid "Does the range match a single number, or a range object?"
msgstr ""

#: ../../pep-0635.rst:645
msgid ""
"Range matching is often used for character ranges ('a'...'z') but that "
"won't work in Python since there's no character data type, just strings."
msgstr ""

#: ../../pep-0635.rst:647
msgid ""
"Range matching can be a significant performance optimization if you can "
"pre-build a jump table, but that's not generally possible in Python due "
"to the fact that names can be dynamically rebound."
msgstr ""

#: ../../pep-0635.rst:651
msgid ""
"Rather than creating a special-case syntax for ranges, it was decided "
"that allowing custom pattern objects (``InRange(0, 6)``) would be more "
"flexible and less ambiguous; however those ideas have been postponed for "
"the time being."
msgstr ""

#: ../../pep-0635.rst:657
msgid "**Example** using Literal patterns::"
msgstr ""

#: ../../pep-0635.rst:681
msgid "Capture Patterns"
msgstr ""

#: ../../pep-0635.rst:683
msgid ""
"Capture patterns take on the form of a name that accepts any value and "
"binds it to a (local) variable (unless the name is declared as "
"``nonlocal`` or ``global``).  In that sense, a capture pattern is similar"
" to a parameter in a function definition (when the function is called, "
"each parameter binds the respective argument to a local variable in the "
"function's scope)."
msgstr ""

#: ../../pep-0635.rst:690
msgid ""
"A name used for a capture pattern must not coincide with another capture "
"pattern in the same pattern.  This, again, is similar to parameters, "
"which equally require each parameter name to be unique within the list of"
" parameters.  It differs, however, from iterable unpacking assignment, "
"where the repeated use of a variable name as target is permissible (e.g.,"
" ``x, x = 1, 2``).  The rationale for not supporting ``(x, x)`` in "
"patterns is its ambiguous reading: it could be seen as in iterable "
"unpacking where only the second binding to ``x`` survives.  But it could "
"be equally seen as expressing a tuple with two equal elements (which "
"comes with its own issues). Should the need arise, then it is still "
"possible to introduce support for repeated use of names later on."
msgstr ""

#: ../../pep-0635.rst:702
msgid ""
"There were calls to explicitly mark capture patterns and thus identify "
"them as binding targets.  According to that idea, a capture pattern would"
" be written as, e.g. ``?x``, ``$x`` or ``=x``.  The aim of such explicit "
"capture markers is to let an unmarked name be a value pattern (see "
"below). However, this is based on the misconception that pattern matching"
" was an extension of *switch* statements, placing the emphasis on fast "
"switching based on (ordinal) values.  Such a *switch* statement has "
"indeed been proposed for Python before (see :pep:`275` and :pep:`3103`)."
"  Pattern matching, on the other hand, builds a generalized concept of "
"iterable unpacking.  Binding values extracted from a data structure is at"
" the very core of the concept and hence the most common use case.  "
"Explicit markers for capture patterns would thus betray the objective of "
"the proposed pattern matching syntax and simplify a secondary use case at"
" the expense of additional syntactic clutter for core cases."
msgstr ""

#: ../../pep-0635.rst:717
msgid ""
"It has been proposed that capture patterns are not needed at all, since "
"the equivalent effect can be obtained by combining an AS pattern with a "
"wildcard pattern (e.g., ``case _ as x`` is equivalent to ``case x``).  "
"However, this would be unpleasantly verbose, especially given that we "
"expect capture patterns to be very common."
msgstr ""

#: ../../pep-0635.rst:723
msgid "**Example** using Capture patterns::"
msgstr ""

#: ../../pep-0635.rst:740
msgid "Wildcard Pattern"
msgstr ""

#: ../../pep-0635.rst:742
msgid ""
"The wildcard pattern is a special case of a 'capture' pattern: it accepts"
" any value, but does not bind it to a variable.  The idea behind this "
"rule is to support repeated use of the wildcard in patterns.  While ``(x,"
" x)`` is an error, ``(_, _)`` is legal."
msgstr ""

#: ../../pep-0635.rst:747
msgid ""
"Particularly in larger (sequence) patterns, it is important to allow the "
"pattern to concentrate on values with actual significance while ignoring "
"anything else.  Without a wildcard, it would become necessary to 'invent'"
" a number of local variables, which would be bound but never used.  Even "
"when sticking to naming conventions and using e.g. ``_1, _2, _3`` to name"
" irrelevant values, say, this still introduces visual clutter and can "
"hurt performance (compare the sequence pattern ``(x, y, *z)`` to ``(_, y,"
" *_)``, where the ``*z`` forces the interpreter to copy a potentially "
"very long sequence, whereas the second version simply compiles to code "
"along the lines of ``y = seq[1]``)."
msgstr ""

#: ../../pep-0635.rst:758
msgid ""
"There has been much discussion about the choice of the underscore as "
"``_`` as a wildcard pattern, i.e. making this one name non-binding.  "
"However, the underscore is already heavily used as an 'ignore value' "
"marker in iterable unpacking.  Since the wildcard pattern ``_`` never "
"binds, this use of the underscore does not interfere with other uses such"
" as inside the REPL or the ``gettext`` module."
msgstr ""

#: ../../pep-0635.rst:765
msgid ""
"It has been proposed to use ``...`` (i.e., the ellipsis token) or ``*`` "
"(star) as a wildcard.  However, both these look as if an arbitrary number"
" of items is omitted::"
msgstr ""

#: ../../pep-0635.rst:772
msgid ""
"Either example looks like it would match a sequence of two or more items,"
" capturing the first and last values.  While that may be the ultimate "
"\"wildcard\", it does not convey the desired semantics."
msgstr ""

#: ../../pep-0635.rst:776
msgid ""
"An alternative that does not suggest an arbitrary number of items would "
"be ``?``.  This is even being proposed independently from pattern "
"matching in PEP 640.  We feel however that using ``?`` as a special "
"\"assignment\" target is likely more confusing to Python users than using"
" ``_``.  It violates Python's (admittedly vague) principle of using "
"punctuation characters only in ways similar to how they are used in "
"common English usage or in high school math, unless the usage is *very* "
"well established in other programming languages (like, e.g., using a dot "
"for member access)."
msgstr ""

#: ../../pep-0635.rst:786
msgid ""
"The question mark fails on both counts: its use in other programming "
"languages is a grab-bag of usages only vaguely suggested by the idea of a"
" \"question\".  For example, it means \"any character\" in shell "
"globbing, \"maybe\" in regular expressions, \"conditional expression\" in"
" C and many C-derived languages, \"predicate function\" in Scheme, "
"\"modify error handling\" in Rust, \"optional argument\" and \"optional "
"chaining\" in TypeScript (the latter meaning has also been proposed for "
"Python by PEP 505).  An as yet unnamed PEP proposes it to mark optional "
"types, e.g. ``int?``."
msgstr ""

#: ../../pep-0635.rst:796
msgid ""
"Another common use of ``?`` in programming systems is \"help\", for "
"example, in IPython and Jupyter Notebooks and many interactive command-"
"line utilities."
msgstr ""

#: ../../pep-0635.rst:800
msgid ""
"In addition, this would put Python in a rather unique position: The "
"underscore is as a wildcard pattern in *every* programming language with "
"pattern matching that we could find (including *C#*, *Elixir*, *Erlang*, "
"*F#*, *Grace*, *Haskell*, *Mathematica*, *OCaml*, *Ruby*, *Rust*, "
"*Scala*, *Swift*, and *Thorn*). Keeping in mind that many users of Python"
" also work with other programming languages, have prior experience when "
"learning Python, and may move on to other languages after having learned "
"Python, we find that such well-established standards are important and "
"relevant with respect to readability and learnability.  In our view, "
"concerns that this wildcard means that a regular name received special "
"treatment are not strong enough to introduce syntax that would make "
"Python special."
msgstr ""

#: ../../pep-0635.rst:813
msgid ""
"*Else blocks.*  A case block without a guard whose pattern is a single "
"wildcard (i.e., ``case _:``) accepts any subject without binding it to a "
"variable or performing any other operation.  It is thus semantically "
"equivalent to ``else:``, if it were supported.  However, adding such an "
"else block to the match statement syntax would not remove the need for "
"the wildcard pattern in other contexts.  Another argument against this is"
" that there would be two plausible indentation levels for an else block: "
"aligned with ``case`` or aligned with ``match``.  The authors have found "
"it quite contentious which indentation level to prefer."
msgstr ""

#: ../../pep-0635.rst:824
msgid "**Example** using the Wildcard pattern::"
msgstr ""

#: ../../pep-0635.rst:839
msgid "Value Patterns"
msgstr ""

#: ../../pep-0635.rst:841
msgid ""
"It is good programming style to use named constants for parametric values"
" or to clarify the meaning of particular values.  Clearly, it would be "
"preferable to write ``case (HttpStatus.OK, body):`` over ``case (200, "
"body):``, for example.  The main issue that arises here is how to "
"distinguish capture patterns (variable bindings) from value patterns.  "
"The general discussion surrounding this issue has brought forward a "
"plethora of options, which we cannot all fully list here."
msgstr ""

#: ../../pep-0635.rst:849
msgid ""
"Strictly speaking, value patterns are not really necessary, but could be "
"implemented using guards, i.e. ``case (status, body) if status == "
"HttpStatus.OK:``.  Nonetheless, the convenience of value patterns is "
"unquestioned and obvious."
msgstr ""

#: ../../pep-0635.rst:854
msgid ""
"The observation that constants tend to be written in uppercase letters or"
" collected in enumeration-like namespaces suggests possible rules to "
"discern constants syntactically.  However, the idea of using upper- vs. "
"lowercase as a marker has been met with scepticism since there is no "
"similar precedence in core Python (although it is common in other "
"languages).  We therefore only adopted the rule that any dotted name "
"(i.e., attribute access) is to be interpreted as a value pattern, for "
"example ``HttpStatus.OK`` above.  This precludes, in particular, local "
"variables and global variables defined in the current module from acting "
"as constants."
msgstr ""

#: ../../pep-0635.rst:864
msgid ""
"A proposed rule to use a leading dot (e.g. ``.CONSTANT``) for that "
"purpose was criticised because it was felt that the dot would not be a "
"visible-enough marker for that purpose.  Partly inspired by forms found "
"in other programming languages, a number of different markers/sigils were"
" proposed (such as ``^CONSTANT``, ``$CONSTANT``, ``==CONSTANT``, "
"``CONSTANT?``, or the word enclosed in backticks), although there was no "
"obvious or natural choice.  The current proposal therefore leaves the "
"discussion and possible introduction of such a 'constant' marker for a "
"future PEP."
msgstr ""

#: ../../pep-0635.rst:874
msgid ""
"Distinguishing the semantics of names based on whether it is a global "
"variable (i.e. the compiler would treat global variables as constants "
"rather than capture patterns) leads to various issues.  The addition or "
"alteration of a global variable in the module could have unintended side "
"effects on patterns.  Moreover, pattern matching could not be used "
"directly inside a module's scope because all variables would be global, "
"making capture patterns impossible."
msgstr ""

#: ../../pep-0635.rst:882
msgid "**Example** using the Value pattern::"
msgstr ""

#: ../../pep-0635.rst:898
msgid "Group Patterns"
msgstr ""

#: ../../pep-0635.rst:900
msgid ""
"Allowing users to explicitly specify the grouping is particularly helpful"
" in case of OR patterns."
msgstr ""

#: ../../pep-0635.rst:907
msgid "Sequence Patterns"
msgstr ""

#: ../../pep-0635.rst:909
msgid ""
"Sequence patterns follow as closely as possible the already established "
"syntax and semantics of iterable unpacking.  Of course, subpatterns take "
"the place of assignment targets (variables, attributes and subscript). "
"Moreover, the sequence pattern only matches a carefully selected set of "
"possible subjects, whereas iterable unpacking can be applied to any "
"iterable."
msgstr ""

#: ../../pep-0635.rst:916
msgid ""
"As in iterable unpacking, we do not distinguish between 'tuple' and "
"'list' notation.  ``[a, b, c]``, ``(a, b, c)`` and ``a, b, c`` are all "
"equivalent.  While this means we have a redundant notation and checking "
"specifically for lists or tuples requires more effort (e.g. ``case "
"list([a, b, c])``), we mimic iterable unpacking as much as possible."
msgstr ""

#: ../../pep-0635.rst:923
msgid ""
"A starred pattern will capture a sub-sequence of arbitrary length, again "
"mirroring iterable unpacking.  Only one starred item may be present in "
"any sequence pattern.  In theory, patterns such as ``(*_, 3, *_)`` could "
"be understood as expressing any sequence containing the value ``3``. In "
"practice, however, this would only work for a very narrow set of use "
"cases and lead to inefficient backtracking or even ambiguities otherwise."
msgstr ""

#: ../../pep-0635.rst:930
msgid ""
"The sequence pattern does *not* iterate through an iterable subject.  All"
" elements are accessed through subscripting and slicing, and the subject "
"must be an instance of ``collections.abc.Sequence``.  This includes, of "
"course, lists and tuples, but excludes e.g. sets and dictionaries.  While"
" it would include strings and bytes, we make an exception for these (see "
"below)."
msgstr ""

#: ../../pep-0635.rst:936
msgid ""
"A sequence pattern cannot just iterate through any iterable object.  The "
"consumption of elements from the iteration would have to be undone if the"
" overall pattern fails, which is not feasible."
msgstr ""

#: ../../pep-0635.rst:940
msgid ""
"To identify sequences we cannot rely on ``len()`` and subscripting and "
"slicing alone, because sequences share these protocols with mappings "
"(e.g. ``dict``) in this regard.  It would be surprising if a sequence "
"pattern also matched a dictionaries or other objects implementing the "
"mapping protocol (i.e. ``__getitem__``).  The interpreter therefore "
"performs an instance check to ensure that the subject in question really "
"is a sequence (of known type).  (As an optimization of the most common "
"case, if the subject is exactly a list or a tuple, the instance check can"
" be skipped.)"
msgstr ""

#: ../../pep-0635.rst:950
msgid ""
"String and bytes objects have a dual nature: they are both 'atomic' "
"objects in their own right, as well as sequences (with a strongly "
"recursive nature in that a string is a sequence of strings).  The typical"
" behavior and use cases for strings and bytes are different enough from "
"those of tuples and lists to warrant a clear distinction.  It is in fact "
"often unintuitive and unintended that strings pass for sequences, as "
"evidenced by regular questions and complaints.  Strings and bytes are "
"therefore not matched by a sequence pattern, limiting the sequence "
"pattern to a very specific understanding of 'sequence'.  The built-in "
"``bytearray`` type, being a mutable version of ``bytes``, also deserves "
"an exception; but we don't intend to enumerate all other types that may "
"be used to represent bytes (e.g. some, but not all, instances of "
"``memoryview`` and ``array.array``)."
msgstr ""

#: ../../pep-0635.rst:967
msgid "Mapping Patterns"
msgstr ""

#: ../../pep-0635.rst:969
msgid ""
"Dictionaries or mappings in general are one of the most important and "
"most widely used data structures in Python.  In contrast to sequences, "
"mappings are built for fast direct access to arbitrary elements "
"identified by a key. In most cases an element is retrieved from a "
"dictionary by a known key without regard for any ordering or other key-"
"value pairs stored in the same dictionary.  Particularly common are "
"string keys."
msgstr ""

#: ../../pep-0635.rst:976
msgid ""
"The mapping pattern reflects the common usage of dictionary lookup: it "
"allows the user to extract some values from a mapping by means of "
"constant/known keys and have the values match given subpatterns. Extra "
"keys in the subject are ignored even if ``**rest`` is not present. This "
"is different from sequence patterns, where extra items will cause a match"
" to fail.  But mappings are actually different from sequences: they have "
"natural structural sub-typing behavior, i.e., passing a dictionary with "
"extra keys somewhere will likely just work. Should it be necessary to "
"impose an upper bound on the mapping and ensure that no additional keys "
"are present, then the usual double-star-pattern ``**rest`` can be used.  "
"The special case ``**_`` with a wildcard, however, is not supported as it"
" would not have any effect, but might lead to an incorrect understanding "
"of the mapping pattern's semantics."
msgstr ""

#: ../../pep-0635.rst:991
msgid ""
"To avoid overly expensive matching algorithms, keys must be literals or "
"value patterns."
msgstr ""

#: ../../pep-0635.rst:994
msgid ""
"There is a subtle reason for using ``get(key, default)`` instead of "
"``__getitem__(key)`` followed by a check for ``AttributeError``: if the "
"subject happens to be a ``defaultdict``, calling ``__getitem__`` for a "
"non-existent key would add the key.  Using ``get()`` avoids this "
"unexpected side effect."
msgstr ""

#: ../../pep-0635.rst:1000
msgid "**Example** using the Mapping pattern::"
msgstr ""

#: ../../pep-0635.rst:1014
msgid "Class Patterns"
msgstr ""

#: ../../pep-0635.rst:1016
msgid ""
"Class patterns fulfill two purposes: checking whether a given subject is "
"indeed an instance of a specific class, and extracting data from specific"
" attributes of the subject.  Anecdotal evidence revealed that "
"``isinstance()`` is one of the most often used functions in Python in "
"terms of static occurrences in programs.  Such instance checks typically "
"precede a subsequent access to information stored in the object, or a "
"possible manipulation thereof.  A typical pattern might be along the "
"lines of::"
msgstr ""

#: ../../pep-0635.rst:1031
msgid ""
"In many cases class patterns occur nested, as in the example given in the"
" motivation::"
msgstr ""

#: ../../pep-0635.rst:1039
msgid ""
"The class pattern lets you concisely specify both an instance check and "
"relevant attributes (with possible further constraints).  It is thereby "
"very tempting to write, e.g., ``case Node(left, right):`` in the first "
"case above and ``case Leaf(value):`` in the second.  While this indeed "
"works well for languages with strict algebraic data types, it is "
"problematic with the structure of Python objects."
msgstr ""

#: ../../pep-0635.rst:1046
msgid ""
"When dealing with general Python objects, we face a potentially very "
"large number of unordered attributes: an instance of ``Node`` contains a "
"large number of attributes (most of which are 'special methods' such as "
"``__repr__``).  Moreover, the interpreter cannot reliably deduce the "
"ordering of attributes.  For an object that represents a circle, say, "
"there is no inherently obvious ordering of the attributes ``x``, ``y`` "
"and ``radius``."
msgstr ""

#: ../../pep-0635.rst:1054
msgid ""
"We envision two possibilities for dealing with this issue: either "
"explicitly name the attributes of interest, or provide an additional "
"mapping that tells the interpreter which attributes to extract and in "
"which order.  Both approaches are supported.  Moreover, explicitly naming"
" the attributes of interest lets you further specify the required "
"structure of an object; if an object lacks an attribute specified by the "
"pattern, the match fails."
msgstr ""

#: ../../pep-0635.rst:1061
msgid ""
"Attributes that are explicitly named pick up the syntax of named "
"arguments. If an object of class ``Node`` has two attributes ``left`` and"
" ``right`` as above, the pattern ``Node(left=x, right=y)`` will extract "
"the values of both attributes and assign them to ``x`` and ``y``, "
"respectively.  The data flow from left to right seems unusual, but is in "
"line with mapping patterns and has precedents such as assignments via "
"``as`` in *with*- or *import*-statements (and indeed AS patterns)."
msgstr ""

#: ../../pep-0635.rst:1069
msgid ""
"Naming the attributes in question explicitly will be mostly used for more"
" complex cases where the positional form (below) is insufficient."
msgstr ""

#: ../../pep-0635.rst:1072
msgid ""
"The class field ``__match_args__`` specifies a number of attributes "
"together with their ordering, allowing class patterns to rely on "
"positional sub-patterns without having to explicitly name the attributes "
"in question. This is particularly handy for smaller objects or instances "
"of data classes, where the attributes of interest are rather obvious and "
"often have a well-defined ordering.  In a way, ``__match_args__`` is "
"similar to the declaration of formal parameters, which allows calling "
"functions with positional arguments rather than naming all the "
"parameters."
msgstr ""

#: ../../pep-0635.rst:1081
msgid ""
"This is a class attribute, because it needs to be looked up on the class "
"named in the class pattern, not on the subject instance."
msgstr ""

#: ../../pep-0635.rst:1085
msgid ""
"The syntax of class patterns is based on the idea that de-construction "
"mirrors the syntax of construction.  This is already the case in "
"virtually any Python construct, be assignment targets, function "
"definitions or iterable unpacking.  In all these cases, we find that the "
"syntax for sending and that for receiving 'data' are virtually identical."
msgstr ""

#: ../../pep-0635.rst:1091
msgid ""
"Assignment targets such as variables, attributes and subscripts: "
"``foo.bar[2] = foo.bar[3]``;"
msgstr ""

#: ../../pep-0635.rst:1094
msgid ""
"Function definitions: a function defined with ``def foo(x, y, z=6)`` is "
"called as, e.g., ``foo(123, y=45)``, where the actual arguments provided "
"at the call site are matched against the formal parameters at the "
"definition site;"
msgstr ""

#: ../../pep-0635.rst:1099
msgid ""
"Iterable unpacking: ``a, b = b, a`` or ``[a, b] = [b, a]`` or ``(a, b) = "
"(b, a)``, just to name a few equivalent possibilities."
msgstr ""

#: ../../pep-0635.rst:1102
msgid ""
"Using the same syntax for reading and writing, l- and r-values, or "
"construction and de-construction is widely accepted for its benefits in "
"thinking about data, its flow and manipulation.  This equally extends to "
"the explicit construction of instances, where class patterns ``C(p, q)`` "
"deliberately mirror the syntax of creating instances."
msgstr ""

#: ../../pep-0635.rst:1108
msgid ""
"The special case for the built-in classes ``bool``, ``bytearray`` etc. "
"(where e.g. ``str(x)`` captures the subject value in ``x``) can be "
"emulated by a user-defined class as follows::"
msgstr ""

#: ../../pep-0635.rst:1117
msgid ""
"**Type annotations for pattern variables.** The proposal was to combine "
"patterns with type annotations::"
msgstr ""

#: ../../pep-0635.rst:1125
msgid ""
"This idea has a lot of problems.  For one, the colon can only be used "
"inside of brackets or parentheses, otherwise the syntax becomes "
"ambiguous.  And because Python disallows ``isinstance()`` checks on "
"generic types, type annotations containing generics will not work as "
"expected."
msgstr ""

#: ../../pep-0635.rst:1133
msgid "History and Context"
msgstr ""

#: ../../pep-0635.rst:1135
msgid ""
"Pattern matching emerged in the late 1970s in the form of tuple unpacking"
" and as a means to handle recursive data structures such as linked lists "
"or trees (object-oriented languages usually use the visitor pattern for "
"handling recursive data structures).  The early proponents of pattern "
"matching organised structured data in 'tagged tuples' rather than "
"``struct`` as in *C* or the objects introduced later.  A node in a binary"
" tree would, for instance, be a tuple with two elements for the left and "
"right branches, respectively, and a ``Node`` tag, written as ``Node(left,"
" right)``.  In Python we would probably put the tag inside the tuple as "
"``('Node', left, right)`` or define a data class ``Node`` to achieve the "
"same effect."
msgstr ""

#: ../../pep-0635.rst:1147
msgid ""
"Using modern syntax, a depth-first tree traversal would then be written "
"as follows::"
msgstr ""

#: ../../pep-0635.rst:1158
msgid ""
"The notion of handling recursive data structures with pattern matching "
"immediately gave rise to the idea of handling more general recursive "
"'patterns' (i.e. recursion beyond recursive data structures) with pattern"
" matching.  Pattern matching would thus also be used to define recursive "
"functions such as::"
msgstr ""

#: ../../pep-0635.rst:1173
msgid ""
"As pattern matching was repeatedly integrated into new and emerging "
"programming languages, its syntax slightly evolved and expanded.  The two"
" first cases in the ``fib`` example above could be written more "
"succinctly as ``case 0 | 1:`` with ``|`` denoting alternative patterns.  "
"Moreover, the underscore ``_`` was widely adopted as a wildcard, a filler"
" where neither the structure nor value of parts of a pattern were of "
"substance.  Since the underscore is already frequently used in equivalent"
" capacity in Python's iterable unpacking (e.g., ``_, _, third, _* = "
"something``) we kept these universal standards."
msgstr ""

#: ../../pep-0635.rst:1183
msgid ""
"It is noteworthy that the concept of pattern matching has always been "
"closely linked to the concept of functions.  The different case clauses "
"have always been considered as something like semi-independent functions "
"where pattern variables take on the role of parameters.  This becomes "
"most apparent when pattern matching is written as an overloaded function,"
" along the lines of (Standard ML)::"
msgstr ""

#: ../../pep-0635.rst:1194
msgid ""
"Even though such a strict separation of case clauses into independent "
"functions does not apply in Python, we find that patterns share many "
"syntactic rules with parameters, such as binding arguments to unqualified"
" names only or that variable/parameter names must not be repeated for a "
"particular pattern/function."
msgstr ""

#: ../../pep-0635.rst:1200
msgid ""
"With its emphasis on abstraction and encapsulation, object-oriented "
"programming posed a serious challenge to pattern matching.  In short: in "
"object-oriented programming, we can no longer view objects as tagged "
"tuples. The arguments passed into the constructor do not necessarily "
"specify the attributes or fields of the objects.  Moreover, there is no "
"longer a strict ordering of an object's fields and some of the fields "
"might be private and thus inaccessible.  And on top of this, the given "
"object might actually be an instance of a subclass with slightly "
"different structure."
msgstr ""

#: ../../pep-0635.rst:1209
msgid ""
"To address this challenge, patterns became increasingly independent of "
"the original tuple constructors.  In a pattern like ``Node(left, "
"right)``, ``Node`` is no longer a passive tag, but rather a function that"
" can actively check for any given object whether it has the right "
"structure and extract a ``left`` and ``right`` field.  In other words: "
"the ``Node``-tag becomes a function that transforms an object into a "
"tuple or returns some failure indicator if it is not possible."
msgstr ""

#: ../../pep-0635.rst:1217
msgid ""
"In Python, we simply use ``isinstance()`` together with the "
"``__match_args__`` field of a class to check whether an object has the "
"correct structure and then transform some of its attributes into a tuple."
"  For the ``Node`` example above, for instance, we would have "
"``__match_args__ = ('left', 'right')`` to indicate that these two "
"attributes should be extracted to form the tuple. That is, ``case Node(x,"
" y)`` would first check whether a given object is an instance of ``Node``"
" and then assign ``left`` to ``x`` and ``right`` to ``y``, respectively."
msgstr ""

#: ../../pep-0635.rst:1226
msgid ""
"Paying tribute to Python's dynamic nature with 'duck typing', however, we"
" also added a more direct way to specify the presence of, or constraints "
"on specific attributes.  Instead of ``Node(x, y)`` you could also write "
"``object(left=x, right=y)``, effectively eliminating the ``isinstance()``"
" check and thus supporting any object with ``left`` and ``right`` "
"attributes. Or you would combine these ideas to write ``Node(right=y)`` "
"so as to require an instance of ``Node`` but only extract the value of "
"the ``right`` attribute."
msgstr ""

#: ../../pep-0635.rst:1236
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0635.rst:1238
msgid ""
"Through its use of \"soft keywords\" and the new PEG parser (PEP 617), "
"the proposal remains fully backwards compatible.  However, 3rd party "
"tooling that uses a LL(1) parser to parse Python source code may be "
"forced to switch parser technology to be able to support those same "
"features."
msgstr ""

#: ../../pep-0635.rst:1246
msgid "Security Implications"
msgstr ""

#: ../../pep-0635.rst:1248
msgid "We do not expect any security implications from this language feature."
msgstr ""

#: ../../pep-0635.rst:1252
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0635.rst:1254
msgid ""
"A `feature-complete CPython implementation "
"<https://github.com/brandtbucher/cpython/tree/patma>`_ is available on "
"GitHub."
msgstr ""

#: ../../pep-0635.rst:1258
msgid ""
"An `interactive playground "
"<https://mybinder.org/v2/gh/gvanrossum/patma/master?urlpath=lab/tree/playground-622.ipynb>`_"
" based on the above implementation was created using Binder [2]_ and "
"Jupyter [3]_."
msgstr ""

#: ../../pep-0635.rst:1264
msgid "References"
msgstr ""

#: ../../pep-0635.rst:1266
msgid ""
"Kohn et al., Dynamic Pattern Matching with Python "
"https://gvanrossum.github.io/docs/PyPatternMatching.pdf"
msgstr ""

#: ../../pep-0635.rst:1269
msgid "Binder https://mybinder.org"
msgstr ""

#: ../../pep-0635.rst:1272
msgid "Jupyter https://jupyter.org"
msgstr ""

#: ../../pep-0635.rst:1277
msgid "Copyright"
msgstr ""

#: ../../pep-0635.rst:1279
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

