# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0556.rst
msgid "PEP"
msgstr ""

#: ../../pep-0556.rst:1
msgid "556"
msgstr ""

#: ../../pep-0556.rst
msgid "Title"
msgstr ""

#: ../../pep-0556.rst:2
msgid "Threaded garbage collection"
msgstr ""

#: ../../pep-0556.rst
msgid "Author"
msgstr ""

#: ../../pep-0556.rst:3
msgid "Antoine Pitrou <solipsis@pitrou.net>"
msgstr ""

#: ../../pep-0556.rst
msgid "Status"
msgstr ""

#: ../../pep-0556.rst:4
msgid "Deferred"
msgstr ""

#: ../../pep-0556.rst
msgid "Type"
msgstr ""

#: ../../pep-0556.rst:5
msgid "Standards Track"
msgstr ""

#: ../../pep-0556.rst
msgid "Created"
msgstr ""

#: ../../pep-0556.rst:7
msgid "08-Sep-2017"
msgstr ""

#: ../../pep-0556.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0556.rst:8
msgid "3.7"
msgstr ""

#: ../../pep-0556.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0556.rst:9
msgid "2017-09-08"
msgstr ""

#: ../../pep-0556.rst:13
msgid "Deferral Notice"
msgstr ""

#: ../../pep-0556.rst:15
msgid ""
"This PEP is currently not being actively worked on.  It may be revived in"
" the future.  The main missing steps are:"
msgstr ""

#: ../../pep-0556.rst:18
msgid "polish the implementation, adapting the test suite where necessary;"
msgstr ""

#: ../../pep-0556.rst:20
msgid ""
"ensure setting threaded garbage collection does not disrupt existing code"
" in unexpected ways (expected impact includes lengthening the lifetime of"
" objects in reference cycles)."
msgstr ""

#: ../../pep-0556.rst:26
msgid "Abstract"
msgstr ""

#: ../../pep-0556.rst:28
msgid ""
"This PEP proposes a new optional mode of operation for CPython's cyclic "
"garbage collector (GC) where implicit (i.e. opportunistic) collections "
"happen in a dedicated thread rather than synchronously."
msgstr ""

#: ../../pep-0556.rst:34
msgid "Terminology"
msgstr ""

#: ../../pep-0556.rst:36
msgid ""
"An \"implicit\" GC run (or \"implicit\" collection) is one that is "
"triggered opportunistically based on a certain heuristic computed over "
"allocation statistics, whenever a new allocation is requested.  Details "
"of the heuristic are not relevant to this PEP, as it does not propose to "
"change it."
msgstr ""

#: ../../pep-0556.rst:41
msgid ""
"An \"explicit\" GC run (or \"explicit\" collection) is one that is "
"requested programmatically by an API call such as ``gc.collect``."
msgstr ""

#: ../../pep-0556.rst:44
msgid ""
"\"Threaded\" refers to the fact that GC runs happen in a dedicated thread"
" separate from sequential execution of application code.  It does not "
"mean \"concurrent\" (the Global Interpreter Lock, or GIL, still "
"serializes execution among Python threads *including* the dedicated GC "
"thread) nor \"parallel\" (the GC is not able to distribute its work onto "
"several threads at once to lower wall-clock latencies of GC runs)."
msgstr ""

#: ../../pep-0556.rst:53
msgid "Rationale"
msgstr ""

#: ../../pep-0556.rst:55
msgid ""
"The mode of operation for the GC has always been to perform implicit "
"collections synchronously.  That is, whenever the aforementioned "
"heuristic is activated, execution of application code in the current "
"thread is suspended and the GC is launched in order to reclaim dead "
"reference cycles."
msgstr ""

#: ../../pep-0556.rst:61
msgid ""
"There is a catch, though.  Over the course of reclaiming dead reference "
"cycles (and any ancillary objects hanging at those cycles), the GC can "
"execute arbitrary finalization code in the form of ``__del__`` methods "
"and ``weakref`` callbacks.  Over the years, Python has been used for more"
" and more sophisticated purposes, and it is increasingly common for "
"finalization code to perform complex tasks, for example in distributed "
"systems where loss of an object may require notifying other (logical or "
"physical) nodes."
msgstr ""

#: ../../pep-0556.rst:70
msgid ""
"Interrupting application code at arbitrary points to execute finalization"
" code that may rely on a consistent internal state and/or on acquiring "
"synchronization primitives gives rise to reentrancy issues that even the "
"most seasoned experts have trouble fixing properly [#queue-reentrancy-"
"bug]_."
msgstr ""

#: ../../pep-0556.rst:75
msgid ""
"This PEP bases itself on the observation that, despite the apparent "
"similarities, same-thread reentrancy is a fundamentally harder problem "
"than multi-thread synchronization.  Instead of letting each developer or "
"library author struggle with extremely hard reentrancy issues, one by "
"one, this PEP proposes to allow the GC to run in a separate thread where "
"well-known multi-thread synchronization practices are sufficient."
msgstr ""

#: ../../pep-0556.rst:85
msgid "Proposal"
msgstr ""

#: ../../pep-0556.rst:87
msgid "Under this PEP, the GC has two modes of operation:"
msgstr ""

#: ../../pep-0556.rst:89
msgid ""
"\"serial\", which is the default and legacy mode, where an implicit GC "
"run is performed immediately in the thread that detects such an implicit "
"run is desired (based on the aforementioned allocation heuristic)."
msgstr ""

#: ../../pep-0556.rst:93
msgid ""
"\"threaded\", which can be explicitly enabled at runtime on a per-process"
" basis, where implicit GC runs are *scheduled* whenever the allocation "
"heuristic is triggered, but run in a dedicated background thread."
msgstr ""

#: ../../pep-0556.rst:97
msgid ""
"Hard reentrancy problems which plague sophisticated uses of finalization "
"callbacks in the \"serial\" mode become relatively easy multi-thread "
"synchronization problems in the \"threaded\" mode of operation."
msgstr ""

#: ../../pep-0556.rst:101
msgid ""
"The GC also traditionally allows for explicit GC runs, using the Python "
"API ``gc.collect`` and the C API ``PyGC_Collect``.  The visible semantics"
" of these two APIs are left unchanged: they perform a GC run immediately "
"when called, and only return when the GC run is finished."
msgstr ""

#: ../../pep-0556.rst:108
msgid "New public APIs"
msgstr ""

#: ../../pep-0556.rst:110
msgid "Two new Python APIs are added to the ``gc`` module:"
msgstr ""

#: ../../pep-0556.rst:112
msgid ""
"``gc.set_mode(mode)`` sets the current mode of operation (either "
"\"serial\" or \"threaded\").  If setting to \"serial\" and the current "
"mode is \"threaded\", then the function also waits for the GC thread to "
"end."
msgstr ""

#: ../../pep-0556.rst:116
msgid "``gc.get_mode()`` returns the current mode of operation."
msgstr ""

#: ../../pep-0556.rst:118
msgid "It is allowed to switch back and forth between modes of operation."
msgstr ""

#: ../../pep-0556.rst:122
msgid "Intended use"
msgstr ""

#: ../../pep-0556.rst:124
msgid ""
"Given the per-process nature of the switch and its repercussions on "
"semantics of all finalization callbacks, it is recommended that it is set"
" at the beginning of an application's code (and/or in initializers for "
"child processes e.g. when using ``multiprocessing``).  Library functions "
"should probably not mess with this setting, just as they shouldn't call "
"``gc.enable`` or ``gc.disable``, but there's nothing to prevent them from"
" doing so."
msgstr ""

#: ../../pep-0556.rst:134
msgid "Non-goals"
msgstr ""

#: ../../pep-0556.rst:136
msgid ""
"This PEP does not address reentrancy issues with other kinds of "
"asynchronous code execution (for example signal handlers registered with "
"the ``signal`` module).  The author believes that the overwhelming "
"majority of painful reentrancy issues occur with finalizers.  Most of the"
" time, signal handlers are able to set a single flag and/or wake up a "
"file descriptor for the main program to notice.  As for those signal "
"handlers which raise an exception, they *have* to execute in-thread."
msgstr ""

#: ../../pep-0556.rst:144
msgid ""
"This PEP also does not change the execution of finalization callbacks "
"when they are called as part of regular reference counting, i.e. when "
"releasing a visible reference drops an object's reference count to zero. "
"Since such execution happens at deterministic points in code, it is "
"usually not a problem."
msgstr ""

#: ../../pep-0556.rst:152
msgid "Internal details"
msgstr ""

#: ../../pep-0556.rst:154
msgid "TODO: Update this section to conform to the current implementation."
msgstr ""

#: ../../pep-0556.rst:157
msgid "``gc`` module"
msgstr ""

#: ../../pep-0556.rst:159
msgid ""
"An internal flag ``gc_is_threaded`` is added, telling whether GC is "
"serial or threaded."
msgstr ""

#: ../../pep-0556.rst:162
msgid "An internal structure ``gc_mutex`` is added to avoid two GC runs at once:"
msgstr ""

#: ../../pep-0556.rst:172
msgid ""
"An internal structure ``gc_thread`` is added to handle synchronization "
"with the GC thread:"
msgstr ""

#: ../../pep-0556.rst:187
msgid "``threading`` module"
msgstr ""

#: ../../pep-0556.rst:189
msgid "Two private functions are added to the ``threading`` module:"
msgstr ""

#: ../../pep-0556.rst:191
msgid ""
"``threading._ensure_dummy_thread(name)`` creates and registers a "
"``Thread`` instance for the current thread with the given *name*, and "
"returns it."
msgstr ""

#: ../../pep-0556.rst:194
msgid ""
"``threading._remove_dummy_thread(thread)`` removes the given *thread* (as"
" returned by ``_ensure_dummy_thread``) from the threading module's "
"internal state."
msgstr ""

#: ../../pep-0556.rst:198
msgid ""
"The purpose of these two functions is to improve debugging and "
"introspection by letting ``threading.current_thread()`` return a more "
"meaningfully-named object when called inside a finalization callback in "
"the GC thread."
msgstr ""

#: ../../pep-0556.rst:204
msgid "Pseudo-code"
msgstr ""

#: ../../pep-0556.rst:206
msgid ""
"Here is a proposed pseudo-code for the main primitives, public and "
"internal, required for implementing this PEP.  All of them will be "
"implemented in C and live inside the ``gc`` module, unless otherwise "
"noted:"
msgstr ""

#: ../../pep-0556.rst:342
msgid "Discussion"
msgstr ""

#: ../../pep-0556.rst:345
msgid "Default mode"
msgstr ""

#: ../../pep-0556.rst:347
msgid ""
"One may wonder whether the default mode should simply be changed to "
"\"threaded\". For multi-threaded applications, it would probably not be a"
" problem: those applications must already be prepared for finalization "
"handlers to be run in arbitrary threads.  In single-thread applications, "
"however, it is currently guaranteed that finalizers will always be called"
" in the main thread.  Breaking this property may induce subtle behaviour "
"changes or bugs, for example if finalizers rely on some thread-local "
"values."
msgstr ""

#: ../../pep-0556.rst:355
msgid ""
"Another problem is when a program uses ``fork()`` for concurrency. "
"Calling ``fork()`` from a single-threaded program is safe, but it's "
"fragile (to say the least) if the program is multi-threaded."
msgstr ""

#: ../../pep-0556.rst:360
msgid "Explicit collections"
msgstr ""

#: ../../pep-0556.rst:362
msgid ""
"One may ask whether explicit collections should also be delegated to the "
"background thread.  The answer is it doesn't really matter: since "
"``gc.collect`` and ``PyGC_Collect`` actually *wait* for the collection to"
" end (breaking this property would break compatibility), delegating the "
"actual work to a background thread wouldn't ease synchronization with the"
" thread requesting an explicit collection."
msgstr ""

#: ../../pep-0556.rst:369
msgid ""
"In the end, this PEP choses the behaviour that seems simpler to implement"
" based on the pseudo-code above."
msgstr ""

#: ../../pep-0556.rst:373
msgid "Impact on memory use"
msgstr ""

#: ../../pep-0556.rst:375
msgid ""
"The \"threaded\" mode incurs a slight delay in implicit collections "
"compared to the default \"serial\" mode.  This obviously may change the "
"memory profile of certain applications.  By how much remains to be "
"measured in real-world use, but we expect the impact to remain minor and "
"bearable.  First because implicit collections are based on a *heuristic* "
"whose effect does not result in deterministic visible behaviour anyway.  "
"Second because the GC deals with reference cycles while many objects are "
"reclaimed immediately when their last visible reference disappears."
msgstr ""

#: ../../pep-0556.rst:385
msgid "Impact on CPU consumption"
msgstr ""

#: ../../pep-0556.rst:387
msgid ""
"The pseudo-code above adds two lock operations for each implicit "
"collection request in \"threaded\" mode: one in the thread making the "
"request (a ``release`` call) and one in the GC thread (an ``acquire`` "
"call). It also adds two other lock operations, regardless of the current "
"mode, around each actual collection."
msgstr ""

#: ../../pep-0556.rst:393
msgid ""
"We expect the cost of those lock operations to be very small, on modern "
"systems, compared to the actual cost of crawling through the chains of "
"pointers during the collection itself (\"pointer chasing\" being one of "
"the hardest workloads on modern CPUs, as it lends itself poorly to "
"speculation and superscalar execution)."
msgstr ""

#: ../../pep-0556.rst:399
msgid ""
"Actual measurements on worst-case mini-benchmarks may help provide "
"reassuring upper bounds."
msgstr ""

#: ../../pep-0556.rst:403
msgid "Impact on GC pauses"
msgstr ""

#: ../../pep-0556.rst:405
msgid ""
"While this PEP does not concern itself with GC pauses, there is a "
"practical chance that releasing the GIL at some point during an implicit "
"collection (for example by virtue of executing a pure Python finalizer) "
"will allow application code to run in-between, lowering the *visible* GC "
"pause time for some applications."
msgstr ""

#: ../../pep-0556.rst:411
msgid ""
"If this PEP is accepted, future work may try to better realize this "
"potential by speculatively releasing the GIL during collections, though "
"it is unclear how doable that is."
msgstr ""

#: ../../pep-0556.rst:417
msgid "Open issues"
msgstr ""

#: ../../pep-0556.rst:419
msgid ""
"``gc.set_mode`` should probably be protected against multiple concurrent "
"invocations.  Also, it should raise when called from *inside* a GC run "
"(i.e. from a finalizer)."
msgstr ""

#: ../../pep-0556.rst:423
msgid ""
"What happens at shutdown?  Does the GC thread run until ``_PyGC_Fini()`` "
"is called?"
msgstr ""

#: ../../pep-0556.rst:428
msgid "Implementation"
msgstr ""

#: ../../pep-0556.rst:430
msgid ""
"A draft implementation is available in the ``threaded_gc`` branch "
"[#implementation-branch]_ of the author's Github fork [#cpython-pitrou-"
"fork]_."
msgstr ""

#: ../../pep-0556.rst:435
msgid "References"
msgstr ""

#: ../../pep-0556.rst:437
msgid "https://bugs.python.org/issue14976"
msgstr ""

#: ../../pep-0556.rst:439
msgid "https://github.com/pitrou/cpython/tree/threaded_gc"
msgstr ""

#: ../../pep-0556.rst:441
msgid "https://github.com/pitrou/cpython/"
msgstr ""

#: ../../pep-0556.rst:445
msgid "Copyright"
msgstr ""

#: ../../pep-0556.rst:447
msgid "This document has been placed in the public domain."
msgstr ""

