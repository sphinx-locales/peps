# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0637.rst
msgid "PEP"
msgstr ""

#: ../../pep-0637.rst:1
msgid "637"
msgstr ""

#: ../../pep-0637.rst
msgid "Title"
msgstr ""

#: ../../pep-0637.rst:2
msgid "Support for indexing with keyword arguments"
msgstr ""

#: ../../pep-0637.rst
msgid "Author"
msgstr ""

#: ../../pep-0637.rst:5
msgid "Stefano Borini"
msgstr ""

#: ../../pep-0637.rst
msgid "Sponsor"
msgstr ""

#: ../../pep-0637.rst:6
msgid "Steven D'Aprano"
msgstr ""

#: ../../pep-0637.rst
msgid "Discussions-To"
msgstr ""

#: ../../pep-0637.rst:7
msgid "python-ideas@python.org"
msgstr ""

#: ../../pep-0637.rst
msgid "Status"
msgstr ""

#: ../../pep-0637.rst:8
msgid "Rejected"
msgstr ""

#: ../../pep-0637.rst
msgid "Type"
msgstr ""

#: ../../pep-0637.rst:9
msgid "Standards Track"
msgstr ""

#: ../../pep-0637.rst
msgid "Created"
msgstr ""

#: ../../pep-0637.rst:11
msgid "24-Aug-2020"
msgstr ""

#: ../../pep-0637.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0637.rst:12
msgid "3.10"
msgstr ""

#: ../../pep-0637.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0637.rst:13
msgid "23-Sep-2020"
msgstr ""

#: ../../pep-0637.rst
msgid "Resolution"
msgstr ""

#: ../../pep-0637.rst:14
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/thread/6TAQ2BEVSJNV4JM2RJYSSYFJUT3INGZD/"
msgstr ""

#: ../../pep-0637.rst:18
msgid ""
"This PEP has been rejected. In general, the cost of introducing new "
"syntax was not outweighed by the perceived benefits. See the link in the "
"Resolution header field for details."
msgstr ""

#: ../../pep-0637.rst:23
msgid "Abstract"
msgstr ""

#: ../../pep-0637.rst:25
msgid ""
"At present keyword arguments are allowed in function calls, but not in "
"item access. This PEP proposes that Python be extended to allow keyword "
"arguments in item access."
msgstr ""

#: ../../pep-0637.rst:29
msgid ""
"The following example shows keyword arguments for ordinary function "
"calls::"
msgstr ""

#: ../../pep-0637.rst:33
msgid ""
"The proposal would extend the syntax to allow a similar construct to "
"indexing operations::"
msgstr ""

#: ../../pep-0637.rst:40
msgid ""
"and would also provide appropriate semantics. Single- and double-star "
"unpacking of arguments is also provided::"
msgstr ""

#: ../../pep-0637.rst:45
msgid ""
"This PEP is a successor to PEP 472, which was rejected due to lack of "
"interest in 2019. Since then there's been renewed interest in the "
"feature."
msgstr ""

#: ../../pep-0637.rst:49
msgid "Overview"
msgstr ""

#: ../../pep-0637.rst:52
msgid "Background"
msgstr ""

#: ../../pep-0637.rst:54
msgid ""
"PEP 472 was opened in 2014. The PEP detailed various use cases and was "
"created by extracting implementation strategies from a broad discussion "
"on the python-ideas mailing list, although no clear consensus was reached"
" on which strategy should be used.  Many corner cases have been examined "
"more closely and felt awkward, backward incompatible or both."
msgstr ""

#: ../../pep-0637.rst:60
msgid ""
"The PEP was eventually rejected in 2019 [#rejection]_ mostly due to lack "
"of interest for the feature despite its 5 years of existence."
msgstr ""

#: ../../pep-0637.rst:63
msgid ""
"However, with the introduction of type hints in PEP 484 [#pep-0484]_ the "
"square bracket notation has been used consistently to enrich the typing "
"annotations, e.g. to specify a list of integers as Sequence[int]. "
"Additionally, there has been an expanded growth of packages for data "
"analysis such as pandas and xarray, which use names to describe columns "
"in a table (pandas) or axis in an nd-array (xarray). These packages allow"
" users to access specific data by names, but cannot currently use index "
"notation ([]) for this functionality."
msgstr ""

#: ../../pep-0637.rst:71
msgid ""
"As a result, a renewed interest in a more flexible syntax that would "
"allow for named information has been expressed occasionally in many "
"different threads on python-ideas, recently by Caleb Donovick "
"[#request-1]_ in 2019 and Andras Tantos [#request-2]_ in 2020. These "
"requests prompted a strong activity on the python-ideas mailing list, "
"where the various options have been re-discussed and a general consensus "
"on an implementation strategy has now been reached."
msgstr ""

#: ../../pep-0637.rst:79
msgid "Use cases"
msgstr ""

#: ../../pep-0637.rst:81
msgid ""
"The following practical use cases present different cases where a keyword"
" specification would improve notation and provide additional value:"
msgstr ""

#: ../../pep-0637.rst:84
msgid ""
"To provide a more communicative meaning to the index, preventing e.g. "
"accidental inversion of indexes::"
msgstr ""

#: ../../pep-0637.rst:91
msgid ""
"To enrich the typing notation with keywords, especially during the use of"
" generics::"
msgstr ""

#: ../../pep-0637.rst:95
msgid ""
"In some domain, such as computational physics and chemistry, the use of a"
" notation such as ``Basis[Z=5]`` is a Domain Specific Language notation "
"to represent a level of accuracy::"
msgstr ""

#: ../../pep-0637.rst:101
msgid "Pandas currently uses a notation such as::"
msgstr ""

#: ../../pep-0637.rst:105
msgid "which could be replaced with ``df[x=1]``."
msgstr ""

#: ../../pep-0637.rst:107
msgid ""
"xarray has named dimensions. Currently these are handled with functions "
".isel::"
msgstr ""

#: ../../pep-0637.rst:111
msgid ""
"which could also be replaced with ``data[row=10]``. A more complex "
"example::"
msgstr ""

#: ../../pep-0637.rst:118
msgid "Another example::"
msgstr ""

#: ../../pep-0637.rst:130
msgid ""
"Functions/methods whose argument is another function (plus its arguments)"
" need some way to determine which arguments are destined for the target "
"function, and which are used to configure how they run the target. This "
"is simple (if non-extensible) for positional parameters, but we need some"
" way to distinguish these for keywords. [#trio-run]_"
msgstr ""

#: ../../pep-0637.rst:136
msgid ""
"An indexed notation would afford a Pythonic way to pass keyword arguments"
" to these functions without cluttering the caller's code."
msgstr ""

#: ../../pep-0637.rst:163
msgid ""
"Availability of star arguments would benefit PEP-646 Variadic Generics "
"[#pep-0646]_, especially in the forms ``a[*x]`` and ``a[*x, *y, p, q, "
"*z]``. The PEP details exactly this notation in its \"Unpacking: Star "
"Operator\" section."
msgstr ""

#: ../../pep-0637.rst:167
msgid ""
"It is important to note that how the notation is interpreted is up to the"
" implementation. This PEP only defines and dictates the behavior of "
"Python regarding passed keyword arguments, not how these arguments should"
" be interpreted and used by the implementing class."
msgstr ""

#: ../../pep-0637.rst:173
msgid "Current status of indexing operation"
msgstr ""

#: ../../pep-0637.rst:175
msgid ""
"Before detailing the new syntax and semantics to the indexing notation, "
"it is relevant to analyse how the indexing notation works today, in which"
" contexts, and how it is different from a function call."
msgstr ""

#: ../../pep-0637.rst:179
msgid ""
"Subscripting ``obj[x]`` is, effectively, an alternate and specialised "
"form of function call syntax with a number of differences and "
"restrictions compared to ``obj(x)``. The current Python syntax focuses "
"exclusively on position to express the index, and also contains syntactic"
" sugar to refer to non-punctiform selection (slices). Some common "
"examples::"
msgstr ""

#: ../../pep-0637.rst:189
msgid ""
"This translates into a ``__(get|set|del)item__`` dunder call which is "
"passed a single parameter containing the index (for ``__getitem__`` and "
"``__delitem__``) or two parameters containing index and value (for "
"``__setitem__``)."
msgstr ""

#: ../../pep-0637.rst:193
msgid ""
"The behavior of the indexing call is fundamentally different from a "
"function call in various aspects:"
msgstr ""

#: ../../pep-0637.rst:196
msgid ""
"The first difference is in meaning to the reader.  A function call says "
"\"arbitrary function call potentially with side-effects\". An indexing "
"operation says \"lookup\", typically to point at a subset or specific "
"sub-aspect of an entity (as in the case of typing notation).  This "
"fundamental difference means that, while we cannot prevent abuse, "
"implementors should be aware that the introduction of keyword arguments "
"to alter the behavior of the lookup may violate this intrinsic meaning."
msgstr ""

#: ../../pep-0637.rst:204
msgid ""
"The second difference of the indexing notation compared to a function is "
"that indexing can be used for both getting and setting operations. In "
"Python, a function cannot be on the left hand side of an assignment. In "
"other words, both of these are valid::"
msgstr ""

#: ../../pep-0637.rst:212
msgid "but only the first one of these is valid::"
msgstr ""

#: ../../pep-0637.rst:217
msgid ""
"This asymmetry is important, and makes one understand that there is a "
"natural imbalance between the two forms. It is therefore not a given that"
" the two should behave transparently and symmetrically."
msgstr ""

#: ../../pep-0637.rst:221
msgid ""
"The third difference is that functions have names assigned to their "
"arguments, unless the passed parameters are captured with ``*args``, in "
"which case they end up as entries in the args tuple. In other words, "
"functions already have anonymous argument semantic, exactly like the "
"indexing operation. However, ``__(get|set|del)item__`` is not always "
"receiving a tuple as the ``index`` argument (to be uniform in behavior "
"with ``*args``).  In fact, given a trivial class::"
msgstr ""

#: ../../pep-0637.rst:232
msgid ""
"The index operation basically forwards the content of the square brackets"
" \"as is\" in the ``index`` argument::"
msgstr ""

#: ../../pep-0637.rst:252
msgid ""
"The fourth difference is that the indexing operation knows how to convert"
" colon notations to slices, thanks to support from the parser. This is "
"valid::"
msgstr ""

#: ../../pep-0637.rst:257 ../../pep-0637.rst:265
msgid "this one isn't::"
msgstr ""

#: ../../pep-0637.rst:261
msgid ""
"The fifth difference is that there's no zero-argument form. This is "
"valid::"
msgstr ""

#: ../../pep-0637.rst:270
msgid "Specification"
msgstr ""

#: ../../pep-0637.rst:272
msgid ""
"Before describing the specification, it is important to stress the "
"difference in nomenclature between *positional index*, *final index*  and"
" *keyword argument*, as it is important to understand the fundamental "
"asymmetries at play. The ``__(get|set|del)item__`` is fundamentally an "
"indexing operation, and the way the element is retrieved, set, or deleted"
" is through an index, the *final index*."
msgstr ""

#: ../../pep-0637.rst:278
msgid ""
"The current status quo is to directly build the *final index* from what "
"is passed between square brackets, the *positional index*. In other "
"words, what is passed in the square brackets is trivially used to "
"generate what the code in ``__getitem__`` then uses for the indicisation "
"operation. As we already saw for the dict, ``d[1]`` has a positional "
"index of ``1`` and also a final index of ``1`` (because it's the element "
"that is then added to the dictionary) and ``d[1, 2]`` has positional "
"index of ``(1, 2)`` and final index also of ``(1, 2)`` (because yet again"
" it's the element that is added to the dictionary). However, the "
"positional index ``d[1,2:3]`` is not accepted by the dictionary, because "
"there's no way to transform the positional index into a final index, as "
"the slice object is unhashable. The positional index is what is currently"
" known as the ``index`` parameter in ``__getitem__``. Nevertheless, "
"nothing prevents to construct a dictionary-like class that creates the "
"final index by e.g. converting the positional index to a string."
msgstr ""

#: ../../pep-0637.rst:291
msgid ""
"This PEP extends the current status quo, and grants more flexibility to "
"create the final index via an enhanced syntax that combines the "
"positional index and keyword arguments, if passed."
msgstr ""

#: ../../pep-0637.rst:295
msgid ""
"The above brings an important point across. Keyword arguments, in the "
"context of the index operation, may be used to take indexing decisions to"
" obtain the final index, and therefore will have to accept values that "
"are unconventional for functions. See for example use case 1, where a "
"slice is accepted."
msgstr ""

#: ../../pep-0637.rst:300
msgid ""
"The successful implementation of this PEP will result in the following "
"behavior:"
msgstr ""

#: ../../pep-0637.rst:302
msgid ""
"An empty subscript is still illegal, regardless of context (see Rejected "
"Ideas)::"
msgstr ""

#: ../../pep-0637.rst:306
msgid "A single index value remains a single index value when passed::"
msgstr ""

#: ../../pep-0637.rst:317
msgid ""
"This remains the case even if the index is followed by keywords; see "
"point 5 below."
msgstr ""

#: ../../pep-0637.rst:319
msgid ""
"Comma-separated arguments are still parsed as a tuple and passed as a "
"single positional argument::"
msgstr ""

#: ../../pep-0637.rst:331
msgid ""
"The points above mean that classes which do not want to support keyword "
"arguments in subscripts need do nothing at all, and the feature is "
"therefore completely backwards compatible."
msgstr ""

#: ../../pep-0637.rst:335
msgid "Keyword arguments, if any, must follow positional arguments::"
msgstr ""

#: ../../pep-0637.rst:339
msgid ""
"This is like function calls, where intermixing positional and keyword "
"arguments give a SyntaxError."
msgstr ""

#: ../../pep-0637.rst:342
msgid ""
"Keyword subscripts, if any, will be handled like they are in function "
"calls. Examples::"
msgstr ""

#: ../../pep-0637.rst:367
msgid "Note that:"
msgstr ""

#: ../../pep-0637.rst:369
msgid ""
"a single positional index will not turn into a tuple just because one "
"adds a keyword value."
msgstr ""

#: ../../pep-0637.rst:372
msgid ""
"for ``__setitem__``, the same order is retained for index and value. The "
"keyword arguments go at the end, as is normal for a function definition."
msgstr ""

#: ../../pep-0637.rst:376
msgid ""
"The same rules apply with respect to keyword subscripts as for keywords "
"in function calls:"
msgstr ""

#: ../../pep-0637.rst:379
msgid ""
"the interpreter matches up each keyword subscript to a named parameter in"
" the appropriate method;"
msgstr ""

#: ../../pep-0637.rst:382
msgid "if a named parameter is used twice, that is an error;"
msgstr ""

#: ../../pep-0637.rst:384
msgid ""
"if there are any named parameters left over (without a value) when the "
"keywords are all used, they are assigned their default value (if any);"
msgstr ""

#: ../../pep-0637.rst:387
msgid "if any such parameter doesn't have a default, that is an error;"
msgstr ""

#: ../../pep-0637.rst:389
msgid ""
"if there are any keyword subscripts remaining after all the named "
"parameters are filled, and the method has a ``**kwargs`` parameter, they "
"are bound to the ``**kwargs`` parameter as a dict;"
msgstr ""

#: ../../pep-0637.rst:393
msgid "but if no ``**kwargs`` parameter is defined, it is an error."
msgstr ""

#: ../../pep-0637.rst:396
msgid "Sequence unpacking is allowed inside subscripts::"
msgstr ""

#: ../../pep-0637.rst:400
msgid ""
"This allows notations such as ``[:, *args, :]``, which could be treated "
"as ``[(slice(None), *args, slice(None))]``. Multiple star unpacking are "
"allowed::"
msgstr ""

#: ../../pep-0637.rst:407
msgid "The following notation equivalence must be honored::"
msgstr ""

#: ../../pep-0637.rst:421
msgid ""
"Note in particular case 3: sequence unpacking of a single element will "
"not behave as if only one single argument was passed. A related case is "
"the following example::"
msgstr ""

#: ../../pep-0637.rst:429
msgid ""
"However, as we saw earlier, for backward compatibility a single index "
"will be passed as is::"
msgstr ""

#: ../../pep-0637.rst:434
msgid ""
"In other words, a single positional index will be passed \"as is\" only "
"if no sequence unpacking is present. If a sequence unpacking is present, "
"then the index will become a tuple, regardless of the resulting number of"
" elements in the index after the unpacking has taken place."
msgstr ""

#: ../../pep-0637.rst:438
msgid "Dict unpacking is permitted::"
msgstr ""

#: ../../pep-0637.rst:444
msgid "The following notation equivalent should be honored::"
msgstr ""

#: ../../pep-0637.rst:452
msgid ""
"Keyword-only subscripts are permitted. The positional index will be the "
"empty tuple::"
msgstr ""

#: ../../pep-0637.rst:463
msgid ""
"The choice of the empty tuple as a sentinel has been debated. Details are"
" provided in the Rejected Ideas section."
msgstr ""

#: ../../pep-0637.rst:466
msgid "Keyword arguments must allow slice syntax::"
msgstr ""

#: ../../pep-0637.rst:471
msgid ""
"This may open up the possibility to accept the same syntax for general "
"function calls, but this is not part of this recommendation."
msgstr ""

#: ../../pep-0637.rst:474
msgid "Keyword arguments allow for default values::"
msgstr ""

#: ../../pep-0637.rst:482
msgid ""
"The same semantics given above must be extended to "
"``__class__getitem__``: Since PEP 560, type hints are dispatched so that "
"for ``x[y]``, if no ``__getitem__`` method is found, and ``x`` is a type "
"(class) object, and ``x`` has a class method ``__class_getitem__``, that "
"method is called. The same changes should be applied to this method as "
"well, so that a writing like ``list[T=int]`` can be accepted."
msgstr ""

#: ../../pep-0637.rst:490
msgid "Indexing behavior in standard classes (dict, list, etc.)"
msgstr ""

#: ../../pep-0637.rst:492
msgid ""
"None of what is proposed in this PEP will change the behavior of the "
"current core classes that use indexing. Adding keywords to the index "
"operation for custom classes is not the same as modifying e.g. the "
"standard dict type to handle keyword arguments. In fact, dict (as well as"
" list and other stdlib classes with indexing semantics) will remain the "
"same and will continue not to accept keyword arguments. In other words, "
"if ``d`` is a ``dict``, the statement ``d[1, a=2]`` will raise "
"``TypeError``, as their implementation will not support the use of "
"keyword arguments. The same holds for all other classes (list, dict, "
"etc.)"
msgstr ""

#: ../../pep-0637.rst:503
msgid "Corner case and Gotchas"
msgstr ""

#: ../../pep-0637.rst:505
msgid ""
"With the introduction of the new notation, a few corner cases need to be "
"analysed."
msgstr ""

#: ../../pep-0637.rst:507
msgid "Technically, if a class defines their getter like this::"
msgstr ""

#: ../../pep-0637.rst:511
msgid ""
"then the caller could call that using keyword syntax, like these two "
"cases::"
msgstr ""

#: ../../pep-0637.rst:516
msgid ""
"The resulting behavior would be an error automatically, since it would be"
" like attempting to call the method with two values for the ``index`` "
"argument, and a ``TypeError`` will be raised. In the first case, the "
"``index`` would be ``3``, in the second case, it would be the empty tuple"
" ``()``."
msgstr ""

#: ../../pep-0637.rst:521
msgid ""
"Note that this behavior applies for all currently existing classes that "
"rely on indexing, meaning that there is no way for the new behavior to "
"introduce backward compatibility issues on this respect."
msgstr ""

#: ../../pep-0637.rst:525
msgid ""
"Classes that wish to stress this behavior explicitly can define their "
"parameters as positional-only::"
msgstr ""

#: ../../pep-0637.rst:530
msgid "a similar case occurs with setter notation::"
msgstr ""

#: ../../pep-0637.rst:535
msgid ""
"This poses no issue because the value is passed automatically, and the "
"Python interpreter will raise ``TypeError: got multiple values for "
"keyword argument 'value'``"
msgstr ""

#: ../../pep-0637.rst:539
msgid ""
"If the subscript dunders are declared to use positional-or-keyword "
"parameters, there may be some surprising cases when arguments are passed "
"to the method. Given the signature::"
msgstr ""

#: ../../pep-0637.rst:545
msgid "if the caller uses this::"
msgstr ""

#: ../../pep-0637.rst:549
msgid "they will probably be surprised by the method call::"
msgstr ""

#: ../../pep-0637.rst:555
msgid ""
"Solution: best practice suggests that keyword subscripts should be "
"flagged as keyword-only when possible::"
msgstr ""

#: ../../pep-0637.rst:560
msgid ""
"The interpreter need not enforce this rule, as there could be scenarios "
"where this is the desired behaviour. But linters may choose to warn about"
" subscript methods which don't use the keyword-only flag."
msgstr ""

#: ../../pep-0637.rst:564
msgid ""
"As we saw, a single value followed by a keyword argument will not be "
"changed into a tuple, i.e.: ``d[1, a=3]`` is treated as ``__getitem__(d, "
"1, a=3)``, NOT ``__getitem__(d, (1,), a=3)``. It would be extremely "
"confusing if adding keyword arguments were to change the type of the "
"passed index. In other words, adding a keyword to a single-valued "
"subscript will not change it into a tuple. For those cases where an "
"actual tuple needs to be passed, a proper syntax will have to be used::"
msgstr ""

#: ../../pep-0637.rst:573
msgid ""
"In this case, the call is passing a single element (which is passed as "
"is, as from rule above), only that the single element happens to be a "
"tuple."
msgstr ""

#: ../../pep-0637.rst:576
msgid ""
"Note that this behavior just reveals the truth that the ``obj[1,]`` "
"notation is shorthand for ``obj[(1,)]`` (and also ``obj[1]`` is shorthand"
" for ``obj[(1)]``, with the expected behavior). When keywords are "
"present, the rule that you can omit this outermost pair of parentheses is"
" no longer true::"
msgstr ""

#: ../../pep-0637.rst:593
msgid "This is particularly relevant in the case where two entries are passed::"
msgstr ""

#: ../../pep-0637.rst:607
msgid "And particularly when the tuple is extracted as a variable::"
msgstr ""

#: ../../pep-0637.rst:616
msgid ""
"Why? because in the case ``obj[1, 2, a=3]`` we are passing two elements "
"(which are then packed as a tuple and passed as the index). In the case "
"``obj[(1, 2), a=3]`` we are passing a single element (which is passed as "
"is) which happens to be a tuple. The final result is that they are the "
"same."
msgstr ""

#: ../../pep-0637.rst:622
msgid "C Interface"
msgstr ""

#: ../../pep-0637.rst:624
msgid ""
"Resolution of the indexing operation is performed through a call to the "
"following functions"
msgstr ""

#: ../../pep-0637.rst:626
msgid "``PyObject_GetItem(PyObject *o, PyObject *key)`` for the get operation"
msgstr ""

#: ../../pep-0637.rst:627
msgid ""
"``PyObject_SetItem(PyObject *o, PyObject *key, PyObject *value)`` for the"
" set operation"
msgstr ""

#: ../../pep-0637.rst:628
msgid "``PyObject_DelItem(PyObject *o, PyObject *key)`` for the del operation"
msgstr ""

#: ../../pep-0637.rst:630
msgid ""
"These functions are used extensively within the Python executable, and "
"are also part of the public C API, as exported by ``Include/abstract.h``."
" It is clear that the signature of this function cannot be changed, and "
"different C level functions need to be implemented to support the "
"extended call. We propose"
msgstr ""

#: ../../pep-0637.rst:635 ../../pep-0637.rst:637
msgid ""
"``PyObject_GetItemWithKeywords(PyObject *o, PyObject *key, PyObject "
"*kwargs)``"
msgstr ""

#: ../../pep-0637.rst:636
msgid ""
"``PyObject_SetItemWithKeywords(PyObject *o, PyObject *key, PyObject "
"*value, PyObject *kwargs)``"
msgstr ""

#: ../../pep-0637.rst:639
msgid ""
"New opcodes will be needed for the enhanced call.  Currently, the "
"implementation uses ``BINARY_SUBSCR``, ``STORE_SUBSCR`` and "
"``DELETE_SUBSCR`` to invoke the old functions. We propose "
"``BINARY_SUBSCR_KW``, ``STORE_SUBSCR_KW`` and ``DELETE_SUBSCR_KW`` for "
"the new operations. The compiler will have to generate these new opcodes."
" The old C implementations will call the extended methods passing "
"``NULL`` as kwargs."
msgstr ""

#: ../../pep-0637.rst:647
msgid ""
"Finally, the following new slots must be added to the "
"``PyMappingMethods`` struct:"
msgstr ""

#: ../../pep-0637.rst:649
msgid "``mp_subscript_kw``"
msgstr ""

#: ../../pep-0637.rst:650
msgid "``mp_ass_subscript_kw``"
msgstr ""

#: ../../pep-0637.rst:652
msgid ""
"These slots will have the appropriate signature to handle the dictionary "
"object containing the keywords."
msgstr ""

#: ../../pep-0637.rst:656
msgid "\"How to teach\" recommendations"
msgstr ""

#: ../../pep-0637.rst:658
msgid ""
"One request that occurred during feedback sessions was to detail a "
"possible narrative for teaching the feature, e.g. to students, data "
"scientists, and similar audience. This section addresses that need."
msgstr ""

#: ../../pep-0637.rst:662
msgid ""
"We will only describe the indexing from the perspective of use, not of "
"implementation, because it is the aspect that the above mentioned "
"audience will likely encounter. Only a subset of the users will have to "
"implement their own dunder functions, and can be considered advanced "
"usage. A proper explanation could be:"
msgstr ""

#: ../../pep-0637.rst:667
msgid ""
"The indexing operation is generally used to refer to a subset of a larger"
" dataset by means of an index. In the commonly seen cases, the index is "
"made by one or more numbers, strings, slices, etc."
msgstr ""

#: ../../pep-0637.rst:671
msgid ""
"Some types may allow indexing to occur not only with the index, but also "
"with named values. These named values are given between square brackets "
"using the same syntax used for function call keyword arguments. The "
"meaning of the names and their use is found in the documentation of the "
"type, as it varies from one type to another."
msgstr ""

#: ../../pep-0637.rst:677
msgid ""
"The teacher will now show some practical real world examples, explaining "
"the semantics of the feature in the shown library. At the time of writing"
" these examples do not exist, obviously, but the libraries most likely to"
" implement the feature are pandas and numpy, possibly as a method to "
"refer to columns by name."
msgstr ""

#: ../../pep-0637.rst:684
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0637.rst:686
msgid ""
"A reference implementation is currently being developed here [#reference-"
"impl]_."
msgstr ""

#: ../../pep-0637.rst:690
msgid "Workarounds"
msgstr ""

#: ../../pep-0637.rst:692
msgid ""
"Every PEP that changes the Python language should \"clearly explain why "
"the existing language specification is inadequate to address the problem "
"that the PEP solves.\" [#pep-0001]_"
msgstr ""

#: ../../pep-0637.rst:696
msgid ""
"Some rough equivalents to the proposed extension, which we call work-"
"arounds, are already possible. The work-arounds provide an alternative to"
" enabling the new syntax, while leaving the semantics to be defined "
"elsewhere."
msgstr ""

#: ../../pep-0637.rst:700
msgid ""
"These work-arounds follow. In them the helpers ``H`` and ``P`` are not "
"intended to be universal. For example, a module or package might require "
"the use of its own helpers."
msgstr ""

#: ../../pep-0637.rst:704
msgid ""
"User defined classes can be given ``getitem`` and ``delitem`` methods, "
"that respectively get and delete values stored in a container::"
msgstr ""

#: ../../pep-0637.rst:710
msgid "The same can't be done for ``setitem``. It's not valid syntax::"
msgstr ""

#: ../../pep-0637.rst:715
msgid ""
"A helper class, here called ``H``, can be used to swap the container and "
"parameter roles. In other words, we use::"
msgstr ""

#: ../../pep-0637.rst:720
msgid "as a substitute for::"
msgstr ""

#: ../../pep-0637.rst:724
msgid ""
"This method will work for ``getitem``, ``delitem`` and also for "
"``setitem``. This is because::"
msgstr ""

#: ../../pep-0637.rst:729
msgid "is valid syntax, which can be given the appropriate semantics."
msgstr ""

#: ../../pep-0637.rst:731
msgid ""
"A helper function, here called ``P``, can be used to store the arguments "
"in a single object. For example::"
msgstr ""

#: ../../pep-0637.rst:736
msgid "is valid syntax, and can be given the appropriate semantics."
msgstr ""

#: ../../pep-0637.rst:738
msgid ""
"The ``lo:hi:step`` syntax for slices is sometimes very useful. This "
"syntax is not directly available in the work-arounds. However::"
msgstr ""

#: ../../pep-0637.rst:743
msgid "provides a work-around that is available everything, where::"
msgstr ""

#: ../../pep-0637.rst:750
msgid "defines the helper object ``s``."
msgstr ""

#: ../../pep-0637.rst:753
msgid "Rejected Ideas"
msgstr ""

#: ../../pep-0637.rst:756
msgid "Previous PEP 472 solutions"
msgstr ""

#: ../../pep-0637.rst:758
msgid ""
"PEP 472 presents a good amount of ideas that are now all to be considered"
" Rejected. A personal email from D'Aprano to the author specifically "
"said:"
msgstr ""

#: ../../pep-0637.rst:761
msgid ""
"I have now carefully read through PEP 472 in full, and I am afraid I "
"cannot support any of the strategies currently in the PEP."
msgstr ""

#: ../../pep-0637.rst:764
msgid ""
"We agree that those options are inferior to the currently presented, for "
"one reason or another."
msgstr ""

#: ../../pep-0637.rst:767
msgid ""
"To keep this document compact, we will not present here the objections "
"for all options presented in PEP 472. Suffice to say that they were "
"discussed, and each proposed alternative had one or few dealbreakers."
msgstr ""

#: ../../pep-0637.rst:772
msgid "Adding new dunders"
msgstr ""

#: ../../pep-0637.rst:774
msgid ""
"It was proposed to introduce new dunders ``__(get|set|del)item_ex__`` "
"that are invoked over the ``__(get|set|del)item__`` triad, if they are "
"present."
msgstr ""

#: ../../pep-0637.rst:777
msgid ""
"The rationale around this choice is to make the intuition around how to "
"add kwd arg support to square brackets more obvious and in line with the "
"function behavior. Given::"
msgstr ""

#: ../../pep-0637.rst:783
msgid "These all just work and produce the same result effortlessly::"
msgstr ""

#: ../../pep-0637.rst:789
msgid ""
"In other words, this solution would unify the behavior of ``__getitem__``"
" to the traditional function signature, but since we can't change "
"``__getitem__`` and break backward compatibility, we would have an "
"extended version that is used preferentially."
msgstr ""

#: ../../pep-0637.rst:793
msgid "The problems with this approach were found to be:"
msgstr ""

#: ../../pep-0637.rst:795
msgid ""
"It will slow down subscripting. For every subscript access, this new "
"dunder attribute gets investigated on the class, and if it is not present"
" then the default key translation function is executed. Different ideas "
"were proposed to handle this, from wrapping the method only at class "
"instantiation time, to add a bit flag to signal the availability of these"
" methods. Regardess of the solution, the new dunder would be effective "
"only if added at class creation time, not if it's added later. This would"
" be unusual and would disallow (and behave unexpectedly) monkeypatching "
"of the methods for whatever reason it might be needed."
msgstr ""

#: ../../pep-0637.rst:805
msgid "It adds complexity to the mechanism."
msgstr ""

#: ../../pep-0637.rst:807
msgid ""
"Will require a long and painful transition period during which time "
"libraries will have to somehow support both calling conventions, because "
"most likely, the extended methods will delegate to the traditional ones "
"when the right conditions are matched in the arguments, or some classes "
"will support the traditional dunder and others the extended dunder. While"
" this will not affect calling code, it will affect development."
msgstr ""

#: ../../pep-0637.rst:814
msgid ""
"it would potentially lead to mixed situations where the extended version "
"is defined for the getter, but not for the setter."
msgstr ""

#: ../../pep-0637.rst:817
msgid ""
"In the ``__setitem_ex__`` signature, value would have to be made the "
"first element, because the index is of arbitrary length depending on the "
"specified indexes. This would look awkward because the visual notation "
"does not match the signature::"
msgstr ""

#: ../../pep-0637.rst:825
msgid ""
"the solution relies on the assumption that all keyword indices "
"necessarily map into positional indices, or that they must have a name. "
"This assumption may be false: xarray, which is the primary Python package"
" for numpy arrays with labelled dimensions, supports indexing by "
"additional dimensions (so called \"non-dimension coordinates\") that "
"don't correspond directly to the dimensions of the underlying numpy "
"array, and those have no position to match up to. In other words, "
"anonymous indexes are a plausible use case that this solution would "
"remove, although it could be argued that using ``*args`` would solve that"
" issue."
msgstr ""

#: ../../pep-0637.rst:836
msgid "Adding an adapter function"
msgstr ""

#: ../../pep-0637.rst:838
msgid ""
"Similar to the above, in the sense that a pre-function would be called to"
" convert the \"new style\" indexing into \"old style indexing\" that is "
"then passed. Has problems similar to the above."
msgstr ""

#: ../../pep-0637.rst:843
msgid "create a new \"kwslice\" object"
msgstr ""

#: ../../pep-0637.rst:845
msgid ""
"This proposal has already been explored in \"New arguments contents\" P4 "
"in PEP 472::"
msgstr ""

#: ../../pep-0637.rst:850
msgid ""
"This solution requires everyone who needs keyword arguments to parse the "
"tuple and/or key object by hand to extract them. This is painful and "
"opens up to the get/set/del function to always accept arbitrary keyword "
"arguments, whether they make sense or not. We want the developer to be "
"able to specify which arguments make sense and which ones do not."
msgstr ""

#: ../../pep-0637.rst:858
msgid "Using a single bit to change the behavior"
msgstr ""

#: ../../pep-0637.rst:860
msgid "A special class dunder flag::"
msgstr ""

#: ../../pep-0637.rst:864
msgid ""
"would change the signature of the ``__get|set|delitem__`` to a \"function"
" like\" dispatch, meaning that this::"
msgstr ""

#: ../../pep-0637.rst:869
msgid "would result in a call to::"
msgstr ""

#: ../../pep-0637.rst:874
msgid ""
"This option has been rejected because it feels odd that a signature of a "
"method depends on a specific value of another dunder. It would be "
"confusing for both static type checkers and for humans: a static type "
"checker would have to hard-code a special case for this, because there "
"really is nothing else in Python where the signature of a dunder depends "
"on the value of another dunder. A human that has to implement a "
"``__getitem__`` dunder would have to look if in the class (or in any of "
"its subclasses) for a ``__keyfn__`` before the dunder can be written. "
"Moreover, adding a base classes that have the ``__keyfn__`` flag set "
"would break the signature of the current methods. This would be even more"
" problematic if the flag is changed at runtime, or if the flag is "
"generated by calling a function that returns randomly True or something "
"else."
msgstr ""

#: ../../pep-0637.rst:887
msgid "Allowing for empty index notation obj[]"
msgstr ""

#: ../../pep-0637.rst:889
msgid ""
"The current proposal prevents ``obj[]`` from being valid notation. "
"However a commenter stated"
msgstr ""

#: ../../pep-0637.rst:892
msgid ""
"We have ``Tuple[int, int]`` as a tuple of two integers. And we have "
"``Tuple[int]`` as a tuple of one integer. And occasionally we need to "
"spell a tuple of *no* values, since that's the type of ``()``. But we "
"currently are forced to write that as ``Tuple[()]``. If we allowed "
"``Tuple[]`` that odd edge case would be removed."
msgstr ""

#: ../../pep-0637.rst:898
msgid ""
"So I probably would be okay with allowing ``obj[]`` syntactically, as "
"long as the dict type could be made to reject it."
msgstr ""

#: ../../pep-0637.rst:901
msgid ""
"This proposal already established that, in case no positional index is "
"given, the passed value must be the empty tuple. Allowing for the empty "
"index notation would make the dictionary type accept it automatically, to"
" insert or refer to the value with the empty tuple as key. Moreover, a "
"typing notation such as ``Tuple[]`` can easily be written as ``Tuple`` "
"without the indexing notation."
msgstr ""

#: ../../pep-0637.rst:907
msgid ""
"However, subsequent discussion with Brandt Bucher during implementation "
"has revealed that the case ``obj[]`` would fit a natural evolution for "
"variadic generics, giving more strength to the above comment. In the end,"
" after a discussion between D'Aprano, Bucher and the author, we decided "
"to leave the ``obj[]`` notation as a syntax error for now, and possibly "
"extend the notation with an additional PEP to hold the equivalence "
"``obj[]`` as ``obj[()]``."
msgstr ""

#: ../../pep-0637.rst:916
msgid "Sentinel value for no given positional index"
msgstr ""

#: ../../pep-0637.rst:918
msgid "The topic of which value to pass as the index in the case of::"
msgstr ""

#: ../../pep-0637.rst:922
msgid "has been considerably debated."
msgstr ""

#: ../../pep-0637.rst:924
msgid ""
"One apparently rational choice would be to pass no value at all, by "
"making use of the keyword only argument feature, but unfortunately will "
"not work well with the ``__setitem__`` dunder, as a positional element "
"for the value is always passed, and we can't \"skip over\" the index one "
"unless we introduce a very weird behavior where the first argument refers"
" to the index when specified, and to the value when index is not "
"specified. This is extremely deceiving and error prone."
msgstr ""

#: ../../pep-0637.rst:931
msgid ""
"The above consideration makes it impossible to have a keyword only "
"dunder, and opens up the question of what entity to pass for the index "
"position when no index is passed::"
msgstr ""

#: ../../pep-0637.rst:938
msgid ""
"A proposed hack would be to let the user specify which entity to use when"
" an index is not specified, by specifying a default for the ``index``, "
"but this forces necessarily to also specify a (never going to be used, as"
" a value is always passed by design) default for the ``value``, as we "
"can't have non-default arguments after defaulted one::"
msgstr ""

#: ../../pep-0637.rst:946
msgid ""
"which seems ugly, redundant and confusing. We must therefore accept that "
"some form of sentinel index must be passed by the Python implementation "
"when the ``obj[k=3]`` notation is used. This also means that default "
"arguments to those parameters are simply never going to be used (but it's"
" already the case with the current implementation, so no change there)."
msgstr ""

#: ../../pep-0637.rst:952
msgid ""
"Additionally, some classes may want to use ``**kwargs``, instead of a "
"keyword-only argument, meaning that having a definition like::"
msgstr ""

#: ../../pep-0637.rst:957
msgid "and a user that wants to pass a keyword ``value``::"
msgstr ""

#: ../../pep-0637.rst:961
msgid "expecting a call like::"
msgstr ""

#: ../../pep-0637.rst:965
msgid ""
"will instead accidentally be caught by the named ``value``, producing a "
"``duplicate value error``. The user should not be worried about the "
"actual local names of those two arguments if they are, for all practical "
"purposes, positional only. Unfortunately, using positional-only values "
"will ensure this does not happen but it will still not solve the need to "
"pass both ``index`` and ``value`` even when the index is not provided. "
"The point is that the user should not be prevented to use keyword "
"arguments to refer to a column ``index``, ``value`` (or ``self``) just "
"because the class implementor happens to use those names in the parameter"
" list."
msgstr ""

#: ../../pep-0637.rst:975
msgid ""
"Moreover, we also require the three dunders to behave in the same way: it"
" would be extremely inconvenient if only ``__setitem__`` were to receive "
"this sentinel, and ``__get|delitem__`` would not because they can get "
"away with a signature that allows for no index specification, thus "
"allowing for a user-specified default index."
msgstr ""

#: ../../pep-0637.rst:981
msgid ""
"Whatever the choice of the sentinel, it will make the following cases "
"degenerate and thus impossible to differentiate in the dunder::"
msgstr ""

#: ../../pep-0637.rst:987
msgid ""
"The question now shifts to which entity should represent the sentinel: "
"the options were:"
msgstr ""

#: ../../pep-0637.rst:990
msgid "Empty tuple"
msgstr ""

#: ../../pep-0637.rst:991
msgid "None"
msgstr ""

#: ../../pep-0637.rst:992
msgid "NotImplemented"
msgstr ""

#: ../../pep-0637.rst:993
msgid "a new sentinel object (e.g. NoIndex)"
msgstr ""

#: ../../pep-0637.rst:995
msgid "For option 1, the call will become::"
msgstr ""

#: ../../pep-0637.rst:999
msgid ""
"therefore making ``obj[k=3]`` and ``obj[(), k=3]`` degenerate and "
"indistinguishable."
msgstr ""

#: ../../pep-0637.rst:1001
msgid "This option sounds appealing because:"
msgstr ""

#: ../../pep-0637.rst:1003
msgid ""
"The numpy community was inquired [#numpy-ml]_, and the general consensus "
"of the responses was that the empty tuple felt appropriate."
msgstr ""

#: ../../pep-0637.rst:1005
msgid ""
"It shows a parallel with the behavior of ``*args`` in a function, when no"
" positional arguments are given::"
msgstr ""

#: ../../pep-0637.rst:1014
msgid ""
"Although we do accept the following asymmetry in behavior compared to "
"functions when a single value is passed, but that ship has sailed::"
msgstr ""

#: ../../pep-0637.rst:1020
msgid ""
"For option 2, using ``None``, it was objected that NumPy uses it to "
"indicate inserting a new axis/dimensions (there's a ``np.newaxis`` alias "
"as well)::"
msgstr ""

#: ../../pep-0637.rst:1027
msgid ""
"While this is not an insurmountable issue, it certainly will ripple onto "
"numpy."
msgstr ""

#: ../../pep-0637.rst:1029
msgid ""
"The only issues with both the above is that both the empty tuple and None"
" are potential legitimate indexes, and there might be value in being able"
" to differentiate the two degenerate cases."
msgstr ""

#: ../../pep-0637.rst:1033
msgid ""
"So, an alternative strategy (option 3) would be to use an existing entity"
" that is unlikely to be used as a valid index. One option could be the "
"current built-in constant ``NotImplemented``, which is currently returned"
" by operators methods to report that they do not implement a particular "
"operation, and a different strategy should be attempted (e.g. to ask the "
"other object). Unfortunately, its name and traditional use calls back to "
"a feature that is not available, rather than the fact that something was "
"not passed by the user."
msgstr ""

#: ../../pep-0637.rst:1041
msgid ""
"This leaves us with option 4: a new built-in constant. This constant must"
" be unhashable (so it's never going to be a valid key) and have a clear "
"name that makes it obvious its context: ``NoIndex``. This would solve all"
" the above issues, but the question is: is it worth it?"
msgstr ""

#: ../../pep-0637.rst:1046
msgid ""
"From a quick inquire, it seems that most people on python-ideas seem to "
"believe it's not crucial, and the empty tuple is an acceptable option. "
"Hence the resulting series will be::"
msgstr ""

#: ../../pep-0637.rst:1059
msgid "and the following two notation will be degenerate::"
msgstr ""

#: ../../pep-0637.rst:1068
msgid "Common objections"
msgstr ""

#: ../../pep-0637.rst:1070
msgid "Just use a method call."
msgstr ""

#: ../../pep-0637.rst:1072
msgid ""
"One of the use cases is typing, where the indexing is used exclusively, "
"and function calls are out of the question.  Moreover, function calls do "
"not handle slice notation, which is commonly used in some cases for "
"arrays."
msgstr ""

#: ../../pep-0637.rst:1076
msgid ""
"One problem is type hint creation has been extended to built-ins in "
"Python 3.9, so that you do not have to import Dict, List, et al anymore."
msgstr ""

#: ../../pep-0637.rst:1079
msgid "Without kwdargs inside ``[]``, you would not be able to do this::"
msgstr ""

#: ../../pep-0637.rst:1083
msgid ""
"but for obvious reasons, call syntax using builtins to create custom type"
" hints isn't an option::"
msgstr ""

#: ../../pep-0637.rst:1089
msgid ""
"Finally, function calls do not allow for a setitem-like notation, as "
"shown in the Overview: operations such as ``f(1, x=3) = 5`` are not "
"allowed, and are instead allowed for indexing operations."
msgstr ""

#: ../../pep-0637.rst:1095
msgid "References"
msgstr ""

#: ../../pep-0637.rst:1097
msgid ""
"\"Rejection of PEP 472\" (https://mail.python.org/pipermail/python-"
"dev/2019-March/156693.html)"
msgstr ""

#: ../../pep-0637.rst:1099
msgid "\"PEP 484 -- Type hints\" (https://www.python.org/dev/peps/pep-0484)"
msgstr ""

#: ../../pep-0637.rst:1101
msgid ""
"\"Allow kwargs in __{get|set|del}item__\" "
"(https://mail.python.org/archives/list/python-"
"ideas@python.org/thread/EUGDRTRFIY36K4RM3QRR52CKCI7MIR2M/)"
msgstr ""

#: ../../pep-0637.rst:1103
msgid ""
"\"PEP 472 -- Support for indexing with keyword arguments\" "
"(https://mail.python.org/archives/list/python-"
"ideas@python.org/thread/6OGAFDWCXT5QVV23OZWKBY4TXGZBVYZS/)"
msgstr ""

#: ../../pep-0637.rst:1105
msgid ""
"\"PEP 1 -- PEP Purpose and Guidelines\" "
"(https://www.python.org/dev/peps/pep-0001/#what-belongs-in-a-successful-"
"pep)"
msgstr ""

#: ../../pep-0637.rst:1107
msgid ""
"\"trio.run() should take \\*\\*kwargs in addition to \\*args\" "
"(https://github.com/python-trio/trio/issues/470)"
msgstr ""

#: ../../pep-0637.rst:1109
msgid ""
"\"PEP 646 -- Variadic Generics\" "
"(https://www.python.org/dev/peps/pep-0646)"
msgstr ""

#: ../../pep-0637.rst:1111
msgid ""
"\"[Numpy-discussion] Request for comments on PEP 637 - Support for "
"indexing with keyword arguments\" (http://numpy-"
"discussion.10968.n7.nabble.com/Request-for-comments-on-PEP-637-Support-"
"for-indexing-with-keyword-arguments-td48489.html)"
msgstr ""

#: ../../pep-0637.rst:1113
msgid ""
"\"Reference implementation\" "
"(https://github.com/python/cpython/compare/master...stefanoborini:PEP-637"
"-implementation-attempt-2)"
msgstr ""

#: ../../pep-0637.rst:1117
msgid "Copyright"
msgstr ""

#: ../../pep-0637.rst:1119
msgid "This document has been placed in the public domain."
msgstr ""

