# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0550.rst
msgid "PEP"
msgstr ""

#: ../../pep-0550.rst:1
msgid "550"
msgstr ""

#: ../../pep-0550.rst
msgid "Title"
msgstr ""

#: ../../pep-0550.rst:2
msgid "Execution Context"
msgstr ""

#: ../../pep-0550.rst
msgid "Author"
msgstr ""

#: ../../pep-0550.rst:5
msgid "Yury Selivanov <yury@edgedb.com>, Elvis Pranskevichus <elvis@edgedb.com>"
msgstr ""

#: ../../pep-0550.rst
msgid "Status"
msgstr ""

#: ../../pep-0550.rst:7
msgid "Withdrawn"
msgstr ""

#: ../../pep-0550.rst
msgid "Type"
msgstr ""

#: ../../pep-0550.rst:8
msgid "Standards Track"
msgstr ""

#: ../../pep-0550.rst
msgid "Created"
msgstr ""

#: ../../pep-0550.rst:10
msgid "11-Aug-2017"
msgstr ""

#: ../../pep-0550.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0550.rst:11
msgid "3.7"
msgstr ""

#: ../../pep-0550.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0550.rst:12
msgid "11-Aug-2017, 15-Aug-2017, 18-Aug-2017, 25-Aug-2017, 01-Sep-2017"
msgstr ""

#: ../../pep-0550.rst:17
msgid "Abstract"
msgstr ""

#: ../../pep-0550.rst:19
msgid ""
"This PEP adds a new generic mechanism of ensuring consistent access to "
"non-local state in the context of out-of-order execution, such as in "
"Python generators and coroutines."
msgstr ""

#: ../../pep-0550.rst:23
msgid ""
"Thread-local storage, such as ``threading.local()``, is inadequate for "
"programs that execute concurrently in the same OS thread.  This PEP "
"proposes a solution to this problem."
msgstr ""

#: ../../pep-0550.rst:29
msgid "PEP Status"
msgstr ""

#: ../../pep-0550.rst:31
msgid ""
"Due to its breadth and the lack of general consensus on some aspects, "
"this PEP has been withdrawn and superseded by a simpler :pep:`567`, which"
" has been accepted and included in Python 3.7."
msgstr ""

#: ../../pep-0550.rst:35
msgid ""
":pep:`567` implements the same core idea, but limits the ContextVar "
"support to asynchronous tasks while leaving the generator behavior "
"untouched. The latter may be revisited in a future PEP."
msgstr ""

#: ../../pep-0550.rst:41
msgid "Rationale"
msgstr ""

#: ../../pep-0550.rst:43
msgid ""
"Prior to the advent of asynchronous programming in Python, programs used "
"OS threads to achieve concurrency.  The need for thread-specific state "
"was solved by ``threading.local()`` and its C-API equivalent, "
"``PyThreadState_GetDict()``."
msgstr ""

#: ../../pep-0550.rst:48
msgid ""
"A few examples of where Thread-local storage (TLS) is commonly relied "
"upon:"
msgstr ""

#: ../../pep-0550.rst:51
msgid ""
"Context managers like decimal contexts, ``numpy.errstate``, and "
"``warnings.catch_warnings``."
msgstr ""

#: ../../pep-0550.rst:54
msgid ""
"Request-related data, such as security tokens and request data in web "
"applications, language context for ``gettext`` etc."
msgstr ""

#: ../../pep-0550.rst:57
msgid "Profiling, tracing, and logging in large code bases."
msgstr ""

#: ../../pep-0550.rst:59
msgid ""
"Unfortunately, TLS does not work well for programs which execute "
"concurrently in a single thread.  A Python generator is the simplest "
"example of a concurrent program.  Consider the following::"
msgstr ""

#: ../../pep-0550.rst:74
msgid "The intuitively expected value of ``items`` is::"
msgstr ""

#: ../../pep-0550.rst:79
msgid "Rather surprisingly, the actual result is::"
msgstr ""

#: ../../pep-0550.rst:84
msgid ""
"This is because implicit Decimal context is stored as a thread-local, so "
"concurrent iteration of the ``fractions()`` generator would corrupt the "
"state.  For Decimal, specifically, the only current workaround is to use "
"explicit context method calls for all arithmetic operations [28]_.  "
"Arguably, this defeats the usefulness of overloaded operators and makes "
"even simple formulas hard to read and write."
msgstr ""

#: ../../pep-0550.rst:91
msgid ""
"Coroutines are another class of Python code where TLS unreliability is a "
"significant issue."
msgstr ""

#: ../../pep-0550.rst:94
msgid ""
"The inadequacy of TLS in asynchronous code has lead to the proliferation "
"of ad-hoc solutions, which are limited in scope and do not support all "
"required use cases."
msgstr ""

#: ../../pep-0550.rst:98
msgid ""
"The current status quo is that any library (including the standard "
"library), which relies on TLS, is likely to be broken when used in "
"asynchronous code or with generators (see [3]_ as an example issue.)"
msgstr ""

#: ../../pep-0550.rst:102
msgid ""
"Some languages, that support coroutines or generators, recommend passing "
"the context manually as an argument to every function, see [1]_ for an "
"example.  This approach, however, has limited use for Python, where there"
" is a large ecosystem that was built to work with a TLS-like context.  "
"Furthermore, libraries like ``decimal`` or ``numpy`` rely on context "
"implicitly in overloaded operator implementations."
msgstr ""

#: ../../pep-0550.rst:110
msgid ""
"The .NET runtime, which has support for async/await, has a generic "
"solution for this problem, called ``ExecutionContext`` (see [2]_)."
msgstr ""

#: ../../pep-0550.rst:115
msgid "Goals"
msgstr ""

#: ../../pep-0550.rst:117
msgid ""
"The goal of this PEP is to provide a more reliable ``threading.local()`` "
"alternative, which:"
msgstr ""

#: ../../pep-0550.rst:120
msgid ""
"provides the mechanism and the API to fix non-local state issues with "
"coroutines and generators;"
msgstr ""

#: ../../pep-0550.rst:123
msgid ""
"implements TLS-like semantics for synchronous code, so that users like "
"``decimal`` and ``numpy`` can switch to the new mechanism with minimal "
"risk of breaking backwards compatibility;"
msgstr ""

#: ../../pep-0550.rst:127
msgid ""
"has no or negligible performance impact on the existing code or the code "
"that will be using the new mechanism, including C extensions."
msgstr ""

#: ../../pep-0550.rst:133
msgid "High-Level Specification"
msgstr ""

#: ../../pep-0550.rst:135
msgid "The full specification of this PEP is broken down into three parts:"
msgstr ""

#: ../../pep-0550.rst:137
msgid ""
"High-Level Specification (this section): the description of the overall "
"solution.  We show how it applies to generators and coroutines in user "
"code, without delving into implementation details."
msgstr ""

#: ../../pep-0550.rst:142
msgid ""
"Detailed Specification: the complete description of new concepts, APIs, "
"and related changes to the standard library."
msgstr ""

#: ../../pep-0550.rst:145
msgid ""
"Implementation Details: the description and analysis of data structures "
"and algorithms used to implement this PEP, as well as the necessary "
"changes to CPython."
msgstr ""

#: ../../pep-0550.rst:149
msgid ""
"For the purpose of this section, we define *execution context* as an "
"opaque container of non-local state that allows consistent access to its "
"contents in the concurrent execution environment."
msgstr ""

#: ../../pep-0550.rst:153
msgid ""
"A *context variable* is an object representing a value in the execution "
"context.  A call to ``contextvars.ContextVar(name)`` creates a new "
"context variable object.  A context variable object has three methods:"
msgstr ""

#: ../../pep-0550.rst:158
msgid ""
"``get()``: returns the value of the variable in the current execution "
"context;"
msgstr ""

#: ../../pep-0550.rst:161
msgid ""
"``set(value)``: sets the value of the variable in the current execution "
"context;"
msgstr ""

#: ../../pep-0550.rst:164
msgid ""
"``delete()``: can be used for restoring variable state, it's purpose and "
"semantics are explained in `Setting and restoring context variables`_."
msgstr ""

#: ../../pep-0550.rst:170
msgid "Regular Single-threaded Code"
msgstr ""

#: ../../pep-0550.rst:172
msgid ""
"In regular, single-threaded code that doesn't involve generators or "
"coroutines, context variables behave like globals::"
msgstr ""

#: ../../pep-0550.rst:188
msgid "Multithreaded Code"
msgstr ""

#: ../../pep-0550.rst:190
msgid "In multithreaded code, context variables behave like thread locals::"
msgstr ""

#: ../../pep-0550.rst:210 ../../pep-0550.rst:478
msgid "Generators"
msgstr ""

#: ../../pep-0550.rst:212
msgid ""
"Unlike regular function calls, generators can cooperatively yield their "
"control of execution to the caller.  Furthermore, a generator does not "
"control *where* the execution would continue after it yields. It may be "
"resumed from an arbitrary code location."
msgstr ""

#: ../../pep-0550.rst:217
msgid ""
"For these reasons, the least surprising behaviour of generators is as "
"follows:"
msgstr ""

#: ../../pep-0550.rst:220
msgid ""
"changes to context variables are always local and are not visible in the "
"outer context, but are visible to the code called by the generator;"
msgstr ""

#: ../../pep-0550.rst:224
msgid ""
"once set in the generator, the context variable is guaranteed not to "
"change between iterations;"
msgstr ""

#: ../../pep-0550.rst:227
msgid ""
"changes to context variables in outer context (where the generator is "
"being iterated) are visible to the generator, unless these variables were"
" also modified inside the generator."
msgstr ""

#: ../../pep-0550.rst:231
msgid "Let's review::"
msgstr ""

#: ../../pep-0550.rst:264
msgid ""
"Now, let's revisit the decimal precision example from the `Rationale`_ "
"section, and see how the execution context can improve the situation::"
msgstr ""

#: ../../pep-0550.rst:301
msgid "The value of ``items`` is::"
msgstr ""

#: ../../pep-0550.rst:306
msgid "which matches the expected result."
msgstr ""

#: ../../pep-0550.rst:310
msgid "Coroutines and Asynchronous Tasks"
msgstr ""

#: ../../pep-0550.rst:312
msgid ""
"Like generators, coroutines can yield and regain control.  The major "
"difference from generators is that coroutines do not yield to the "
"immediate caller.  Instead, the entire coroutine call stack (coroutines "
"chained by ``await``) switches to another coroutine call stack.  In this "
"regard, ``await``-ing on a coroutine is conceptually similar to a regular"
" function call, and a coroutine chain (or a \"task\", e.g. an "
"``asyncio.Task``) is conceptually similar to a thread."
msgstr ""

#: ../../pep-0550.rst:321
msgid ""
"From this similarity we conclude that context variables in coroutines "
"should behave like \"task locals\":"
msgstr ""

#: ../../pep-0550.rst:324
msgid ""
"changes to context variables in a coroutine are visible to the coroutine "
"that awaits on it;"
msgstr ""

#: ../../pep-0550.rst:327
msgid ""
"changes to context variables made in the caller prior to awaiting are "
"visible to the awaited coroutine;"
msgstr ""

#: ../../pep-0550.rst:330
msgid ""
"changes to context variables made in one task are not visible in other "
"tasks;"
msgstr ""

#: ../../pep-0550.rst:333
msgid ""
"tasks spawned by other tasks inherit the execution context from the "
"parent task, but any changes to context variables made in the parent task"
" *after* the child task was spawned are *not* visible."
msgstr ""

#: ../../pep-0550.rst:337
msgid ""
"The last point shows behaviour that is different from OS threads. OS "
"threads do not inherit the execution context by default. There are two "
"reasons for this: *common usage intent* and backwards compatibility."
msgstr ""

#: ../../pep-0550.rst:342
msgid ""
"The main reason for why tasks inherit the context, and threads do not, is"
" the common usage intent.  Tasks are often used for relatively short-"
"running operations which are logically tied to the code that spawned the "
"task (like running a coroutine with a timeout in asyncio).  OS threads, "
"on the other hand, are normally used for long-running, logically separate"
" code."
msgstr ""

#: ../../pep-0550.rst:349
msgid ""
"With respect to backwards compatibility, we want the execution context to"
" behave like ``threading.local()``.  This is so that libraries can start "
"using the execution context in place of TLS with a lesser risk of "
"breaking compatibility with existing code."
msgstr ""

#: ../../pep-0550.rst:354
msgid ""
"Let's review a few examples to illustrate the semantics we have just "
"defined."
msgstr ""

#: ../../pep-0550.rst:357
msgid "Context variable propagation in a single task::"
msgstr ""

#: ../../pep-0550.rst:378
msgid "Context variable propagation between tasks::"
msgstr ""

#: ../../pep-0550.rst:408
msgid ""
"As shown above, changes to the execution context are local to the task, "
"and tasks get a snapshot of the execution context at the point of "
"creation."
msgstr ""

#: ../../pep-0550.rst:412
msgid ""
"There is one narrow edge case when this can lead to surprising behaviour."
"  Consider the following example where we modify the context variable in "
"a nested coroutine::"
msgstr ""

#: ../../pep-0550.rst:437
msgid ""
"However, relying on context changes leaking to the caller is ultimately a"
" bad pattern.  For this reason, the behaviour shown in the above example "
"is not considered a major issue and can be addressed with proper "
"documentation."
msgstr ""

#: ../../pep-0550.rst:444
msgid "Detailed Specification"
msgstr ""

#: ../../pep-0550.rst:446
msgid ""
"Conceptually, an *execution context* (EC) is a stack of logical contexts."
"  There is always exactly one active EC per Python thread."
msgstr ""

#: ../../pep-0550.rst:449
msgid ""
"A *logical context* (LC) is a mapping of context variables to their "
"values in that particular LC."
msgstr ""

#: ../../pep-0550.rst:452
msgid ""
"A *context variable* is an object representing a value in the execution "
"context.  A new context variable object is created by calling "
"``contextvars.ContextVar(name: str)``.  The value of the required "
"``name`` argument is not used by the EC machinery, but may be used for "
"debugging and introspection."
msgstr ""

#: ../../pep-0550.rst:458
msgid "The context variable object has the following methods and attributes:"
msgstr ""

#: ../../pep-0550.rst:460
msgid "``name``: the value passed to ``ContextVar()``."
msgstr ""

#: ../../pep-0550.rst:462
msgid ""
"``get(*, topmost=False, default=None)``, if *topmost* is ``False`` (the "
"default), traverses the execution context top-to-bottom, until the "
"variable value is found.  If *topmost* is ``True``, returns the value of "
"the variable in the topmost logical context. If the variable value was "
"not found, returns the value of *default*."
msgstr ""

#: ../../pep-0550.rst:468
msgid ""
"``set(value)``: sets the value of the variable in the topmost logical "
"context."
msgstr ""

#: ../../pep-0550.rst:471
msgid ""
"``delete()``: removes the variable from the topmost logical context. "
"Useful when restoring the logical context to the state prior to the "
"``set()`` call, for example, in a context manager, see `Setting and "
"restoring context variables`_ for more information."
msgstr ""

#: ../../pep-0550.rst:480
msgid ""
"When created, each generator object has an empty logical context object "
"stored in its ``__logical_context__`` attribute.  This logical context is"
" pushed onto the execution context at the beginning of each generator "
"iteration and popped at the end::"
msgstr ""

#: ../../pep-0550.rst:545
msgid ""
"The snippet above shows the state of the execution context stack "
"throughout the generator lifespan."
msgstr ""

#: ../../pep-0550.rst:550
msgid "contextlib.contextmanager"
msgstr ""

#: ../../pep-0550.rst:552
msgid ""
"The ``contextlib.contextmanager()`` decorator can be used to turn a "
"generator into a context manager.  A context manager that temporarily "
"modifies the value of a context variable could be defined like this::"
msgstr ""

#: ../../pep-0550.rst:569
msgid ""
"Unfortunately, this would not work straight away, as the modification to "
"the ``var`` variable is contained to the ``var_context()`` generator, and"
" therefore will not be visible inside the ``with`` block::"
msgstr ""

#: ../../pep-0550.rst:584
msgid ""
"The way to fix this is to set the generator's ``__logical_context__`` "
"attribute to ``None``.  This will cause the generator to avoid modifying "
"the execution context stack."
msgstr ""

#: ../../pep-0550.rst:588
msgid ""
"We modify the ``contextlib.contextmanager()`` decorator to set "
"``genobj.__logical_context__`` to ``None`` to produce well-behaved "
"context managers::"
msgstr ""

#: ../../pep-0550.rst:603
msgid "Enumerating context vars"
msgstr ""

#: ../../pep-0550.rst:605
msgid ""
"The ``ExecutionContext.vars()`` method returns a list of ``ContextVar`` "
"objects, that have values in the execution context. This method is mostly"
" useful for introspection and logging."
msgstr ""

#: ../../pep-0550.rst:611
msgid "coroutines"
msgstr ""

#: ../../pep-0550.rst:613
msgid ""
"In CPython, coroutines share the implementation with generators. The "
"difference is that in coroutines ``__logical_context__`` defaults to "
"``None``.  This affects both the ``async def`` coroutines and the old-"
"style generator-based coroutines (generators decorated with "
"``@types.coroutine``)."
msgstr ""

#: ../../pep-0550.rst:621
msgid "Asynchronous Generators"
msgstr ""

#: ../../pep-0550.rst:623
msgid ""
"The execution context semantics in asynchronous generators does not "
"differ from that of regular generators."
msgstr ""

#: ../../pep-0550.rst:628
msgid "asyncio"
msgstr ""

#: ../../pep-0550.rst:630
msgid ""
"``asyncio`` uses ``Loop.call_soon``, ``Loop.call_later``, and "
"``Loop.call_at`` to schedule the asynchronous execution of a function.  "
"``asyncio.Task`` uses ``call_soon()`` to run the wrapped coroutine."
msgstr ""

#: ../../pep-0550.rst:635
msgid ""
"We modify ``Loop.call_{at,later,soon}`` to accept the new optional "
"*execution_context* keyword argument, which defaults to the copy of the "
"current execution context::"
msgstr ""

#: ../../pep-0550.rst:648
msgid ""
"The ``contextvars.get_execution_context()`` function returns a shallow "
"copy of the current execution context.  By shallow copy here we mean such"
" a new execution context that:"
msgstr ""

#: ../../pep-0550.rst:652
msgid ""
"lookups in the copy provide the same results as in the original execution"
" context, and"
msgstr ""

#: ../../pep-0550.rst:654
msgid "any changes in the original execution context do not affect the copy, and"
msgstr ""

#: ../../pep-0550.rst:656
msgid "any changes to the copy do not affect the original execution context."
msgstr ""

#: ../../pep-0550.rst:659
msgid "Either of the following satisfy the copy requirements:"
msgstr ""

#: ../../pep-0550.rst:661
msgid "a new stack with shallow copies of logical contexts;"
msgstr ""

#: ../../pep-0550.rst:662
msgid "a new stack with one squashed logical context."
msgstr ""

#: ../../pep-0550.rst:664
msgid ""
"The ``contextvars.run_with_execution_context(ec, func, *args, **kwargs)``"
" function runs ``func(*args, **kwargs)`` with *ec* as the execution "
"context.  The function performs the following steps:"
msgstr ""

#: ../../pep-0550.rst:668
msgid "Set *ec* as the current execution context stack in the current thread."
msgstr ""

#: ../../pep-0550.rst:670
msgid "Push an empty logical context onto the stack."
msgstr ""

#: ../../pep-0550.rst:671 ../../pep-0550.rst:725
msgid "Run ``func(*args, **kwargs)``."
msgstr ""

#: ../../pep-0550.rst:672
msgid "Pop the logical context from the stack."
msgstr ""

#: ../../pep-0550.rst:673
msgid "Restore the original execution context stack."
msgstr ""

#: ../../pep-0550.rst:674 ../../pep-0550.rst:727
msgid "Return or raise the ``func()`` result."
msgstr ""

#: ../../pep-0550.rst:676
msgid ""
"These steps ensure that *ec* cannot be modified by *func*, which makes "
"``run_with_execution_context()`` idempotent."
msgstr ""

#: ../../pep-0550.rst:679
msgid "``asyncio.Task`` is modified as follows::"
msgstr ""

#: ../../pep-0550.rst:704
msgid "Generators Transformed into Iterators"
msgstr ""

#: ../../pep-0550.rst:706
msgid ""
"Any Python generator can be represented as an equivalent iterator. "
"Compilers like Cython rely on this axiom.  With respect to the execution "
"context, such iterator should behave the same way as the generator it "
"represents."
msgstr ""

#: ../../pep-0550.rst:711
msgid ""
"This means that there needs to be a Python API to create new logical "
"contexts and run code with a given logical context."
msgstr ""

#: ../../pep-0550.rst:714
msgid ""
"The ``contextvars.LogicalContext()`` function creates a new empty logical"
" context."
msgstr ""

#: ../../pep-0550.rst:717
msgid ""
"The ``contextvars.run_with_logical_context(lc, func, *args, **kwargs)`` "
"function can be used to run functions in the specified logical context.  "
"The *lc* can be modified as a result of the call."
msgstr ""

#: ../../pep-0550.rst:721
msgid ""
"The ``contextvars.run_with_logical_context()`` function performs the "
"following steps:"
msgstr ""

#: ../../pep-0550.rst:724
msgid "Push *lc* onto the current execution context stack."
msgstr ""

#: ../../pep-0550.rst:726
msgid "Pop *lc* from the execution context stack."
msgstr ""

#: ../../pep-0550.rst:729
msgid ""
"By using ``LogicalContext()`` and ``run_with_logical_context()``, we can "
"replicate the generator behaviour like this::"
msgstr ""

#: ../../pep-0550.rst:748
msgid "Let's see how this pattern can be applied to an example generator::"
msgstr ""

#: ../../pep-0550.rst:798
msgid ""
"For hand-written iterators such approach to context management is "
"normally not necessary, and it is easier to set and restore context "
"variables directly in ``__next__``::"
msgstr ""

#: ../../pep-0550.rst:816
msgid "Implementation"
msgstr ""

#: ../../pep-0550.rst:818
msgid ""
"Execution context is implemented as an immutable linked list of logical "
"contexts, where each logical context is an immutable weak key mapping.  A"
" pointer to the currently active execution context is stored in the OS "
"thread state::"
msgstr ""

#: ../../pep-0550.rst:841
msgid ""
"The choice of the immutable list of immutable mappings as a fundamental "
"data structure is motivated by the need to efficiently implement "
"``contextvars.get_execution_context()``, which is to be frequently used "
"by asynchronous tasks and callbacks.  When the EC is immutable, "
"``get_execution_context()`` can simply copy the current execution context"
" *by reference*::"
msgstr ""

#: ../../pep-0550.rst:851
msgid "Let's review all possible context modification scenarios:"
msgstr ""

#: ../../pep-0550.rst:853
msgid "The ``ContextVariable.set()`` method is called::"
msgstr ""

#: ../../pep-0550.rst:867
msgid ""
"The ``contextvars.run_with_logical_context()`` is called, in which case "
"the passed logical context object is appended to the execution context::"
msgstr ""

#: ../../pep-0550.rst:883
msgid ""
"The ``contextvars.run_with_execution_context()`` is called, in which case"
" the current execution context is set to the passed execution context "
"with a new empty logical context appended to it::"
msgstr ""

#: ../../pep-0550.rst:900
msgid ""
"Either ``genobj.send()``, ``genobj.throw()``, ``genobj.close()`` are "
"called on a ``genobj`` generator, in which case the logical context "
"recorded in ``genobj`` is pushed onto the stack::"
msgstr ""

#: ../../pep-0550.rst:932
msgid ""
"Coroutines and asynchronous generators share the implementation with "
"generators, and the above changes apply to them as well."
msgstr ""

#: ../../pep-0550.rst:935
msgid ""
"In certain scenarios the EC may need to be squashed to limit the size of "
"the chain.  For example, consider the following corner case::"
msgstr ""

#: ../../pep-0550.rst:950
msgid ""
"In the above code, the EC chain will grow as long as ``repeat()`` is "
"called. Each new task will call "
"``contextvars.run_with_execution_context()``, which will append a new "
"logical context to the chain.  To prevent unbounded growth, "
"``contextvars.get_execution_context()`` checks if the chain is longer "
"than a predetermined maximum, and if it is, squashes the chain into a "
"single LC::"
msgstr ""

#: ../../pep-0550.rst:977
msgid "Logical Context"
msgstr ""

#: ../../pep-0550.rst:979
msgid ""
"Logical context is an immutable weak key mapping which has the following "
"properties with respect to garbage collection:"
msgstr ""

#: ../../pep-0550.rst:982
msgid ""
"``ContextVar`` objects are strongly-referenced only from the application "
"code, not from any of the execution context machinery or values they "
"point to.  This means that there are no reference cycles that could "
"extend their lifespan longer than necessary, or prevent their collection "
"by the GC."
msgstr ""

#: ../../pep-0550.rst:988
msgid ""
"Values put in the execution context are guaranteed to be kept alive while"
" there is a ``ContextVar`` key referencing them in the thread."
msgstr ""

#: ../../pep-0550.rst:992
msgid ""
"If a ``ContextVar`` is garbage collected, all of its values will be "
"removed from all contexts, allowing them to be GCed if needed."
msgstr ""

#: ../../pep-0550.rst:995
msgid ""
"If an OS thread has ended its execution, its thread state will be cleaned"
" up along with its execution context, cleaning up all values bound to all"
" context variables in the thread."
msgstr ""

#: ../../pep-0550.rst:999
msgid ""
"As discussed earlier, we need ``contextvars.get_execution_context()`` to "
"be consistently fast regardless of the size of the execution context, so "
"logical context is necessarily an immutable mapping."
msgstr ""

#: ../../pep-0550.rst:1003
msgid ""
"Choosing ``dict`` for the underlying implementation is suboptimal, "
"because ``LC.set()`` will cause ``dict.copy()``, which is an O(N) "
"operation, where *N* is the number of items in the LC."
msgstr ""

#: ../../pep-0550.rst:1007
msgid ""
"``get_execution_context()``, when squashing the EC, is an O(M) operation,"
" where *M* is the total number of context variable values in the EC."
msgstr ""

#: ../../pep-0550.rst:1011
msgid ""
"So, instead of ``dict``, we choose Hash Array Mapped Trie (HAMT) as the "
"underlying implementation of logical contexts.  (Scala and Clojure use "
"HAMT to implement high performance immutable collections [5]_, [6]_.)"
msgstr ""

#: ../../pep-0550.rst:1016
msgid ""
"With HAMT ``.set()`` becomes an O(log N) operation, and "
"``get_execution_context()`` squashing is more efficient on average due to"
" structural sharing in HAMT."
msgstr ""

#: ../../pep-0550.rst:1020
msgid ""
"See `Appendix: HAMT Performance Analysis`_ for a more elaborate analysis "
"of HAMT performance compared to ``dict``."
msgstr ""

#: ../../pep-0550.rst:1025
msgid "Context Variables"
msgstr ""

#: ../../pep-0550.rst:1027
msgid ""
"The ``ContextVar.get()`` and ``ContextVar.set()`` methods are implemented"
" as follows (in pseudo-code)::"
msgstr ""

#: ../../pep-0550.rst:1080
msgid ""
"For efficient access in performance-sensitive code paths, such as in "
"``numpy`` and ``decimal``, we cache lookups in ``ContextVar.get()``, "
"making it an O(1) operation when the cache is hit.  The cache key is "
"composed from the following:"
msgstr ""

#: ../../pep-0550.rst:1085
msgid ""
"The new ``uint64_t PyThreadState->unique_id``, which is a globally unique"
" thread state identifier.  It is computed from the new ``uint64_t "
"PyInterpreterState->ts_counter``, which is incremented whenever a new "
"thread state is created."
msgstr ""

#: ../../pep-0550.rst:1090
msgid ""
"The new ``uint64_t PyThreadState->stack_version``, which is a thread-"
"specific counter, which is incremented whenever a non-empty logical "
"context is pushed onto the stack or popped from the stack."
msgstr ""

#: ../../pep-0550.rst:1094
msgid ""
"The ``uint64_t ContextVar->version`` counter, which is incremented "
"whenever the context variable value is changed in any logical context in "
"any OS thread."
msgstr ""

#: ../../pep-0550.rst:1098
msgid "The cache is then implemented as follows::"
msgstr ""

#: ../../pep-0550.rst:1126
msgid ""
"Note that ``last_value`` is a borrowed reference.  We assume that if the "
"version checks are fine, the value object will be alive. This allows the "
"values of context variables to be properly garbage collected."
msgstr ""

#: ../../pep-0550.rst:1131
msgid ""
"This generic caching approach is similar to what the current C "
"implementation of ``decimal`` does to cache the current decimal context, "
"and has similar performance characteristics."
msgstr ""

#: ../../pep-0550.rst:1137
msgid "Performance Considerations"
msgstr ""

#: ../../pep-0550.rst:1139
#, python-format
msgid ""
"Tests of the reference implementation based on the prior revisions of "
"this PEP have shown 1-2% slowdown on generator microbenchmarks and no "
"noticeable difference in macrobenchmarks."
msgstr ""

#: ../../pep-0550.rst:1143
msgid ""
"The performance of non-generator and non-async code is not affected by "
"this PEP."
msgstr ""

#: ../../pep-0550.rst:1148
msgid "Summary of the New APIs"
msgstr ""

#: ../../pep-0550.rst:1151
msgid "Python"
msgstr ""

#: ../../pep-0550.rst:1153
msgid "The following new Python APIs are introduced by this PEP:"
msgstr ""

#: ../../pep-0550.rst:1155
msgid ""
"The new ``contextvars.ContextVar(name: str='...')`` class, instances of "
"which have the following:"
msgstr ""

#: ../../pep-0550.rst:1158
msgid "the read-only ``.name`` attribute,"
msgstr ""

#: ../../pep-0550.rst:1159
msgid ""
"the ``.get()`` method, which returns the value of the variable in the "
"current execution context;"
msgstr ""

#: ../../pep-0550.rst:1161
msgid ""
"the ``.set()`` method, which sets the value of the variable in the "
"current logical context;"
msgstr ""

#: ../../pep-0550.rst:1163
msgid ""
"the ``.delete()`` method, which removes the value of the variable from "
"the current logical context."
msgstr ""

#: ../../pep-0550.rst:1166
msgid ""
"The new ``contextvars.ExecutionContext()`` class, which represents an "
"execution context."
msgstr ""

#: ../../pep-0550.rst:1169
msgid ""
"The new ``contextvars.LogicalContext()`` class, which represents a "
"logical context."
msgstr ""

#: ../../pep-0550.rst:1172
msgid ""
"The new ``contextvars.get_execution_context()`` function, which returns "
"an ``ExecutionContext`` instance representing a copy of the current "
"execution context."
msgstr ""

#: ../../pep-0550.rst:1176
msgid ""
"The ``contextvars.run_with_execution_context(ec: ExecutionContext, func, "
"*args, **kwargs)`` function, which runs *func* with the provided "
"execution context."
msgstr ""

#: ../../pep-0550.rst:1180
msgid ""
"The ``contextvars.run_with_logical_context(lc: LogicalContext, func, "
"*args, **kwargs)`` function, which runs *func* with the provided logical "
"context on top of the current execution context."
msgstr ""

#: ../../pep-0550.rst:1186
msgid "C API"
msgstr ""

#: ../../pep-0550.rst:1188
msgid ""
"``PyContextVar * PyContext_NewVar(char *desc)``: create a "
"``PyContextVar`` object."
msgstr ""

#: ../../pep-0550.rst:1191
msgid ""
"``PyObject * PyContext_GetValue(PyContextVar *, int topmost)``: return "
"the value of the variable in the current execution context."
msgstr ""

#: ../../pep-0550.rst:1194
msgid ""
"``int PyContext_SetValue(PyContextVar *, PyObject *)``: set the value of "
"the variable in the current logical context."
msgstr ""

#: ../../pep-0550.rst:1197
msgid ""
"``int PyContext_DelValue(PyContextVar *)``: delete the value of the "
"variable from the current logical context."
msgstr ""

#: ../../pep-0550.rst:1200
msgid ""
"``PyLogicalContext * PyLogicalContext_New()``: create a new empty "
"``PyLogicalContext``."
msgstr ""

#: ../../pep-0550.rst:1203
msgid ""
"``PyExecutionContext * PyExecutionContext_New()``: create a new empty "
"``PyExecutionContext``."
msgstr ""

#: ../../pep-0550.rst:1206
msgid ""
"``PyExecutionContext * PyExecutionContext_Get()``: return the current "
"execution context."
msgstr ""

#: ../../pep-0550.rst:1209
msgid ""
"``int PyContext_SetCurrent( PyExecutionContext *, PyLogicalContext *)``: "
"set the passed EC object as the current execution context for the active "
"thread state, and/or set the passed LC object as the current logical "
"context."
msgstr ""

#: ../../pep-0550.rst:1217
msgid "Design Considerations"
msgstr ""

#: ../../pep-0550.rst:1220
msgid "Should \"yield from\" leak context changes?"
msgstr ""

#: ../../pep-0550.rst:1222
msgid ""
"No.  It may be argued that ``yield from`` is semantically equivalent to "
"calling a function, and should leak context changes. However, it is not "
"possible to satisfy the following at the same time:"
msgstr ""

#: ../../pep-0550.rst:1226
msgid "``next(gen)`` *does not* leak context changes made in ``gen``, and"
msgstr ""

#: ../../pep-0550.rst:1227
msgid "``yield from gen`` *leaks* context changes made in ``gen``."
msgstr ""

#: ../../pep-0550.rst:1229
msgid ""
"The reason is that ``yield from`` can be used with a partially iterated "
"generator, which already has local context changes::"
msgstr ""

#: ../../pep-0550.rst:1251
msgid ""
"Another example would be refactoring of an explicit ``for..in yield`` "
"construct to a ``yield from`` expression.  Consider the following code::"
msgstr ""

#: ../../pep-0550.rst:1262
msgid "which we want to refactor to use ``yield from``::"
msgstr ""

#: ../../pep-0550.rst:1270
msgid ""
"The above examples illustrate that it is unsafe to refactor generator "
"code using ``yield from`` when it can leak context changes."
msgstr ""

#: ../../pep-0550.rst:1273
msgid ""
"Thus, the only well-defined and consistent behaviour is to **always** "
"isolate context changes in generators, regardless of how they are being "
"iterated."
msgstr ""

#: ../../pep-0550.rst:1279
msgid "Should ``PyThreadState_GetDict()`` use the execution context?"
msgstr ""

#: ../../pep-0550.rst:1281
msgid ""
"No. ``PyThreadState_GetDict`` is based on TLS, and changing its semantics"
" will break backwards compatibility."
msgstr ""

#: ../../pep-0550.rst:1286
msgid "PEP 521"
msgstr ""

#: ../../pep-0550.rst:1288
msgid ""
":pep:`521` proposes an alternative solution to the problem, which extends"
" the context manager protocol with two new methods: ``__suspend__()`` and"
" ``__resume__()``.  Similarly, the asynchronous context manager protocol "
"is also extended with ``__asuspend__()`` and ``__aresume__()``."
msgstr ""

#: ../../pep-0550.rst:1294
msgid ""
"This allows implementing context managers that manage non-local state, "
"which behave correctly in generators and coroutines."
msgstr ""

#: ../../pep-0550.rst:1297
msgid ""
"For example, consider the following context manager, which uses execution"
" state::"
msgstr ""

#: ../../pep-0550.rst:1312
msgid "An equivalent implementation with PEP 521::"
msgstr ""

#: ../../pep-0550.rst:1331
msgid ""
"The downside of this approach is the addition of significant new "
"complexity to the context manager protocol and the interpreter "
"implementation.  This approach is also likely to negatively impact the "
"performance of generators and coroutines."
msgstr ""

#: ../../pep-0550.rst:1336
msgid ""
"Additionally, the solution in :pep:`521` is limited to context managers, "
"and does not provide any mechanism to propagate state in asynchronous "
"tasks and callbacks."
msgstr ""

#: ../../pep-0550.rst:1342
msgid "Can Execution Context be implemented without modifying CPython?"
msgstr ""

#: ../../pep-0550.rst:1344
msgid "No."
msgstr ""

#: ../../pep-0550.rst:1346
msgid ""
"It is true that the concept of \"task-locals\" can be implemented for "
"coroutines in libraries (see, for example, [29]_ and [30]_). On the other"
" hand, generators are managed by the Python interpreter directly, and so "
"their context must also be managed by the interpreter."
msgstr ""

#: ../../pep-0550.rst:1352
msgid ""
"Furthermore, execution context cannot be implemented in a third-party "
"module at all, otherwise the standard library, including ``decimal`` "
"would not be able to rely on it."
msgstr ""

#: ../../pep-0550.rst:1358
msgid "Should we update sys.displayhook and other APIs to use EC?"
msgstr ""

#: ../../pep-0550.rst:1360
msgid ""
"APIs like redirecting stdout by overwriting ``sys.stdout``, or specifying"
" new exception display hooks by overwriting the ``sys.displayhook`` "
"function are affecting the whole Python process **by design**.  Their "
"users assume that the effect of changing them will be visible across OS "
"threads.  Therefore, we cannot just make these APIs to use the new "
"Execution Context."
msgstr ""

#: ../../pep-0550.rst:1367
msgid ""
"That said we think it is possible to design new APIs that will be context"
" aware, but that is outside of the scope of this PEP."
msgstr ""

#: ../../pep-0550.rst:1372
msgid "Greenlets"
msgstr ""

#: ../../pep-0550.rst:1374
msgid ""
"Greenlet is an alternative implementation of cooperative scheduling for "
"Python.  Although greenlet package is not part of CPython, popular "
"frameworks like gevent rely on it, and it is important that greenlet can "
"be modified to support execution contexts."
msgstr ""

#: ../../pep-0550.rst:1380
msgid ""
"Conceptually, the behaviour of greenlets is very similar to that of "
"generators, which means that similar changes around greenlet entry and "
"exit can be done to add support for execution context.  This PEP provides"
" the necessary C APIs to do that."
msgstr ""

#: ../../pep-0550.rst:1387
msgid "Context manager as the interface for modifications"
msgstr ""

#: ../../pep-0550.rst:1389
msgid ""
"This PEP concentrates on the low-level mechanics and the minimal API that"
" enables fundamental operations with execution context."
msgstr ""

#: ../../pep-0550.rst:1392
msgid ""
"For developer convenience, a high-level context manager interface may be "
"added to the ``contextvars`` module.  For example::"
msgstr ""

#: ../../pep-0550.rst:1400
msgid "Setting and restoring context variables"
msgstr ""

#: ../../pep-0550.rst:1402
msgid ""
"The ``ContextVar.delete()`` method removes the context variable from the "
"topmost logical context."
msgstr ""

#: ../../pep-0550.rst:1405
msgid ""
"If the variable is not found in the topmost logical context, a "
"``LookupError`` is raised, similarly to ``del var`` raising ``NameError``"
" when ``var`` is not in scope."
msgstr ""

#: ../../pep-0550.rst:1409
msgid ""
"This method is useful when there is a (rare) need to correctly restore "
"the state of a logical context, such as when a nested generator wants to "
"modify the logical context *temporarily*::"
msgstr ""

#: ../../pep-0550.rst:1432
msgid ""
"The above example would work correctly only if there is a way to delete "
"``var`` from the logical context in ``gen()``.  Setting it to a "
"\"previous value\" in ``__exit__()`` would mask changes made in "
"``main()`` between the iterations."
msgstr ""

#: ../../pep-0550.rst:1439
msgid "Alternative Designs for ContextVar API"
msgstr ""

#: ../../pep-0550.rst:1442
msgid "Logical Context with stacked values"
msgstr ""

#: ../../pep-0550.rst:1444
msgid ""
"By the design presented in this PEP, logical context is a simple "
"``LC({ContextVar: value, ...})`` mapping.  An alternative representation "
"is to store a stack of values for each context variable: "
"``LC({ContextVar: [val1, val2, ...], ...})``."
msgstr ""

#: ../../pep-0550.rst:1449
msgid "The ``ContextVar`` methods would then be:"
msgstr ""

#: ../../pep-0550.rst:1451
msgid ""
"``get(*, default=None)`` -- traverses the stack of logical contexts, and "
"returns the top value from the first non-empty logical context;"
msgstr ""

#: ../../pep-0550.rst:1455
msgid ""
"``push(val)`` -- pushes *val* onto the stack of values in the current "
"logical context;"
msgstr ""

#: ../../pep-0550.rst:1458
msgid ""
"``pop()`` -- pops the top value from the stack of values in the current "
"logical context."
msgstr ""

#: ../../pep-0550.rst:1461
msgid ""
"Compared to the single-value design with the ``set()`` and ``delete()`` "
"methods, the stack-based approach allows for a simpler implementation of "
"the set/restore pattern.  However, the mental burden of this approach is "
"considered to be higher, since there would be *two* stacks to consider: a"
" stack of LCs and a stack of values in each LC."
msgstr ""

#: ../../pep-0550.rst:1468
msgid "(This idea was suggested by Nathaniel Smith.)"
msgstr ""

#: ../../pep-0550.rst:1472
msgid "ContextVar \"set/reset\""
msgstr ""

#: ../../pep-0550.rst:1474
msgid ""
"Yet another approach is to return a special object from "
"``ContextVar.set()``, which would represent the modification of the "
"context variable in the current logical context::"
msgstr ""

#: ../../pep-0550.rst:1488
msgid ""
"The critical flaw in this approach is that it becomes possible to pass "
"context var \"modification objects\" into code running in a different "
"execution context, which leads to undefined side effects."
msgstr ""

#: ../../pep-0550.rst:1494
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0550.rst:1496
msgid "This proposal preserves 100% backwards compatibility."
msgstr ""

#: ../../pep-0550.rst:1500
msgid "Rejected Ideas"
msgstr ""

#: ../../pep-0550.rst:1503
msgid "Replication of threading.local() interface"
msgstr ""

#: ../../pep-0550.rst:1505
msgid ""
"Choosing the ``threading.local()``-like interface for context variables "
"was considered and rejected for the following reasons:"
msgstr ""

#: ../../pep-0550.rst:1508
msgid ""
"A survey of the standard library and Django has shown that the vast "
"majority of ``threading.local()`` uses involve a single attribute, which "
"indicates that the namespace approach is not as helpful in the field."
msgstr ""

#: ../../pep-0550.rst:1513
msgid ""
"Using ``__getattr__()`` instead of ``.get()`` for value lookup does not "
"provide any way to specify the depth of the lookup (i.e. search only the "
"top logical context)."
msgstr ""

#: ../../pep-0550.rst:1517
msgid ""
"Single-value ``ContextVar`` is easier to reason about in terms of "
"visibility.  Suppose ``ContextVar()`` is a namespace, and the consider "
"the following::"
msgstr ""

#: ../../pep-0550.rst:1539
msgid ""
"The above example demonstrates that reasoning about the visibility of "
"different attributes of the same context var is not trivial."
msgstr ""

#: ../../pep-0550.rst:1542
msgid ""
"Single-value ``ContextVar`` allows straightforward implementation of the "
"lookup cache;"
msgstr ""

#: ../../pep-0550.rst:1545
msgid ""
"Single-value ``ContextVar`` interface allows the C-API to be simple and "
"essentially the same as the Python API."
msgstr ""

#: ../../pep-0550.rst:1548
msgid "See also the mailing list discussion: [26]_, [27]_."
msgstr ""

#: ../../pep-0550.rst:1552
msgid "Coroutines not leaking context changes by default"
msgstr ""

#: ../../pep-0550.rst:1554
msgid ""
"In V4 (`Version History`_) of this PEP, coroutines were considered to "
"behave exactly like generators with respect to the execution context: "
"changes in awaited coroutines were not visible in the outer coroutine."
msgstr ""

#: ../../pep-0550.rst:1558
msgid ""
"This idea was rejected on the grounds that is breaks the semantic "
"similarity of the task and thread models, and, more specifically, makes "
"it impossible to reliably implement asynchronous context managers that "
"modify context vars, since ``__aenter__`` is a coroutine."
msgstr ""

#: ../../pep-0550.rst:1566
msgid "Appendix: HAMT Performance Analysis"
msgstr ""

#: ../../pep-0550.rst:1572
msgid "Figure 1.  Benchmark code can be found here: [9]_."
msgstr ""

#: ../../pep-0550.rst:1574
msgid "The above chart demonstrates that:"
msgstr ""

#: ../../pep-0550.rst:1576
msgid "HAMT displays near O(1) performance for all benchmarked dictionary sizes."
msgstr ""

#: ../../pep-0550.rst:1579
msgid "``dict.copy()`` becomes very slow around 100 items."
msgstr ""

#: ../../pep-0550.rst:1585
msgid "Figure 2.  Benchmark code can be found here: [10]_."
msgstr ""

#: ../../pep-0550.rst:1587
#, python-format
msgid ""
"Figure 2 compares the lookup costs of ``dict`` versus a HAMT-based "
"immutable mapping.  HAMT lookup time is 30-40% slower than Python dict "
"lookups on average, which is a very good result, considering that the "
"latter is very well optimized."
msgstr ""

#: ../../pep-0550.rst:1592
msgid ""
"There is research [8]_ showing that there are further possible "
"improvements to the performance of HAMT."
msgstr ""

#: ../../pep-0550.rst:1595
msgid "The reference implementation of HAMT for CPython can be found here: [7]_."
msgstr ""

#: ../../pep-0550.rst:1600
msgid "Acknowledgments"
msgstr ""

#: ../../pep-0550.rst:1602
msgid ""
"Thanks to Victor Petrovykh for countless discussions around the topic and"
" PEP proofreading and edits."
msgstr ""

#: ../../pep-0550.rst:1605
msgid ""
"Thanks to Nathaniel Smith for proposing the ``ContextVar`` design [17]_ "
"[18]_, for pushing the PEP towards a more complete design, and coming up "
"with the idea of having a stack of contexts in the thread state."
msgstr ""

#: ../../pep-0550.rst:1610
msgid ""
"Thanks to Nick Coghlan for numerous suggestions and ideas on the mailing "
"list, and for coming up with a case that cause the complete rewrite of "
"the initial PEP version [19]_."
msgstr ""

#: ../../pep-0550.rst:1616
msgid "Version History"
msgstr ""

#: ../../pep-0550.rst:1618
msgid "Initial revision, posted on 11-Aug-2017 [20]_."
msgstr ""

#: ../../pep-0550.rst:1620
msgid "V2 posted on 15-Aug-2017 [21]_."
msgstr ""

#: ../../pep-0550.rst:1622
msgid ""
"The fundamental limitation that caused a complete redesign of the first "
"version was that it was not possible to implement an iterator that would "
"interact with the EC in the same way as generators (see [19]_.)"
msgstr ""

#: ../../pep-0550.rst:1627
msgid ""
"Version 2 was a complete rewrite, introducing new terminology (Local "
"Context, Execution Context, Context Item) and new APIs."
msgstr ""

#: ../../pep-0550.rst:1630
msgid "V3 posted on 18-Aug-2017 [22]_."
msgstr ""

#: ../../pep-0550.rst:1632
msgid "Updates:"
msgstr ""

#: ../../pep-0550.rst:1634
msgid ""
"Local Context was renamed to Logical Context.  The term \"local\" was "
"ambiguous and conflicted with local name scopes."
msgstr ""

#: ../../pep-0550.rst:1637
msgid ""
"Context Item was renamed to Context Key, see the thread with Nick "
"Coghlan, Stefan Krah, and Yury Selivanov [23]_ for details."
msgstr ""

#: ../../pep-0550.rst:1640
msgid ""
"Context Item get cache design was adjusted, per Nathaniel Smith's idea in"
" [25]_."
msgstr ""

#: ../../pep-0550.rst:1643
msgid ""
"Coroutines are created without a Logical Context; ceval loop no longer "
"needs to special case the ``await`` expression (proposed by Nick Coghlan "
"in [24]_.)"
msgstr ""

#: ../../pep-0550.rst:1647
msgid "V4 posted on 25-Aug-2017 [31]_."
msgstr ""

#: ../../pep-0550.rst:1649
msgid "The specification section has been completely rewritten."
msgstr ""

#: ../../pep-0550.rst:1651
msgid ""
"Coroutines now have their own Logical Context.  This means there is no "
"difference between coroutines, generators, and asynchronous generators "
"w.r.t. interaction with the Execution Context."
msgstr ""

#: ../../pep-0550.rst:1656
msgid "Context Key renamed to Context Var."
msgstr ""

#: ../../pep-0550.rst:1658
msgid ""
"Removed the distinction between generators and coroutines with respect to"
" logical context isolation."
msgstr ""

#: ../../pep-0550.rst:1661
msgid "V5 posted on 01-Sep-2017: the current version."
msgstr ""

#: ../../pep-0550.rst:1663
msgid ""
"Coroutines have no logical context by default (a revert to the V3 "
"semantics).  Read about the motivation in the `Coroutines not leaking "
"context changes by default`_ section."
msgstr ""

#: ../../pep-0550.rst:1667
msgid ""
"The `High-Level Specification`_ section was also updated (specifically "
"Generators and Coroutines subsections)."
msgstr ""

#: ../../pep-0550.rst:1670
msgid ""
"All APIs have been placed to the ``contextvars`` module, and the factory "
"functions were changed to class constructors (``ContextVar``, "
"``ExecutionContext``, and ``LogicalContext``). Thanks to Nick for the "
"idea [33]_."
msgstr ""

#: ../../pep-0550.rst:1675
msgid ""
"``ContextVar.lookup()`` got renamed back to ``ContextVar.get()`` and "
"gained the ``topmost`` and ``default`` keyword arguments. Added "
"``ContextVar.delete()``."
msgstr ""

#: ../../pep-0550.rst:1679
msgid "See Guido's comment in [32]_."
msgstr ""

#: ../../pep-0550.rst:1681
msgid ""
"New ``ExecutionContext.vars()`` method.  Read about it in the "
"`Enumerating context vars`_ section."
msgstr ""

#: ../../pep-0550.rst:1684
msgid "Fixed ``ContextVar.get()`` cache bug (thanks Nathaniel!)."
msgstr ""

#: ../../pep-0550.rst:1686
msgid ""
"New `Rejected Ideas`_, `Should \"yield from\" leak context changes?`_, "
"`Alternative Designs for ContextVar API`_, `Setting and restoring context"
" variables`_, and `Context manager as the interface for modifications`_ "
"sections."
msgstr ""

#: ../../pep-0550.rst:1694
msgid "References"
msgstr ""

#: ../../pep-0550.rst:1696
msgid "https://blog.golang.org/context"
msgstr ""

#: ../../pep-0550.rst:1698
msgid ""
"https://msdn.microsoft.com/en-"
"us/library/system.threading.executioncontext.aspx"
msgstr ""

#: ../../pep-0550.rst:1700
msgid "https://github.com/numpy/numpy/issues/9444"
msgstr ""

#: ../../pep-0550.rst:1702
msgid "http://bugs.python.org/issue31179"
msgstr ""

#: ../../pep-0550.rst:1704
msgid "https://en.wikipedia.org/wiki/Hash_array_mapped_trie"
msgstr ""

#: ../../pep-0550.rst:1706
msgid ""
"http://blog.higher-order.net/2010/08/16/assoc-and-clojures-"
"persistenthashmap-part-ii.html"
msgstr ""

#: ../../pep-0550.rst:1708
msgid "https://github.com/1st1/cpython/tree/hamt"
msgstr ""

#: ../../pep-0550.rst:1710
msgid "https://michael.steindorfer.name/publications/oopsla15.pdf"
msgstr ""

#: ../../pep-0550.rst:1712
msgid "https://gist.github.com/1st1/9004813d5576c96529527d44c5457dcd"
msgstr ""

#: ../../pep-0550.rst:1714
msgid "https://gist.github.com/1st1/dbe27f2e14c30cce6f0b5fddfc8c437e"
msgstr ""

#: ../../pep-0550.rst:1716
msgid "https://github.com/1st1/cpython/tree/pep550"
msgstr ""

#: ../../pep-0550.rst:1718
msgid "https://www.python.org/dev/peps/pep-0492/#async-await"
msgstr ""

#: ../../pep-0550.rst:1720
msgid "https://github.com/MagicStack/uvloop/blob/master/examples/bench/echoserver.py"
msgstr ""

#: ../../pep-0550.rst:1722
msgid "https://github.com/MagicStack/pgbench"
msgstr ""

#: ../../pep-0550.rst:1724
msgid "https://github.com/python/performance"
msgstr ""

#: ../../pep-0550.rst:1726
msgid "https://gist.github.com/1st1/6b7a614643f91ead3edf37c4451a6b4c"
msgstr ""

#: ../../pep-0550.rst:1728
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046752.html"
msgstr ""

#: ../../pep-0550.rst:1730
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046772.html"
msgstr ""

#: ../../pep-0550.rst:1732
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046775.html"
msgstr ""

#: ../../pep-0550.rst:1734
msgid "https://github.com/python/peps/blob/e8a06c9a790f39451d9e99e203b13b3ad73a1d01/pep-0550.rst"
msgstr ""

#: ../../pep-0550.rst:1736
msgid "https://github.com/python/peps/blob/e3aa3b2b4e4e9967d28a10827eed1e9e5960c175/pep-0550.rst"
msgstr ""

#: ../../pep-0550.rst:1738
msgid "https://github.com/python/peps/blob/287ed87bb475a7da657f950b353c71c1248f67e7/pep-0550.rst"
msgstr ""

#: ../../pep-0550.rst:1740
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046801.html"
msgstr ""

#: ../../pep-0550.rst:1742
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046790.html"
msgstr ""

#: ../../pep-0550.rst:1744
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046786.html"
msgstr ""

#: ../../pep-0550.rst:1746
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046888.html"
msgstr ""

#: ../../pep-0550.rst:1748
msgid "https://mail.python.org/pipermail/python-ideas/2017-August/046889.html"
msgstr ""

#: ../../pep-0550.rst:1750
msgid "https://docs.python.org/3/library/decimal.html#decimal.Context.abs"
msgstr ""

#: ../../pep-0550.rst:1752
msgid "https://curio.readthedocs.io/en/latest/reference.html#task-local-storage"
msgstr ""

#: ../../pep-0550.rst:1754
msgid "https://docs.atlassian.com/aiolocals/latest/usage.html"
msgstr ""

#: ../../pep-0550.rst:1756
msgid "https://github.com/python/peps/blob/1b8728ded7cde9df0f9a24268574907fafec6d5e/pep-0550.rst"
msgstr ""

#: ../../pep-0550.rst:1758
msgid "https://mail.python.org/pipermail/python-dev/2017-August/149020.html"
msgstr ""

#: ../../pep-0550.rst:1760
msgid "https://mail.python.org/pipermail/python-dev/2017-August/149043.html"
msgstr ""

#: ../../pep-0550.rst:1764
msgid "Copyright"
msgstr ""

#: ../../pep-0550.rst:1766
msgid "This document has been placed in the public domain."
msgstr ""

