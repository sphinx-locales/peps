# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0509.txt
msgid "PEP"
msgstr ""

#: ../../pep-0509.txt:1
msgid "509"
msgstr ""

#: ../../pep-0509.txt
msgid "Title"
msgstr ""

#: ../../pep-0509.txt:2
msgid "Add a private version to dict"
msgstr ""

#: ../../pep-0509.txt
msgid "Author"
msgstr ""

#: ../../pep-0509.txt:5
msgid "Victor Stinner <vstinner@python.org>"
msgstr ""

#: ../../pep-0509.txt
msgid "Status"
msgstr ""

#: ../../pep-0509.txt:6
msgid "Final"
msgstr ""

#: ../../pep-0509.txt
msgid "Type"
msgstr ""

#: ../../pep-0509.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0509.txt
msgid "Created"
msgstr ""

#: ../../pep-0509.txt:9
msgid "04-Jan-2016"
msgstr ""

#: ../../pep-0509.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0509.txt:10
msgid "3.6"
msgstr ""

#: ../../pep-0509.txt:14
msgid "Abstract"
msgstr ""

#: ../../pep-0509.txt:16
msgid ""
"Add a new private version to the builtin ``dict`` type, incremented at "
"each dictionary creation and at each dictionary change, to implement fast"
" guards on namespaces."
msgstr ""

#: ../../pep-0509.txt:22
msgid "Rationale"
msgstr ""

#: ../../pep-0509.txt:24
msgid ""
"In Python, the builtin ``dict`` type is used by many instructions. For "
"example, the ``LOAD_GLOBAL`` instruction looks up a variable in the "
"global namespace, or in the builtins namespace (two dict lookups). Python"
" uses ``dict`` for the builtins namespace, globals namespace, type "
"namespaces, instance namespaces, etc. The local namespace (function "
"namespace) is usually optimized to an array, but it can be a dict too."
msgstr ""

#: ../../pep-0509.txt:31
msgid ""
"Python is hard to optimize because almost everything is mutable: builtin "
"functions, function code, global variables, local variables, ... can be "
"modified at runtime. Implementing optimizations respecting the Python "
"semantics requires to detect when \"something changes\": we will call "
"these checks \"guards\"."
msgstr ""

#: ../../pep-0509.txt:37
msgid ""
"The speedup of optimizations depends on the speed of guard checks. This "
"PEP proposes to add a private version to dictionaries to implement fast "
"guards on namespaces."
msgstr ""

#: ../../pep-0509.txt:41
msgid ""
"Dictionary lookups can be skipped if the version does not change, which "
"is the common case for most namespaces. The version is globally unique, "
"so checking the version is also enough to verify that the namespace "
"dictionary was not replaced with a new dictionary."
msgstr ""

#: ../../pep-0509.txt:46
msgid ""
"When the dictionary version does not change, the performance of a guard "
"does not depend on the number of watched dictionary entries: the "
"complexity is O(1)."
msgstr ""

#: ../../pep-0509.txt:50
msgid ""
"Example of optimization: copy the value of a global variable to function "
"constants.  This optimization requires a guard on the global variable to "
"check if it was modified after it was copied. If the global variable is "
"not modified, the function uses the cached copy. If the global variable "
"is modified, the function uses a regular lookup, and maybe also "
"deoptimizes the function (to remove the overhead of the guard check for "
"next function calls)."
msgstr ""

#: ../../pep-0509.txt:58
msgid ""
"See the `PEP 510 -- Specialized functions with guards "
"<https://www.python.org/dev/peps/pep-0510/>`_ for concrete usage of "
"guards to specialize functions and for a more general rationale on Python"
" static optimizers."
msgstr ""

#: ../../pep-0509.txt:65
msgid "Guard example"
msgstr ""

#: ../../pep-0509.txt:67
msgid ""
"Pseudo-code of a fast guard to check if a dictionary entry was modified "
"(created, updated or deleted) using a hypothetical "
"``dict_get_version(dict)`` function::"
msgstr ""

#: ../../pep-0509.txt:103
msgid "Usage of the dict version"
msgstr ""

#: ../../pep-0509.txt:106
msgid "Speedup method calls"
msgstr ""

#: ../../pep-0509.txt:108
msgid ""
"Yury Selivanov wrote a `patch to optimize method calls "
"<https://bugs.python.org/issue26110>`_. The patch depends on the "
"`\"implement per-opcode cache in ceval\" "
"<https://bugs.python.org/issue26219>`_ patch which requires dictionary "
"versions to invalidate the cache if the globals dictionary or the "
"builtins dictionary has been modified."
msgstr ""

#: ../../pep-0509.txt:115
msgid ""
"The cache also requires that the dictionary version is globally unique. "
"It is possible to define a function in a namespace and call it in a "
"different namespace, using ``exec()`` with the *globals* parameter for "
"example. In this case, the globals dictionary was replaced and the cache "
"must also be invalidated."
msgstr ""

#: ../../pep-0509.txt:123
msgid "Specialized functions using guards"
msgstr ""

#: ../../pep-0509.txt:125
msgid ""
"The `PEP 510 -- Specialized functions with guards "
"<https://www.python.org/dev/peps/pep-0510/>`_ proposes an API to support "
"specialized functions with guards. It allows to implement static "
"optimizers for Python without breaking the Python semantics."
msgstr ""

#: ../../pep-0509.txt:130
msgid ""
"The `fatoptimizer <http://fatoptimizer.readthedocs.org/>`_ of the `FAT "
"Python <http://faster-cpython.readthedocs.org/fat_python.html>`_ project "
"is an example of a static Python optimizer. It implements many "
"optimizations which require guards on namespaces:"
msgstr ""

#: ../../pep-0509.txt:135
msgid ""
"Call pure builtins: to replace ``len(\"abc\")`` with ``3``, guards on "
"``builtins.__dict__['len']`` and ``globals()['len']`` are required"
msgstr ""

#: ../../pep-0509.txt:137
msgid ""
"Loop unrolling: to unroll the loop ``for i in range(...): ...``, guards "
"on ``builtins.__dict__['range']`` and ``globals()['range']`` are required"
msgstr ""

#: ../../pep-0509.txt:140
msgid "etc."
msgstr ""

#: ../../pep-0509.txt:144
msgid "Pyjion"
msgstr ""

#: ../../pep-0509.txt:146
msgid ""
"According of Brett Cannon, one of the two main developers of Pyjion, "
"Pyjion can benefit from dictionary version to implement optimizations."
msgstr ""

#: ../../pep-0509.txt:149
msgid ""
"`Pyjion <https://github.com/Microsoft/Pyjion>`_ is a JIT compiler for "
"Python based upon CoreCLR (Microsoft .NET Core runtime)."
msgstr ""

#: ../../pep-0509.txt:154
msgid "Cython"
msgstr ""

#: ../../pep-0509.txt:156
msgid "Cython can benefit from dictionary version to implement optimizations."
msgstr ""

#: ../../pep-0509.txt:158
msgid ""
"`Cython <http://cython.org/>`_ is an optimising static compiler for both "
"the Python programming language and the extended Cython programming "
"language."
msgstr ""

#: ../../pep-0509.txt:164
msgid "Unladen Swallow"
msgstr ""

#: ../../pep-0509.txt:166
msgid ""
"Even if dictionary version was not explicitly mentioned, optimizing "
"globals and builtins lookup was part of the Unladen Swallow plan: "
"\"Implement one of the several proposed schemes for speeding lookups of "
"globals and builtins.\" (source: `Unladen Swallow ProjectPlan "
"<https://code.google.com/p/unladen-swallow/wiki/ProjectPlan>`_)."
msgstr ""

#: ../../pep-0509.txt:172
msgid ""
"Unladen Swallow is a fork of CPython 2.6.1 adding a JIT compiler "
"implemented with LLVM. The project stopped in 2011: `Unladen Swallow "
"Retrospective <http://qinsb.blogspot.com.au/2011/03/unladen-swallow-"
"retrospective.html>`_."
msgstr ""

#: ../../pep-0509.txt:179
msgid "Changes"
msgstr ""

#: ../../pep-0509.txt:181
msgid ""
"Add a ``ma_version_tag`` field to the ``PyDictObject`` structure with the"
" C type ``PY_UINT64_T``, 64-bit unsigned integer. Add also a global "
"dictionary version."
msgstr ""

#: ../../pep-0509.txt:185
msgid ""
"Each time a dictionary is created, the global version is incremented and "
"the dictionary version is initialized to the global version."
msgstr ""

#: ../../pep-0509.txt:188
msgid ""
"Each time the dictionary content is modified, the global version must be "
"incremented and copied to the dictionary version. Dictionary methods "
"which can modify its content:"
msgstr ""

#: ../../pep-0509.txt:192
msgid "``clear()``"
msgstr ""

#: ../../pep-0509.txt:193
msgid "``pop(key)``"
msgstr ""

#: ../../pep-0509.txt:194
msgid "``popitem()``"
msgstr ""

#: ../../pep-0509.txt:195
msgid "``setdefault(key, value)``"
msgstr ""

#: ../../pep-0509.txt:196
msgid "``__delitem__(key)``"
msgstr ""

#: ../../pep-0509.txt:197
msgid "``__setitem__(key, value)``"
msgstr ""

#: ../../pep-0509.txt:198
msgid "``update(...)``"
msgstr ""

#: ../../pep-0509.txt:200
msgid ""
"The choice of increasing or not the version when a dictionary method does"
" not change its content is left to the Python implementation. A Python "
"implementation can decide to not increase the version to avoid dictionary"
" lookups in guards. Examples of cases when dictionary methods don't "
"modify its content:"
msgstr ""

#: ../../pep-0509.txt:206
msgid "``clear()`` if the dict is already empty"
msgstr ""

#: ../../pep-0509.txt:207
msgid "``pop(key)`` if the key does not exist"
msgstr ""

#: ../../pep-0509.txt:208
msgid "``popitem()`` if the dict is empty"
msgstr ""

#: ../../pep-0509.txt:209
msgid "``setdefault(key, value)`` if the key already exists"
msgstr ""

#: ../../pep-0509.txt:210
msgid "``__delitem__(key)`` if the key does not exist"
msgstr ""

#: ../../pep-0509.txt:211
msgid ""
"``__setitem__(key, value)`` if the new value is identical to the current "
"value"
msgstr ""

#: ../../pep-0509.txt:213
msgid ""
"``update()`` if called without argument or if new values are identical to"
" current values"
msgstr ""

#: ../../pep-0509.txt:216
msgid ""
"Setting a key to a new value equals to the old value is also considered "
"as an operation modifying the dictionary content."
msgstr ""

#: ../../pep-0509.txt:219
msgid ""
"Two different empty dictionaries must have a different version to be able"
" to identify a dictionary just by its version. It allows to verify in a "
"guard that a namespace was not replaced without storing a strong "
"reference to the dictionary. Using a borrowed reference does not work: if"
" the old dictionary is destroyed, it is possible that a new dictionary is"
" allocated at the same memory address. By the way, dictionaries don't "
"support weak references."
msgstr ""

#: ../../pep-0509.txt:227
msgid ""
"The version increase must be atomic. In CPython, the Global Interpreter "
"Lock (GIL) already protects ``dict`` methods to make changes atomic."
msgstr ""

#: ../../pep-0509.txt:230
msgid "Example using a hypothetical ``dict_get_version(dict)`` function::"
msgstr ""

#: ../../pep-0509.txt:245
msgid ""
"The field is called ``ma_version_tag``, rather than ``ma_version``, to "
"suggest to compare it using ``version_tag == old_version_tag``, rather "
"than ``version <= old_version`` which becomes wrong after an integer "
"overflow."
msgstr ""

#: ../../pep-0509.txt:252
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0509.txt:254
msgid ""
"Since the ``PyDictObject`` structure is not part of the stable ABI and "
"the new dictionary version not exposed at the Python scope, changes are "
"backward compatible."
msgstr ""

#: ../../pep-0509.txt:260
msgid "Implementation and Performance"
msgstr ""

#: ../../pep-0509.txt:262
msgid ""
"The `issue #26058: PEP 509: Add ma_version_tag to PyDictObject "
"<https://bugs.python.org/issue26058>`_ contains a patch implementing this"
" PEP."
msgstr ""

#: ../../pep-0509.txt:266
msgid ""
"On pybench and timeit microbenchmarks, the patch does not seem to add any"
" overhead on dictionary operations. For example, the following timeit "
"micro-benchmarks takes 318 nanoseconds before and after the change::"
msgstr ""

#: ../../pep-0509.txt:272
msgid ""
"When the version does not change, ``PyDict_GetItem()`` takes 14.8 ns for "
"a dictionary lookup, whereas a guard check only takes 3.8 ns. Moreover, a"
" guard can watch for multiple keys. For example, for an optimization "
"using 10 global variables in a function, 10 dictionary lookups costs 148 "
"ns, whereas the guard still only costs 3.8 ns when the version does not "
"change (39x as fast)."
msgstr ""

#: ../../pep-0509.txt:279
msgid ""
"The `fat module "
"<http://fatoptimizer.readthedocs.org/en/latest/fat.html>`_ implements "
"such guards: ``fat.GuardDict`` is based on the dictionary version."
msgstr ""

#: ../../pep-0509.txt:285
msgid "Integer overflow"
msgstr ""

#: ../../pep-0509.txt:287
msgid ""
"The implementation uses the C type ``PY_UINT64_T`` to store the version: "
"a 64 bits unsigned integer. The C code uses ``version++``. On integer "
"overflow, the version is wrapped to ``0`` (and then continues to be "
"incremented) according to the C standard."
msgstr ""

#: ../../pep-0509.txt:292
msgid ""
"After an integer overflow, a guard can succeed whereas the watched "
"dictionary key was modified. The bug only occurs at a guard check if "
"there are exactly ``2 ** 64`` dictionary creations or modifications since"
" the previous guard check."
msgstr ""

#: ../../pep-0509.txt:297
msgid ""
"If a dictionary is modified every nanosecond, ``2 ** 64`` modifications "
"takes longer than 584 years. Using a 32-bit version, it only takes 4 "
"seconds. That's why a 64-bit unsigned type is also used on 32-bit "
"systems. A dictionary lookup at the C level takes 14.8 ns."
msgstr ""

#: ../../pep-0509.txt:302
msgid "A risk of a bug every 584 years is acceptable."
msgstr ""

#: ../../pep-0509.txt:306
msgid "Alternatives"
msgstr ""

#: ../../pep-0509.txt:309
msgid "Expose the version at Python level as a read-only __version__ property"
msgstr ""

#: ../../pep-0509.txt:311
msgid ""
"The first version of the PEP proposed to expose the dictionary version as"
" a read-only ``__version__`` property at Python level, and also to add "
"the property to ``collections.UserDict`` (since this type must mimic the "
"``dict`` API)."
msgstr ""

#: ../../pep-0509.txt:316
msgid "There are multiple issues:"
msgstr ""

#: ../../pep-0509.txt:318
msgid ""
"To be consistent and avoid bad surprises, the version must be added to "
"all mapping types. Implementing a new mapping type would require extra "
"work for no benefit, since the version is only required on the ``dict`` "
"type in practice."
msgstr ""

#: ../../pep-0509.txt:322
msgid ""
"All Python implementations would have to implement this new property, it "
"gives more work to other implementations, whereas they may not use the "
"dictionary version at all."
msgstr ""

#: ../../pep-0509.txt:325
msgid ""
"Exposing the dictionary version at the Python level can lead the false "
"assumption on performances. Checking ``dict.__version__`` at the Python "
"level is not faster than a dictionary lookup. A dictionary lookup in "
"Python has a cost of 48.7 ns and checking the version has a cost of 47.5 "
"ns, the difference is only 1.2 ns (3%)::"
msgstr ""

#: ../../pep-0509.txt:337
msgid ""
"The ``__version__`` can be wrapped on integer overflow. It is error "
"prone: using ``dict.__version__ <= guard_version`` is wrong, "
"``dict.__version__ == guard_version`` must be used instead to reduce the "
"risk of bug on integer overflow (even if the integer overflow is unlikely"
" in practice)."
msgstr ""

#: ../../pep-0509.txt:343
msgid "Mandatory bikeshedding on the property name:"
msgstr ""

#: ../../pep-0509.txt:345
msgid ""
"``__cache_token__``: name proposed by Nick Coghlan, name coming from "
"`abc.get_cache_token() "
"<https://docs.python.org/3/library/abc.html#abc.get_cache_token>`_."
msgstr ""

#: ../../pep-0509.txt:348
msgid "``__version__``"
msgstr ""

#: ../../pep-0509.txt:349
msgid "``__version_tag__``"
msgstr ""

#: ../../pep-0509.txt:350
msgid "``__timestamp__``"
msgstr ""

#: ../../pep-0509.txt:354
msgid "Add a version to each dict entry"
msgstr ""

#: ../../pep-0509.txt:356
msgid ""
"A single version per dictionary requires to keep a strong reference to "
"the value which can keep the value alive longer than expected. If we add "
"also a version per dictionary entry, the guard can only store the entry "
"version (a simple integer) to avoid the strong reference to the value: "
"only strong references to the dictionary and to the key are needed."
msgstr ""

#: ../../pep-0509.txt:362
msgid ""
"Changes: add a ``me_version_tag`` field to the ``PyDictKeyEntry`` "
"structure, the field has the C type ``PY_UINT64_T``. When a key is "
"created or modified, the entry version is set to the dictionary version "
"which is incremented at any change (create, modify, delete)."
msgstr ""

#: ../../pep-0509.txt:367
msgid ""
"Pseudo-code of a fast guard to check if a dictionary key was modified "
"using hypothetical ``dict_get_version(dict)`` and "
"``dict_get_entry_version(dict)`` functions::"
msgstr ""

#: ../../pep-0509.txt:402
msgid ""
"The main drawback of this option is the impact on the memory footprint. "
"It increases the size of each dictionary entry, so the overhead depends "
"on the number of buckets (dictionary entries, used or not used). For "
"example, it increases the size of each dictionary entry by 8 bytes on "
"64-bit system."
msgstr ""

#: ../../pep-0509.txt:408
msgid ""
"In Python, the memory footprint matters and the trend is to reduce it. "
"Examples:"
msgstr ""

#: ../../pep-0509.txt:411
msgid ""
"`PEP 393 -- Flexible String Representation "
"<https://www.python.org/dev/peps/pep-0393/>`_"
msgstr ""

#: ../../pep-0509.txt:413
msgid ""
"`PEP 412 -- Key-Sharing Dictionary "
"<https://www.python.org/dev/peps/pep-0412/>`_"
msgstr ""

#: ../../pep-0509.txt:418
msgid "Add a new dict subtype"
msgstr ""

#: ../../pep-0509.txt:420
msgid ""
"Add a new ``verdict`` type, subtype of ``dict``. When guards are needed, "
"use the ``verdict`` for namespaces (module namespace, type namespace, "
"instance namespace, etc.) instead of ``dict``."
msgstr ""

#: ../../pep-0509.txt:424
msgid ""
"Leave the ``dict`` type unchanged to not add any overhead (CPU, memory "
"footprint) when guards are not used."
msgstr ""

#: ../../pep-0509.txt:427
msgid ""
"Technical issue: a lot of C code in the wild, including CPython core, "
"expecting the exact ``dict`` type. Issues:"
msgstr ""

#: ../../pep-0509.txt:430
msgid ""
"``exec()`` requires a ``dict`` for globals and locals. A lot of code use "
"``globals={}``. It is not possible to cast the ``dict`` to a ``dict`` "
"subtype because the caller expects the ``globals`` parameter to be "
"modified (``dict`` is mutable)."
msgstr ""

#: ../../pep-0509.txt:434
msgid ""
"C functions call directly ``PyDict_xxx()`` functions, instead of calling "
"``PyObject_xxx()`` if the object is a ``dict`` subtype"
msgstr ""

#: ../../pep-0509.txt:436
msgid ""
"``PyDict_CheckExact()`` check fails on ``dict`` subtype, whereas some "
"functions require the exact ``dict`` type."
msgstr ""

#: ../../pep-0509.txt:438
msgid ""
"``Python/ceval.c`` does not completely supports dict subtypes for "
"namespaces"
msgstr ""

#: ../../pep-0509.txt:442
msgid "The ``exec()`` issue is a blocker issue."
msgstr ""

#: ../../pep-0509.txt:444
msgid "Other issues:"
msgstr ""

#: ../../pep-0509.txt:446
msgid ""
"The garbage collector has a special code to \"untrack\" ``dict`` "
"instances. If a ``dict`` subtype is used for namespaces, the garbage "
"collector can be unable to break some reference cycles."
msgstr ""

#: ../../pep-0509.txt:449
msgid ""
"Some functions have a fast-path for ``dict`` which would not be taken for"
" ``dict`` subtypes, and so it would make Python a little bit slower."
msgstr ""

#: ../../pep-0509.txt:455
msgid "Prior Art"
msgstr ""

#: ../../pep-0509.txt:458
msgid "Method cache and type version tag"
msgstr ""

#: ../../pep-0509.txt:460
msgid ""
"In 2007, Armin Rigo wrote a patch to implement a cache of methods. It was"
" merged into Python 2.6.  The patch adds a \"type attribute cache version"
" tag\" (``tp_version_tag``) and a \"valid version tag\" flag to types "
"(the ``PyTypeObject`` structure)."
msgstr ""

#: ../../pep-0509.txt:465
msgid "The type version tag is not exposed at the Python level."
msgstr ""

#: ../../pep-0509.txt:467
msgid ""
"The version tag has the C type ``unsigned int``. The cache is a global "
"hash table of 4096 entries, shared by all types. The cache is global to "
"\"make it fast, have a deterministic and low memory footprint, and be "
"easy to invalidate\". Each cache entry has a version tag. A global "
"version tag is used to create the next version tag, it also has the C "
"type ``unsigned int``."
msgstr ""

#: ../../pep-0509.txt:474
msgid ""
"By default, a type has its \"valid version tag\" flag cleared to indicate"
" that the version tag is invalid. When the first method of the type is "
"cached, the version tag and the \"valid version tag\" flag are set. When "
"a type is modified, the \"valid version tag\" flag of the type and its "
"subclasses is cleared. Later, when a cache entry of these types is used, "
"the entry is removed because its version tag is outdated."
msgstr ""

#: ../../pep-0509.txt:481
msgid ""
"On integer overflow, the whole cache is cleared and the global version "
"tag is reset to ``0``."
msgstr ""

#: ../../pep-0509.txt:484
msgid ""
"See `Method cache (issue #1685986) "
"<https://bugs.python.org/issue1685986>`_ and `Armin's method cache "
"optimization updated for Python 2.6 (issue #1700288) "
"<https://bugs.python.org/issue1700288>`_."
msgstr ""

#: ../../pep-0509.txt:491
msgid "Globals / builtins cache"
msgstr ""

#: ../../pep-0509.txt:493
msgid ""
"In 2010, Antoine Pitrou proposed a `Globals / builtins cache (issue "
"#10401) <http://bugs.python.org/issue10401>`_ which adds a private "
"``ma_version`` field to the ``PyDictObject`` structure (``dict`` type), "
"the field has the C type ``Py_ssize_t``."
msgstr ""

#: ../../pep-0509.txt:498
msgid ""
"The patch adds a \"global and builtin cache\" to functions and frames, "
"and changes ``LOAD_GLOBAL`` and ``STORE_GLOBAL`` instructions to use the "
"cache."
msgstr ""

#: ../../pep-0509.txt:502
msgid "The change on the ``PyDictObject`` structure is very similar to this PEP."
msgstr ""

#: ../../pep-0509.txt:507
msgid "Cached globals+builtins lookup"
msgstr ""

#: ../../pep-0509.txt:509
msgid ""
"In 2006, Andrea Griffini proposed a patch implementing a `Cached "
"globals+builtins lookup optimization "
"<https://bugs.python.org/issue1616125>`_.  The patch adds a private "
"``timestamp`` field to the ``PyDictObject`` structure (``dict`` type), "
"the field has the C type ``size_t``."
msgstr ""

#: ../../pep-0509.txt:515
msgid ""
"Thread on python-dev: `About dictionary lookup caching "
"<https://mail.python.org/pipermail/python-"
"dev/2006-December/070348.html>`_ (December 2006)."
msgstr ""

#: ../../pep-0509.txt:521
msgid "Guard against changing dict during iteration"
msgstr ""

#: ../../pep-0509.txt:523
msgid ""
"In 2013, Serhiy Storchaka proposed `Guard against changing dict during "
"iteration (issue #19332) <https://bugs.python.org/issue19332>`_ which "
"adds a ``ma_count`` field to the ``PyDictObject`` structure (``dict`` "
"type), the field has the C type ``size_t``.  This field is incremented "
"when the dictionary is modified."
msgstr ""

#: ../../pep-0509.txt:531
msgid "PySizer"
msgstr ""

#: ../../pep-0509.txt:533
msgid ""
"`PySizer <http://pysizer.8325.org/>`_: a memory profiler for Python, "
"Google Summer of Code 2005 project by Nick Smallbone."
msgstr ""

#: ../../pep-0509.txt:536
msgid ""
"This project has a patch for CPython 2.4 which adds ``key_time`` and "
"``value_time`` fields to dictionary entries. It uses a global process-"
"wide counter for dictionaries, incremented each time that a dictionary is"
" modified. The times are used to decide when child objects first appeared"
" in their parent objects."
msgstr ""

#: ../../pep-0509.txt:544
msgid "Discussion"
msgstr ""

#: ../../pep-0509.txt:546
msgid "Thread on the mailing lists:"
msgstr ""

#: ../../pep-0509.txt:548
msgid ""
"python-dev: `Updated PEP 509 <https://mail.python.org/pipermail/python-"
"dev/2016-April/144250.html>`_"
msgstr ""

#: ../../pep-0509.txt:550
msgid ""
"python-dev: `RFC: PEP 509: Add a private version to dict "
"<https://mail.python.org/pipermail/python-dev/2016-April/144137.html>`_"
msgstr ""

#: ../../pep-0509.txt:552
msgid ""
"python-dev: `PEP 509: Add a private version to dict "
"<https://mail.python.org/pipermail/python-dev/2016-January/142685.html>`_"
" (January 2016)"
msgstr ""

#: ../../pep-0509.txt:555
msgid ""
"python-ideas: `RFC: PEP: Add dict.__version__ "
"<https://mail.python.org/pipermail/python-"
"ideas/2016-January/037702.html>`_ (January 2016)"
msgstr ""

#: ../../pep-0509.txt:561
msgid "Acceptance"
msgstr ""

#: ../../pep-0509.txt:563
msgid ""
"The PEP was `accepted on 2016-09-07 by Guido van Rossum "
"<https://mail.python.org/pipermail/python-"
"dev/2016-September/146298.html>`_. The PEP implementation has since been "
"committed to the repository."
msgstr ""

#: ../../pep-0509.txt:569
msgid "Copyright"
msgstr ""

#: ../../pep-0509.txt:571
msgid "This document has been placed in the public domain."
msgstr ""

