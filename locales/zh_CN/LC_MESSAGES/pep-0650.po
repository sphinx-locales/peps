# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0650.rst
msgid "PEP"
msgstr ""

#: ../../pep-0650.rst:1
msgid "650"
msgstr ""

#: ../../pep-0650.rst
msgid "Title"
msgstr ""

#: ../../pep-0650.rst:2
msgid "Specifying Installer Requirements for Python Projects"
msgstr ""

#: ../../pep-0650.rst
msgid "Author"
msgstr ""

#: ../../pep-0650.rst:3
msgid ""
"Vikram Jayanthi <vikramjayanthi@google.com>, Dustin Ingram "
"<di@python.org>, Brett Cannon <brett@python.org>"
msgstr ""

#: ../../pep-0650.rst
msgid "Discussions-To"
msgstr ""

#: ../../pep-0650.rst:6
msgid ""
"https://discuss.python.org/t/pep-650-specifying-installer-requirements-"
"for-python-projects/6657"
msgstr ""

#: ../../pep-0650.rst
msgid "Status"
msgstr ""

#: ../../pep-0650.rst:7
msgid "Draft"
msgstr ""

#: ../../pep-0650.rst
msgid "Type"
msgstr ""

#: ../../pep-0650.rst:8
msgid "Process"
msgstr ""

#: ../../pep-0650.rst
msgid "Created"
msgstr ""

#: ../../pep-0650.rst:10
msgid "16-Jul-2020"
msgstr ""

#: ../../pep-0650.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0650.rst:11
msgid "2021-01-14"
msgstr ""

#: ../../pep-0650.rst:15
msgid "Abstract"
msgstr ""

#: ../../pep-0650.rst:17
msgid ""
"Python package installers are not completely interoperable with each "
"other. While pip is the most widely used installer and a de facto "
"standard, other installers such as Poetry_ or Pipenv_ are popular as well"
" due to offering unique features which are optimal for certain workflows "
"and not directly in line with how pip operates."
msgstr ""

#: ../../pep-0650.rst:23
msgid ""
"While the abundance of installer options is good for end-users with "
"specific needs, the lack of interoperability between them makes it hard "
"to support all potential installers. Specifically, the lack of a standard"
" requirements file for declaring dependencies means that each tool must "
"be explicitly used in order to install dependencies specified with their "
"respective format. Otherwise tools must emit a requirements file which "
"leads to potential information loss for the installer as well as an added"
" export step as part of a developer's workflow."
msgstr ""

#: ../../pep-0650.rst:33
msgid ""
"By providing a standardized API that can be used to invoke a compatible "
"installer, we can solve this problem without needing to resolve "
"individual concerns, unique requirements, and incompatibilities between "
"different installers and their lock files."
msgstr ""

#: ../../pep-0650.rst:38
msgid ""
"Installers that implement the specification can be invoked in a uniform "
"way, allowing users to use their installer of choice as if they were "
"invoking it directly."
msgstr ""

#: ../../pep-0650.rst:43
msgid "Terminology"
msgstr ""

#: ../../pep-0650.rst:47
msgid "Installer interface"
msgstr ""

#: ../../pep-0650.rst:46
msgid ""
"The interface by which an *installer backend* and a *universal installer*"
" interact."
msgstr ""

#: ../../pep-0650.rst:53
msgid "Universal installer"
msgstr ""

#: ../../pep-0650.rst:50
msgid ""
"An installer that can invoke an *installer backend* by calling the "
"optional invocation methods of the *installer interface*. This can also "
"be thought of as the installer frontend, à la the build_ project for "
":pep:`517`."
msgstr ""

#: ../../pep-0650.rst:63
msgid "Installer backend"
msgstr ""

#: ../../pep-0650.rst:56
msgid ""
"An installer that implements the *installer interface*, allowing it to be"
" invoked by a *universal installer*. An *installer backend* may also be a"
" *universal installer* as well, but it is not required. In comparison to "
":pep:`517`, this would be Flit_. *Installer backends* may be wrapper "
"packages around a backing installer, e.g. Poetry could choose to not "
"support this API, but a package could act as a wrapper to invoke Poetry "
"as appropriate to use Poetry to perform an installation."
msgstr ""

#: ../../pep-0650.rst:71
msgid "Dependency group"
msgstr ""

#: ../../pep-0650.rst:66
msgid ""
"A set of dependencies that are related and required to be installed "
"simultaneously for some purpose. For example, a \"test\" dependency group"
" could include the dependencies required to run the test suite. How "
"dependency groups are specified is up to the *installer backend*."
msgstr ""

#: ../../pep-0650.rst:74
msgid "Motivation"
msgstr ""

#: ../../pep-0650.rst:76
msgid ""
"This specification allows anyone to invoke and interact with *installer "
"backends* that implement the specified interface, allowing for a "
"universally supported layer on top of existing tool-specific installation"
" processes."
msgstr ""

#: ../../pep-0650.rst:81
msgid ""
"This in turn would enable the use of all installers that implement the "
"specified interface to be used in environments that support a single "
"*universal installer*, as long as that installer implements this "
"specification as well."
msgstr ""

#: ../../pep-0650.rst:86
msgid ""
"Below, we identify various use-cases applicable to stakeholders in the "
"Python community and anyone who interacts with Python package installers."
" For developers or companies, this PEP would allow for increased "
"functionality and flexibility with Python package installers."
msgstr ""

#: ../../pep-0650.rst:93
msgid "Providers"
msgstr ""

#: ../../pep-0650.rst:95
msgid ""
"Providers are the parties (organization, person, community, etc.) that "
"supply a service or software tool which interacts with Python packaging "
"and consequently Python package installers. Two different types of "
"providers are considered:"
msgstr ""

#: ../../pep-0650.rst:101
msgid "Platform/Infrastructure Providers"
msgstr ""

#: ../../pep-0650.rst:103
msgid ""
"Platform providers (cloud environments, application hosting, etc.) and "
"infrastructure service providers need to support package installers for "
"their users to install Python dependencies. Most only support pip, "
"however there is user demand for other Python installers. Most providers "
"do not want to maintain support for more than one installer because of "
"the complexity it adds to their software or service and the resources it "
"takes to do so."
msgstr ""

#: ../../pep-0650.rst:111
msgid ""
"Via this specification, we can enable a provider-supported *universal "
"installer* to invoke the user-desired *installer backend* without the "
"provider’s platform needing to have specific knowledge of said backend. "
"What this means is if Poetry implemented the installer backend API "
"proposed by this PEP (or some other package wrapped Poetry to provide the"
" API), then platform providers would support Poetry implicitly."
msgstr ""

#: ../../pep-0650.rst:120
msgid "IDE Providers"
msgstr ""

#: ../../pep-0650.rst:122
msgid ""
"Integrated development environments may interact with Python package "
"installation and management. Most only support pip as a Python package "
"installer, and users are required to find work arounds to install their "
"dependencies using other package installers. Similar to the situation "
"with PaaS & IaaS providers, IDE providers do not want to maintain support"
" for N different Python installers. Instead, implementers of the "
"installer interface (*installer backends*) could be invoked by the IDE by"
" it acting as a *universal installer*."
msgstr ""

#: ../../pep-0650.rst:132
msgid "Developers"
msgstr ""

#: ../../pep-0650.rst:134
msgid ""
"Developers are teams, people, or communities that code and use Python "
"package installers and Python packages. Three different types of "
"developers are considered:"
msgstr ""

#: ../../pep-0650.rst:139
msgid "Developers using PaaS & IaaS providers"
msgstr ""

#: ../../pep-0650.rst:141
msgid ""
"Most PaaS and IaaS providers only support one Python package installer: "
"pip_. (Some exceptions include Heroku's Python buildpack_, which supports"
" pip and Pipenv_). This dictates the installers that developers can use "
"while working with these providers, which might not be optimal for their "
"application or workflow."
msgstr ""

#: ../../pep-0650.rst:147
msgid ""
"Installers adopting this PEP to become *installer backends* would allow "
"users to use third party platforms/infrastructure without having to worry"
" about which Python package installer they are required to use as long as"
" the provider uses a *universal installer*."
msgstr ""

#: ../../pep-0650.rst:153
msgid "Developers using IDEs"
msgstr ""

#: ../../pep-0650.rst:155
msgid ""
"Most IDEs only support pip or a few Python package installers. "
"Consequently, developers must use workarounds or hacky methods to install"
" their dependencies if they use an unsupported package installer."
msgstr ""

#: ../../pep-0650.rst:160
msgid ""
"If the IDE uses/provides a *universal installer* it would allow for any "
"*installer backend* that the developer wanted to be used to install "
"dependencies, freeing them of any extra work to install their "
"dependencies in order to integrate into the IDE's workflow more closely."
msgstr ""

#: ../../pep-0650.rst:167
msgid "Developers working with other developers"
msgstr ""

#: ../../pep-0650.rst:169
msgid ""
"Developers want to be able to use the installer of their choice while "
"working with other developers, but currently have to synchronize their "
"installer choice for compatibility of dependency installation. If all "
"preferred installers instead implemented the specified interface, it "
"would allow for cross use of installers, allowing developers to choose an"
" installer regardless of their collaborator’s preference."
msgstr ""

#: ../../pep-0650.rst:177
msgid "Upgraders & Package Infrastructure Providers"
msgstr ""

#: ../../pep-0650.rst:179
msgid ""
"Package upgraders and package infrastructure in CI/CD such as "
"Dependabot_, PyUP_, etc. currently support a few installers. They work by"
" parsing and editing the installer-specific dependency files directly "
"(such as ``requirements.txt`` or ``poetry.lock``) with relevant package "
"information such as upgrades, downgrades, or new hashes. Similar to "
"Platform and IDE providers, most of these providers do not want to "
"support N different Python package installers as that would require "
"supporting N different file types."
msgstr ""

#: ../../pep-0650.rst:188
msgid ""
"Currently, these services/bots have to implement support for each package"
" installer individually. Inevitably, the most popular installers are "
"supported first, and less popular tools are often never supported. By "
"implementing this specification, these services/bots can support any "
"(compliant) installer, allowing users to select the tool of their choice."
" This will allow for more innovation in the space, as platforms and IDEs "
"are no longer forced to prematurely select a \"winner\"."
msgstr ""

#: ../../pep-0650.rst:198
msgid "Open Source Community"
msgstr ""

#: ../../pep-0650.rst:200
msgid ""
"Specifying installer requirements and adopting this PEP will reduce the "
"friction between Python package installers and people's workflows. "
"Consequently, it will reduce the friction between Python package "
"installers and 3rd party infrastructure/technologies such as PaaS or "
"IDEs. Overall, it will allow for easier development, deployment and "
"maintenance of Python projects as Python package installation becomes "
"simpler and more interoperable."
msgstr ""

#: ../../pep-0650.rst:208
msgid ""
"Specifying requirements and creating an interface for installers can also"
" increase the pace of innovation around installers. This would allow for "
"installers to experiment and add unique functionality without requiring "
"the rest of the ecosystem to do the same. Support becomes easier and more"
" likely for a new installer regardless of the functionality it adds and "
"the format in which it writes dependencies, while reducing the developer "
"time and resources needed to do so."
msgstr ""

#: ../../pep-0650.rst:217
msgid "Specification"
msgstr ""

#: ../../pep-0650.rst:219
msgid ""
"Similar to how :pep:`517` specifies build systems, the install system "
"information will live in the ``pyproject.toml`` file under the ``install-"
"system`` table."
msgstr ""

#: ../../pep-0650.rst:224
msgid "[install-system]"
msgstr ""

#: ../../pep-0650.rst:226
msgid ""
"The install-system table is used to store install-system relevant data "
"and information. There are multiple required keys for this table: "
"``requires`` and ``install-backend``.  The ``requires`` key holds the "
"minimum requirements for the *installer backend* to execute and which "
"will be installed by the *universal installer*. The ``install-backend`` "
"key holds the name of the install backend’s entry point. This will allow "
"the *universal installer* to install the requirements for the *installer "
"backend* itself to execute (not the requirements that the *installer "
"backend* itself will install) as well as invoke the *installer backend*."
msgstr ""

#: ../../pep-0650.rst:237
msgid ""
"If either of the required keys are missing or empty then the *universal "
"installer* SHOULD raise an error."
msgstr ""

#: ../../pep-0650.rst:240
msgid ""
"All package names interacting with this interface are assumed to follow "
":pep:`508`'s  \"Dependency specification for Python Software Packages\" "
"format."
msgstr ""

#: ../../pep-0650.rst:244
msgid "An example ``install-system`` table::"
msgstr ""

#: ../../pep-0650.rst:254
msgid "Installer Requirements:"
msgstr ""

#: ../../pep-0650.rst:255
msgid ""
"The requirements specified by the ``requires`` key must be within the "
"constraints specified by :pep:`517`. Specifically, that dependency cycles"
" are not permitted and the *universal installer* SHOULD refuse to install"
" the dependencies if a cycle is detected."
msgstr ""

#: ../../pep-0650.rst:261
msgid "Additional parameters or tool specific data"
msgstr ""

#: ../../pep-0650.rst:262
msgid ""
"Additional parameters or tool (*installer backend*) data may also be "
"stored in the ``pyproject.toml`` file. This would be in the “tool.*” "
"table as specified by :pep:`518`. For example, if the *installer backend*"
" is Poetry and you wanted to specify multiple dependency groups, the "
"tool.poetry tables could look like this:"
msgstr ""

#: ../../pep-0650.rst:276
msgid ""
"Data may also be stored in other ways as the installer backend sees fit "
"(e.g. separate configuration file)."
msgstr ""

#: ../../pep-0650.rst:281
msgid "Installer interface:"
msgstr ""

#: ../../pep-0650.rst:282
msgid ""
"The *installer interface* contains mandatory and optional hooks. "
"Compliant *installer backends* MUST implement the mandatory hooks and MAY"
" implement the optional hooks. A *universal installer* MAY implement any "
"of the *installer backend* hooks itself, to act as both a *universal "
"installer* and *installer backend*, but this is not required."
msgstr ""

#: ../../pep-0650.rst:289
msgid ""
"All hooks take ``**kwargs`` arbitrary parameters that a *installer "
"backend* may require that are not already specified, allowing for "
"backwards compatibility. If unexpected parameters are passed to the "
"*installer backend*, it should ignore them."
msgstr ""

#: ../../pep-0650.rst:294
msgid ""
"The following information is akin to the corresponding section in "
":pep:`517`. The hooks may be called with keyword arguments, so *installer"
" backends* implementing them should be careful to make sure that their "
"signatures match both the order and the names of the arguments above."
msgstr ""

#: ../../pep-0650.rst:300
msgid ""
"All hooks MAY print arbitrary informational text to ``stdout`` and "
"``stderr``. They MUST NOT read from ``stdin``, and the *universal "
"installer* MAY close ``stdin`` before invoking the hooks."
msgstr ""

#: ../../pep-0650.rst:304
msgid ""
"The *universal installer* may capture ``stdout`` and/or ``stderr`` from "
"the backend. If the backend detects that an output stream is not a "
"terminal/console (e.g. not ``sys.stdout.isatty()``), it SHOULD ensure "
"that any output it writes to that stream is ``UTF-8`` encoded. The "
"*universal installer* MUST NOT fail if captured output is not valid "
"UTF-8, but it MAY not preserve all the information in that case (e.g. it "
"may decode using the replace error handler in Python). If the output "
"stream is a terminal, the *installer backend* is responsible for "
"presenting its output accurately, as for any program running in a "
"terminal."
msgstr ""

#: ../../pep-0650.rst:315
msgid ""
"If a hook raises an exception, or causes the process to terminate, then "
"this indicates an error."
msgstr ""

#: ../../pep-0650.rst:321
msgid "Mandatory hooks:"
msgstr ""

#: ../../pep-0650.rst:323
msgid "invoke_install"
msgstr ""

#: ../../pep-0650.rst:324
msgid "Installs the dependencies::"
msgstr ""

#: ../../pep-0650.rst:334 ../../pep-0650.rst:368 ../../pep-0650.rst:401
#: ../../pep-0650.rst:436 ../../pep-0650.rst:459
msgid ""
"``path`` : An absolute path where the *installer backend* should be "
"invoked from (e.g. the directory where ``pyproject.toml`` is located)."
msgstr ""

#: ../../pep-0650.rst:337
msgid ""
"``dependency_group`` : An optional flag specifying a dependency group "
"that the *installer backend* should install. The install will error if "
"the dependency group doesn't exist. A user can find all dependency groups"
" by calling ``get_dependency_groups()`` if dependency groups are "
"supported by the *installer backend*."
msgstr ""

#: ../../pep-0650.rst:343 ../../pep-0650.rst:373 ../../pep-0650.rst:407
#: ../../pep-0650.rst:439 ../../pep-0650.rst:468
msgid ""
"``**kwargs`` : Arbitrary parameters that a *installer backend* may "
"require that are not already specified, allows for backwards "
"compatibility."
msgstr ""

#: ../../pep-0650.rst:347 ../../pep-0650.rst:377 ../../pep-0650.rst:472
msgid ""
"Returns : An exit code (int). 0 if successful, any positive integer if "
"unsuccessful."
msgstr ""

#: ../../pep-0650.rst:350
msgid ""
"The *universal installer* will use the exit code to determine if the "
"installation is successful and SHOULD return the exit code itself."
msgstr ""

#: ../../pep-0650.rst:354
msgid "Optional hooks:"
msgstr ""

#: ../../pep-0650.rst:357
msgid "invoke_uninstall"
msgstr ""

#: ../../pep-0650.rst:358
msgid "Uninstall the specified dependencies::"
msgstr ""

#: ../../pep-0650.rst:371
msgid ""
"``dependency_group`` : An optional flag specifying a dependency group "
"that the *installer backend* should uninstall."
msgstr ""

#: ../../pep-0650.rst:380
msgid ""
"The *universal installer* MUST invoke the *installer backend* at the same"
" path that the *universal installer* itself was invoked."
msgstr ""

#: ../../pep-0650.rst:383
msgid ""
"The *universal installer* will use the exit code to determine if the "
"uninstall is successful and SHOULD return the exit code itself."
msgstr ""

#: ../../pep-0650.rst:387
msgid "get_dependencies_to_install"
msgstr ""

#: ../../pep-0650.rst:388
msgid ""
"Returns the dependencies that would be installed by "
"``invoke_install(...)``. This allows package upgraders (e.g., Dependabot)"
" to retrieve the dependencies attempting to be installed without parsing "
"the dependency file::"
msgstr ""

#: ../../pep-0650.rst:404
msgid ""
"``dependency_group`` : Specify a dependency group to get the dependencies"
" ``invoke_install(...)`` would install for that dependency group."
msgstr ""

#: ../../pep-0650.rst:411
msgid "Returns: A list of dependencies (:pep:`508` strings) to install."
msgstr ""

#: ../../pep-0650.rst:413
msgid ""
"If the group is specified, the *installer backend* MUST return the "
"dependencies corresponding to the provided dependency group. If the "
"specified group doesn't exist, or dependency groups are not supported by "
"the *installer backend*, the *installer backend* MUST raise an error."
msgstr ""

#: ../../pep-0650.rst:419
msgid ""
"If the group is not specified, and the *installer backend* provides the "
"concept of a default/unspecified group, the *installer backend* MAY "
"return the dependencies for the default/unspecified group, but otherwise "
"MUST raise an error."
msgstr ""

#: ../../pep-0650.rst:425
msgid "get_dependency_groups"
msgstr ""

#: ../../pep-0650.rst:426
msgid ""
"Returns the dependency groups available to be installed. This allows "
"*universal installers* to enumerate all dependency groups the *installer "
"backend* is aware of::"
msgstr ""

#: ../../pep-0650.rst:443
msgid ""
"Returns: A set of known dependency groups, as strings The empty set "
"represents no dependency groups."
msgstr ""

#: ../../pep-0650.rst:447
msgid "update_dependencies"
msgstr ""

#: ../../pep-0650.rst:448
msgid "Outputs a dependency file based on inputted package list::"
msgstr ""

#: ../../pep-0650.rst:462
msgid ""
"``dependency_specifiers`` : An iterable of dependencies as :pep:`508` "
"strings that are being updated, for example : ``[\"requests==2.8.1\", "
"...]``. Optionally for a specific dependency group."
msgstr ""

#: ../../pep-0650.rst:466
msgid ""
"``dependency_group`` : The dependency group that the list of packages is "
"for."
msgstr ""

#: ../../pep-0650.rst:477
msgid "Example"
msgstr ""

#: ../../pep-0650.rst:479
msgid ""
"Let's consider implementing an *installer backend* that uses pip and its "
"requirements files for *dependency groups*. An implementation may (very "
"roughly) look like the following::"
msgstr ""

#: ../../pep-0650.rst:503
msgid ""
"If we named this package ``pep650pip``, then we could specify in "
"``pyproject.toml``::"
msgstr ""

#: ../../pep-0650.rst:513
msgid "Rationale"
msgstr ""

#: ../../pep-0650.rst:515
msgid ""
"All hooks take  ``**kwargs`` to allow for backwards compatibility and "
"allow for tool specific *installer backend* functionality which requires "
"a user to provide additional information not required by the hook."
msgstr ""

#: ../../pep-0650.rst:520
msgid ""
"While *installer backends* must be Python packages, what they do when "
"invoked is an implementation detail of that tool. For example, an "
"*installer backend* could act as a wrapper for a platform package manager"
" (e.g., ``apt``)."
msgstr ""

#: ../../pep-0650.rst:525
msgid ""
"The interface does not in any way try to specify *how* *installer "
"backends* should function. This is on purpose so that *installer "
"backends* can be allowed to innovate and solve problem in their own way. "
"This also means this PEP takes no stance on OS packaging as that would be"
" an *installer backend*'s domain."
msgstr ""

#: ../../pep-0650.rst:531
msgid ""
"Defining the API in Python does mean that *some* Python code will "
"eventually need to be executed. That does not preclude non-Python "
"*installer backends* from being used, though (e.g. mamba_), as they could"
" be executed as a subprocess from Python code."
msgstr ""

#: ../../pep-0650.rst:538
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0650.rst:540
msgid ""
"This PEP would have no impact on pre-existing code and functionality as "
"it only adds new functionality to a *universal installer*. Any existing "
"installer should maintain its existing functionality and use cases, "
"therefore having no backwards compatibility issues. Only code aiming to "
"take advantage of this new functionality will have motivation to make "
"changes to their pre existing code."
msgstr ""

#: ../../pep-0650.rst:549
msgid "Security Implications"
msgstr ""

#: ../../pep-0650.rst:551
msgid ""
"A malicious user has no increased ability or easier access to anything "
"with the addition of standardized installer specifications. The installer"
" that could be invoked by a *universal installer* via the interface "
"specified in this PEP would be explicitly declared by the user. If the "
"user has chosen a malicious installer, then invoking it with a *universal"
" installer* is no different than the user invoking the installer "
"directly. A malicious installer being an *installer backend* doesn't give"
" it additional permissions or abilities."
msgstr ""

#: ../../pep-0650.rst:563
msgid "Rejected Ideas"
msgstr ""

#: ../../pep-0650.rst:566
msgid "A standardized lock file"
msgstr ""

#: ../../pep-0650.rst:568
msgid ""
"A standardized lock file would solve a lot of the same problems that "
"specifying installer requirements would. For example, it would allow for "
"PaaS/IaaS to just support one installer that could read the standardized "
"lock file regardless of the installer that created it. The problem with a"
" standardized lock file is the difference in needs between Python package"
" installers as well as a fundamental issue with creating reproducible "
"environments via the lockfile (one of the main benefits)."
msgstr ""

#: ../../pep-0650.rst:577
msgid ""
"Needs and information stored in dependency files between installers "
"differ significantly and are dependent on installer functionality. For "
"example, a Python package installer such as Poetry requires information "
"for all Python versions and platforms and calculates appropriate hashes "
"while pip doesn't. Additionally, pip would not be able to guarantee "
"recreating the same environment (install the exact same dependencies) as "
"it is outside the scope of its functionality. This makes a standardized "
"lock file harder to implement and makes it seem more appropriate to make "
"lock files tool specific."
msgstr ""

#: ../../pep-0650.rst:589
msgid "Have installer backends support creating virtual environments"
msgstr ""

#: ../../pep-0650.rst:591
msgid ""
"Because *installer backends* will very likely have a concept of virtual "
"environments and how to install into them, it was briefly considered to "
"have them also support creating virtual environments. In the end, though,"
" it was considered an orthogonal idea."
msgstr ""

#: ../../pep-0650.rst:598
msgid "Open Issues"
msgstr ""

#: ../../pep-0650.rst:601
msgid "Should the ``dependency_group`` argument take an iterable?"
msgstr ""

#: ../../pep-0650.rst:603
msgid ""
"This would allow for specifying non-overlapping dependency groups in a "
"single call, e.g. \"docs\" and \"test\" groups which have independent "
"dependencies but which a developer may want to install simultaneously "
"while doing development."
msgstr ""

#: ../../pep-0650.rst:609
msgid "Is the installer backend executed in-process?"
msgstr ""

#: ../../pep-0650.rst:611
msgid ""
"If the *installer backend* is executed in-process then it greatly "
"simplifies knowing what environment to install for/into, as the live "
"Python environment can be queried for appropriate information."
msgstr ""

#: ../../pep-0650.rst:615
msgid ""
"Executing out-of-process allows for minimizing potential issues of "
"clashes between the environment being installed into and the *installer "
"backend* (and potentially *universal installer*)."
msgstr ""

#: ../../pep-0650.rst:620
msgid "Enforce that results from the proposed interface feed into other parts?"
msgstr ""

#: ../../pep-0650.rst:622
msgid ""
"E.g. the results from ``get_dependencies_to_install()`` and "
"``get_dependency_groups()`` can be passed into ``invoke_install()``. This"
" would prevent drift between the results of various parts of the proposed"
" interface, but it makes more of the interface required instead of "
"optional."
msgstr ""

#: ../../pep-0650.rst:629
msgid "Raising exceptions instead of exit codes for failure conditions"
msgstr ""

#: ../../pep-0650.rst:631
msgid ""
"It has been suggested that instead of returning an exit code the API "
"should raise exceptions. If you view this PEP as helping to translate "
"current installers into *installer backends*, then relying on exit codes "
"makes sense. There's is also the point that the APIs have no specific "
"return value, so passing along an exit code does not interfere with what "
"the functions return."
msgstr ""

#: ../../pep-0650.rst:638
msgid ""
"Compare that to raising exceptions in case of an error. That could "
"potentially provide a more structured approach to error raising, although"
" to be able to capture errors it would require specifying exception types"
" as part of the interface."
msgstr ""

#: ../../pep-0650.rst:644
msgid "References"
msgstr ""

#: ../../pep-0650.rst:657
msgid "Copyright"
msgstr ""

#: ../../pep-0650.rst:659
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

