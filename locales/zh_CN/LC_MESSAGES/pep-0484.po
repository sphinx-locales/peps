# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0484.txt
msgid "PEP"
msgstr ""

#: ../../pep-0484.txt:1
msgid "484"
msgstr ""

#: ../../pep-0484.txt
msgid "Title"
msgstr ""

#: ../../pep-0484.txt:2
msgid "Type Hints"
msgstr ""

#: ../../pep-0484.txt
msgid "Author"
msgstr ""

#: ../../pep-0484.txt:5
msgid ""
"Guido van Rossum <guido@python.org>, Jukka Lehtosalo "
"<jukka.lehtosalo@iki.fi>, ≈Åukasz Langa <lukasz@python.org>"
msgstr ""

#: ../../pep-0484.txt
msgid "BDFL-Delegate"
msgstr ""

#: ../../pep-0484.txt:6
msgid "Mark Shannon"
msgstr ""

#: ../../pep-0484.txt
msgid "Discussions-To"
msgstr ""

#: ../../pep-0484.txt:7
msgid "Python-Dev <python-dev@python.org>"
msgstr ""

#: ../../pep-0484.txt
msgid "Status"
msgstr ""

#: ../../pep-0484.txt:8
msgid "Provisional"
msgstr ""

#: ../../pep-0484.txt
msgid "Type"
msgstr ""

#: ../../pep-0484.txt:9
msgid "Standards Track"
msgstr ""

#: ../../pep-0484.txt
msgid "Created"
msgstr ""

#: ../../pep-0484.txt:11
msgid "29-Sep-2014"
msgstr ""

#: ../../pep-0484.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0484.txt:12
msgid "3.5"
msgstr ""

#: ../../pep-0484.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0484.txt:13
msgid "16-Jan-2015,20-Mar-2015,17-Apr-2015,20-May-2015,22-May-2015"
msgstr ""

#: ../../pep-0484.txt
msgid "Resolution"
msgstr ""

#: ../../pep-0484.txt:14
msgid "https://mail.python.org/pipermail/python-dev/2015-May/140104.html"
msgstr ""

#: ../../pep-0484.txt:18
msgid "Abstract"
msgstr ""

#: ../../pep-0484.txt:20
msgid ""
"PEP 3107 introduced syntax for function annotations, but the semantics "
"were deliberately left undefined.  There has now been enough 3rd party "
"usage for static type analysis that the community would benefit from a "
"standard vocabulary and baseline tools within the standard library."
msgstr ""

#: ../../pep-0484.txt:25
msgid ""
"This PEP introduces a provisional module to provide these standard "
"definitions and tools, along with some conventions for situations where "
"annotations are not available."
msgstr ""

#: ../../pep-0484.txt:29
msgid ""
"Note that this PEP still explicitly does NOT prevent other uses of "
"annotations, nor does it require (or forbid) any particular processing of"
" annotations, even when they conform to this specification.  It simply "
"enables better coordination, as PEP 333 did for web frameworks."
msgstr ""

#: ../../pep-0484.txt:34
msgid ""
"For example, here is a simple function whose argument and return type are"
" declared in the annotations::"
msgstr ""

#: ../../pep-0484.txt:40
msgid ""
"While these annotations are available at runtime through the usual "
"``__annotations__`` attribute, *no type checking happens at runtime*. "
"Instead, the proposal assumes the existence of a separate off-line type "
"checker which users can run over their source code voluntarily. "
"Essentially, such a type checker acts as a very powerful linter. (While "
"it would of course be possible for individual users to employ a similar "
"checker at run time for Design By Contract enforcement or JIT "
"optimization, those tools are not yet as mature.)"
msgstr ""

#: ../../pep-0484.txt:49
msgid ""
"The proposal is strongly inspired by mypy [mypy]_.  For example, the type"
" \"sequence of integers\" can be written as ``Sequence[int]``.  The "
"square brackets mean that no new syntax needs to be added to the "
"language.  The example here uses a custom type ``Sequence``, imported "
"from a pure-Python module ``typing``.  The ``Sequence[int]`` notation "
"works at runtime by implementing ``__getitem__()`` in the metaclass (but "
"its significance is primarily to an offline type checker)."
msgstr ""

#: ../../pep-0484.txt:57
msgid ""
"The type system supports unions, generic types, and a special type named "
"``Any`` which is consistent with (i.e. assignable to and from) all types."
"  This latter feature is taken from the idea of gradual typing. Gradual "
"typing and the full type system are explained in PEP 483."
msgstr ""

#: ../../pep-0484.txt:62
msgid ""
"Other approaches from which we have borrowed or to which ours can be "
"compared and contrasted are described in PEP 482."
msgstr ""

#: ../../pep-0484.txt:67
msgid "Rationale and Goals"
msgstr ""

#: ../../pep-0484.txt:69
msgid ""
"PEP 3107 added support for arbitrary annotations on parts of a function "
"definition.  Although no meaning was assigned to annotations then, there "
"has always been an implicit goal to use them for type hinting [gvr-"
"artima]_, which is listed as the first possible use case in said PEP."
msgstr ""

#: ../../pep-0484.txt:75
msgid ""
"This PEP aims to provide a standard syntax for type annotations, opening "
"up Python code to easier static analysis and refactoring, potential "
"runtime type checking, and (perhaps, in some contexts) code generation "
"utilizing type information."
msgstr ""

#: ../../pep-0484.txt:80
msgid ""
"Of these goals, static analysis is the most important.  This includes "
"support for off-line type checkers such as mypy, as well as providing a "
"standard notation that can be used by IDEs for code completion and "
"refactoring."
msgstr ""

#: ../../pep-0484.txt:86
msgid "Non-goals"
msgstr ""

#: ../../pep-0484.txt:88
msgid ""
"While the proposed typing module will contain some building blocks for "
"runtime type checking -- in particular the ``get_type_hints()`` function "
"-- third party packages would have to be developed to implement specific "
"runtime type checking functionality, for example using decorators or "
"metaclasses.  Using type hints for performance optimizations is left as "
"an exercise for the reader."
msgstr ""

#: ../../pep-0484.txt:95
msgid ""
"It should also be emphasized that **Python will remain a dynamically "
"typed language, and the authors have no desire to ever make type hints "
"mandatory, even by convention.**"
msgstr ""

#: ../../pep-0484.txt:101
msgid "The meaning of annotations"
msgstr ""

#: ../../pep-0484.txt:103
msgid ""
"Any function without annotations should be treated as having the most "
"general type possible, or ignored, by any type checker.  Functions with "
"the ``@no_type_check`` decorator should be treated as having no "
"annotations."
msgstr ""

#: ../../pep-0484.txt:108
msgid ""
"It is recommended but not required that checked functions have "
"annotations for all arguments and the return type.  For a checked "
"function, the default annotation for arguments and for the return type is"
" ``Any``.  An exception is the first argument of instance and class "
"methods. If it is not annotated, then it is assumed to have the type of "
"the containing class for instance methods, and a type object type "
"corresponding to the containing class object for class methods. For "
"example, in class ``A`` the first argument of an instance method has the "
"implicit type ``A``. In a class method, the precise type of the first "
"argument cannot be represented using the available type notation."
msgstr ""

#: ../../pep-0484.txt:120
msgid ""
"(Note that the return type of ``__init__`` ought to be annotated with "
"``-> None``.  The reason for this is subtle.  If ``__init__`` assumed a "
"return annotation of ``-> None``, would that mean that an argument-less, "
"un-annotated ``__init__`` method should still be type-checked?  Rather "
"than leaving this ambiguous or introducing an exception to the exception,"
" we simply say that ``__init__`` ought to have a return annotation; the "
"default behavior is thus the same as for other methods.)"
msgstr ""

#: ../../pep-0484.txt:129
msgid ""
"A type checker is expected to check the body of a checked function for "
"consistency with the given annotations.  The annotations may also be used"
" to check correctness of calls appearing in other checked functions."
msgstr ""

#: ../../pep-0484.txt:133
msgid ""
"Type checkers are expected to attempt to infer as much information as "
"necessary.  The minimum requirement is to handle the builtin decorators "
"``@property``, ``@staticmethod`` and ``@classmethod``."
msgstr ""

#: ../../pep-0484.txt:139
msgid "Type Definition Syntax"
msgstr ""

#: ../../pep-0484.txt:141
msgid ""
"The syntax leverages PEP 3107-style annotations with a number of "
"extensions described in sections below.  In its basic form, type hinting "
"is used by filling function annotation slots with classes::"
msgstr ""

#: ../../pep-0484.txt:148
msgid ""
"This states that the expected type of the ``name`` argument is ``str``.  "
"Analogically, the expected return type is ``str``."
msgstr ""

#: ../../pep-0484.txt:151
msgid ""
"Expressions whose type is a subtype of a specific argument type are also "
"accepted for that argument."
msgstr ""

#: ../../pep-0484.txt:156
msgid "Acceptable type hints"
msgstr ""

#: ../../pep-0484.txt:158
msgid ""
"Type hints may be built-in classes (including those defined in standard "
"library or third-party extension modules), abstract base classes, types "
"available in the ``types`` module, and user-defined classes (including "
"those defined in the standard library or third-party modules)."
msgstr ""

#: ../../pep-0484.txt:164
msgid ""
"While annotations are normally the best format for type hints, there are "
"times when it is more appropriate to represent them by a special comment,"
" or in a separately distributed stub file.  (See below for examples.)"
msgstr ""

#: ../../pep-0484.txt:169
msgid ""
"Annotations must be valid expressions that evaluate without raising "
"exceptions at the time the function is defined (but see below for forward"
" references)."
msgstr ""

#: ../../pep-0484.txt:173
msgid ""
"Annotations should be kept simple or static analysis tools may not be "
"able to interpret the values. For example, dynamically computed types are"
" unlikely to be understood.  (This is an intentionally somewhat vague "
"requirement, specific inclusions and exclusions may be added to future "
"versions of this PEP as warranted by the discussion.)"
msgstr ""

#: ../../pep-0484.txt:180
msgid ""
"In addition to the above, the following special constructs defined below "
"may be used: ``None``, ``Any``, ``Union``, ``Tuple``, ``Callable``, all "
"ABCs and stand-ins for concrete classes exported from ``typing`` (e.g. "
"``Sequence`` and ``Dict``), type variables, and type aliases."
msgstr ""

#: ../../pep-0484.txt:186
msgid ""
"All newly introduced names used to support features described in "
"following sections (such as ``Any`` and ``Union``) are available in the "
"``typing`` module."
msgstr ""

#: ../../pep-0484.txt:192
msgid "Using None"
msgstr ""

#: ../../pep-0484.txt:194
msgid ""
"When used in a type hint, the expression ``None`` is considered "
"equivalent to ``type(None)``."
msgstr ""

#: ../../pep-0484.txt:199
msgid "Type aliases"
msgstr ""

#: ../../pep-0484.txt:201
msgid "Type aliases are defined by simple variable assignments::"
msgstr ""

#: ../../pep-0484.txt:207
msgid ""
"Note that we recommend capitalizing alias names, since they represent "
"user-defined types, which (like user-defined classes) are typically "
"spelled that way."
msgstr ""

#: ../../pep-0484.txt:211
msgid ""
"Type aliases may be as complex as type hints in annotations -- anything "
"that is acceptable as a type hint is acceptable in a type alias::"
msgstr ""

#: ../../pep-0484.txt:227
msgid "This is equivalent to::"
msgstr ""

#: ../../pep-0484.txt:241
msgid "Callable"
msgstr ""

#: ../../pep-0484.txt:243
msgid ""
"Frameworks expecting callback functions of specific signatures might be "
"type hinted using ``Callable[[Arg1Type, Arg2Type], ReturnType]``. "
"Examples::"
msgstr ""

#: ../../pep-0484.txt:256
msgid ""
"It is possible to declare the return type of a callable without "
"specifying the call signature by substituting a literal ellipsis (three "
"dots) for the list of arguments::"
msgstr ""

#: ../../pep-0484.txt:263
msgid ""
"Note that there are no square brackets around the ellipsis.  The "
"arguments of the callback are completely unconstrained in this case (and "
"keyword arguments are acceptable)."
msgstr ""

#: ../../pep-0484.txt:267
msgid ""
"Since using callbacks with keyword arguments is not perceived as a common"
" use case, there is currently no support for specifying keyword arguments"
" with ``Callable``.  Similarly, there is no support for specifying "
"callback signatures with a variable number of arguments of a specific "
"type."
msgstr ""

#: ../../pep-0484.txt:273
msgid ""
"Because ``typing.Callable`` does double-duty as a replacement for "
"``collections.abc.Callable``, ``isinstance(x, typing.Callable)`` is "
"implemented by deferring to ``isinstance(x, collections.abc.Callable)``. "
"However, ``isinstance(x, typing.Callable[...])`` is not supported."
msgstr ""

#: ../../pep-0484.txt:280
msgid "Generics"
msgstr ""

#: ../../pep-0484.txt:282
msgid ""
"Since type information about objects kept in containers cannot be "
"statically inferred in a generic way, abstract base classes have been "
"extended to support subscription to denote expected types for container "
"elements.  Example::"
msgstr ""

#: ../../pep-0484.txt:291
msgid ""
"Generics can be parameterized by using a new factory available in "
"``typing`` called ``TypeVar``.  Example::"
msgstr ""

#: ../../pep-0484.txt:301
msgid ""
"In this case the contract is that the returned value is consistent with "
"the elements held by the collection."
msgstr ""

#: ../../pep-0484.txt:304
msgid ""
"A ``TypeVar()`` expression must always directly be assigned to a variable"
" (it should not be used as part of a larger expression).  The argument to"
" ``TypeVar()`` must be a string equal to the variable name to which it is"
" assigned.  Type variables must not be redefined."
msgstr ""

#: ../../pep-0484.txt:309
msgid ""
"``TypeVar`` supports constraining parametric types to a fixed set of "
"possible types (note: those types cannot be parameterized by type "
"variables). For example, we can define a type variable that ranges over "
"just ``str`` and ``bytes``. By default, a type variable ranges over all "
"possible types. Example of constraining a type variable::"
msgstr ""

#: ../../pep-0484.txt:322
msgid ""
"The function ``concat`` can be called with either two ``str`` arguments "
"or two ``bytes`` arguments, but not with a mix of ``str`` and ``bytes`` "
"arguments."
msgstr ""

#: ../../pep-0484.txt:326
msgid ""
"There should be at least two constraints, if any; specifying a single "
"constraint is disallowed."
msgstr ""

#: ../../pep-0484.txt:329
msgid ""
"Subtypes of types constrained by a type variable should be treated as "
"their respective explicitly listed base types in the context of the type "
"variable.  Consider this example::"
msgstr ""

#: ../../pep-0484.txt:337
msgid ""
"The call is valid but the type variable ``AnyStr`` will be set to ``str``"
" and not ``MyStr``. In effect, the inferred type of the return value "
"assigned to ``x`` will also be ``str``."
msgstr ""

#: ../../pep-0484.txt:341
msgid ""
"Additionally, ``Any`` is a valid value for every type variable. Consider "
"the following::"
msgstr ""

#: ../../pep-0484.txt:347
msgid ""
"This is equivalent to omitting the generic notation and just saying "
"``elements: List``."
msgstr ""

#: ../../pep-0484.txt:352
msgid "User-defined generic types"
msgstr ""

#: ../../pep-0484.txt:354
msgid ""
"You can include a ``Generic`` base class to define a user-defined class "
"as generic.  Example::"
msgstr ""

#: ../../pep-0484.txt:379
msgid ""
"``Generic[T]`` as a base class defines that the class ``LoggedVar`` takes"
" a single type parameter ``T``. This also makes ``T`` valid as a type "
"within the class body."
msgstr ""

#: ../../pep-0484.txt:383
msgid ""
"The ``Generic`` base class uses a metaclass that defines ``__getitem__`` "
"so that ``LoggedVar[t]`` is valid as a type::"
msgstr ""

#: ../../pep-0484.txt:392
msgid ""
"A generic type can have any number of type variables, and type variables "
"may be constrained. This is valid::"
msgstr ""

#: ../../pep-0484.txt:404
msgid ""
"Each type variable argument to ``Generic`` must be distinct. This is thus"
" invalid::"
msgstr ""

#: ../../pep-0484.txt:415
msgid ""
"The ``Generic[T]`` base class is redundant in simple cases where you "
"subclass some other generic class and specify type variables for its "
"parameters::"
msgstr ""

#: ../../pep-0484.txt:426
msgid "That class definition is equivalent to::"
msgstr ""

#: ../../pep-0484.txt:431
msgid "You can use multiple inheritance with ``Generic``::"
msgstr ""

#: ../../pep-0484.txt:448
msgid ""
"Subclassing a generic class without specifying type parameters assumes "
"``Any`` for each position.  In the following example, ``MyIterable`` is "
"not generic but implicitly inherits from ``Iterable[Any]``::"
msgstr ""

#: ../../pep-0484.txt:457
msgid "Generic metaclasses are not supported."
msgstr ""

#: ../../pep-0484.txt:461
msgid "Scoping rules for type variables"
msgstr ""

#: ../../pep-0484.txt:463
msgid ""
"Type variables follow normal name resolution rules. However, there are "
"some special cases in the static typechecking context:"
msgstr ""

#: ../../pep-0484.txt:466
msgid ""
"A type variable used in a generic function could be inferred to represent"
" different types in the same code block. Example::"
msgstr ""

#: ../../pep-0484.txt:479
msgid ""
"A type variable used in a method of a generic class that coincides with "
"one of the variables that parameterize this class is always bound to that"
" variable. Example::"
msgstr ""

#: ../../pep-0484.txt:495
msgid ""
"A type variable used in a method that does not match any of the variables"
" that parameterize the class makes this method a generic function in that"
" variable::"
msgstr ""

#: ../../pep-0484.txt:508
msgid ""
"Unbound type variables should not appear in the bodies of generic "
"functions, or in the class bodies apart from method definitions::"
msgstr ""

#: ../../pep-0484.txt:527
msgid ""
"A generic class definition that appears inside a generic function should "
"not use type variables that parameterize the generic function::"
msgstr ""

#: ../../pep-0484.txt:542
msgid ""
"A generic class nested in another generic class cannot use same type "
"variables. The scope of the type variables of the outer class doesn't "
"cover the inner one::"
msgstr ""

#: ../../pep-0484.txt:561
msgid "Instantiating generic classes and type erasure"
msgstr ""

#: ../../pep-0484.txt:563
msgid ""
"User-defined generic classes can be instantiated. Suppose we write a "
"``Node`` class inheriting from ``Generic[T]``::"
msgstr ""

#: ../../pep-0484.txt:573
msgid ""
"To create ``Node`` instances you call ``Node()`` just as for a regular "
"class.  At runtime the type (class) of the instance will be ``Node``. But"
" what type does it have to the type checker?  The answer depends on how "
"much information is available in the call.  If the constructor "
"(``__init__`` or ``__new__``) uses ``T`` in its signature, and a "
"corresponding argument value is passed, the type of the corresponding "
"argument(s) is substituted.  Otherwise, ``Any`` is assumed.  Example::"
msgstr ""

#: ../../pep-0484.txt:594
msgid ""
"In case the inferred type uses ``[Any]`` but the intended type is more "
"specific, you can use a type comment (see below) to force the type of the"
" variable, e.g.::"
msgstr ""

#: ../../pep-0484.txt:602
msgid "Alternatively, you can instantiate a specific concrete type, e.g.::"
msgstr ""

#: ../../pep-0484.txt:610
msgid ""
"Note that the runtime type (class) of ``p`` and ``q`` is still just "
"``Node`` -- ``Node[int]`` and ``Node[str]`` are distinguishable class "
"objects, but the runtime class of the objects created by instantiating "
"them doesn't record the distinction. This behavior is called \"type "
"erasure\"; it is common practice in languages with generics (e.g. Java, "
"TypeScript)."
msgstr ""

#: ../../pep-0484.txt:616
msgid ""
"Using generic classes (parameterized or not) to access attributes will "
"result in type check failure. Outside the class definition body, a class "
"attribute cannot be assigned, and can only be looked up by accessing it "
"through a class instance that does not have an instance attribute with "
"the same name::"
msgstr ""

#: ../../pep-0484.txt:631
msgid ""
"Generic versions of abstract collections like ``Mapping`` or ``Sequence``"
" and generic versions of built-in classes -- ``List``, ``Dict``, ``Set``,"
" and ``FrozenSet`` -- cannot be instantiated. However, concrete user-"
"defined subclasses thereof and generic versions of concrete collections "
"can be instantiated::"
msgstr ""

#: ../../pep-0484.txt:639
msgid ""
"Note that one should not confuse static types and runtime classes. The "
"type is still erased in this case and the above expression is just a "
"shorthand for::"
msgstr ""

#: ../../pep-0484.txt:645
msgid ""
"It is not recommended to use the subscripted class (e.g. ``Node[int]``) "
"directly in an expression -- using a type alias (e.g. ``IntNode = "
"Node[int]``) instead is preferred. (First, creating the subscripted "
"class, e.g. ``Node[int]``, has a runtime cost. Second, using a type alias"
" is more readable.)"
msgstr ""

#: ../../pep-0484.txt:653
msgid "Arbitrary generic types as base classes"
msgstr ""

#: ../../pep-0484.txt:655
msgid ""
"``Generic[T]`` is only valid as a base class -- it's not a proper type. "
"However, user-defined generic types such as ``LinkedList[T]`` from the "
"above example and built-in generic types and ABCs such as ``List[T]`` and"
" ``Iterable[T]`` are valid both as types and as base classes. For "
"example, we can define a subclass of ``Dict`` that specializes type "
"arguments::"
msgstr ""

#: ../../pep-0484.txt:680
msgid ""
"``SymbolTable`` is a subclass of ``dict`` and a subtype of ``Dict[str, "
"List[Node]]``."
msgstr ""

#: ../../pep-0484.txt:683
msgid ""
"If a generic base class has a type variable as a type argument, this "
"makes the defined class generic. For example, we can define a generic "
"``LinkedList`` class that is iterable and a container::"
msgstr ""

#: ../../pep-0484.txt:694
msgid ""
"Now ``LinkedList[int]`` is a valid type. Note that we can use ``T`` "
"multiple times in the base class list, as long as we don't use the same "
"type variable ``T`` multiple times within ``Generic[...]``."
msgstr ""

#: ../../pep-0484.txt:698
msgid "Also consider the following example::"
msgstr ""

#: ../../pep-0484.txt:707
msgid "In this case MyDict has a single parameter, T."
msgstr ""

#: ../../pep-0484.txt:711
msgid "Abstract generic types"
msgstr ""

#: ../../pep-0484.txt:713
msgid ""
"The metaclass used by ``Generic`` is a subclass of ``abc.ABCMeta``. A "
"generic class can be an ABC by including abstract methods or properties, "
"and generic classes can also have ABCs as base classes without a "
"metaclass conflict."
msgstr ""

#: ../../pep-0484.txt:720
msgid "Type variables with an upper bound"
msgstr ""

#: ../../pep-0484.txt:722
msgid ""
"A type variable may specify an upper bound using ``bound=<type>`` (note: "
"<type> itself cannot be parameterized by type variables). This means that"
" an actual type substituted (explicitly or implicitly) for the type "
"variable must be a subtype of the boundary type. Example::"
msgstr ""

#: ../../pep-0484.txt:741
msgid ""
"An upper bound cannot be combined with type constraints (as in used "
"``AnyStr``, see the example earlier); type constraints cause the inferred"
" type to be _exactly_ one of the constraint types, while an upper bound "
"just requires that the actual type is a subtype of the boundary type."
msgstr ""

#: ../../pep-0484.txt:749
msgid "Covariance and contravariance"
msgstr ""

#: ../../pep-0484.txt:751
msgid ""
"Consider a class ``Employee`` with a subclass ``Manager``.  Now suppose "
"we have a function with an argument annotated with ``List[Employee]``.  "
"Should we be allowed to call this function with a variable of type "
"``List[Manager]`` as its argument?  Many people would answer \"yes, of "
"course\" without even considering the consequences. But unless we know "
"more about the function, a type checker should reject such a call: the "
"function might append an ``Employee`` instance to the list, which would "
"violate the variable's type in the caller."
msgstr ""

#: ../../pep-0484.txt:760
msgid ""
"It turns out such an argument acts *contravariantly*, whereas the "
"intuitive answer (which is correct in case the function doesn't mutate "
"its argument!) requires the argument to act *covariantly*.  A longer "
"introduction to these concepts can be found on Wikipedia [wiki-variance]_"
" and in PEP 483; here we just show how to control a type checker's "
"behavior."
msgstr ""

#: ../../pep-0484.txt:767
msgid ""
"By default generic types are considered *invariant* in all type "
"variables, which means that values for variables annotated with types "
"like ``List[Employee]`` must exactly match the type annotation -- no "
"subclasses or superclasses of the type parameter (in this example "
"``Employee``) are allowed."
msgstr ""

#: ../../pep-0484.txt:773
msgid ""
"To facilitate the declaration of container types where covariant or "
"contravariant type checking is acceptable, type variables accept keyword "
"arguments ``covariant=True`` or ``contravariant=True``. At most one of "
"these may be passed. Generic types defined with such variables are "
"considered covariant or contravariant in the corresponding variable. By "
"convention, it is recommended to use names ending in ``_co`` for type "
"variables defined with ``covariant=True`` and names ending in ``_contra``"
" for that defined with ``contravariant=True``."
msgstr ""

#: ../../pep-0484.txt:782
msgid ""
"A typical example involves defining an immutable (or read-only) container"
" class::"
msgstr ""

#: ../../pep-0484.txt:805
msgid ""
"The read-only collection classes in ``typing`` are all declared covariant"
" in their type variable (e.g. ``Mapping`` and ``Sequence``). The mutable "
"collection classes (e.g. ``MutableMapping`` and ``MutableSequence``) are "
"declared invariant. The one example of a contravariant type is the "
"``Generator`` type, which is contravariant in the ``send()`` argument "
"type (see below)."
msgstr ""

#: ../../pep-0484.txt:812
msgid ""
"Note: Covariance or contravariance is *not* a property of a type "
"variable, but a property of a generic class defined using this variable. "
"Variance is only applicable to generic types; generic functions do not "
"have this property. The latter should be defined using only type "
"variables without ``covariant`` or ``contravariant`` keyword arguments. "
"For example, the following example is fine::"
msgstr ""

#: ../../pep-0484.txt:832
msgid "while the following is prohibited::"
msgstr ""

#: ../../pep-0484.txt:841
msgid "The numeric tower"
msgstr ""

#: ../../pep-0484.txt:843
msgid ""
"PEP 3141 defines Python's numeric tower, and the stdlib module "
"``numbers`` implements the corresponding ABCs (``Number``, ``Complex``, "
"``Real``, ``Rational`` and ``Integral``).  There are some issues with "
"these ABCs, but the built-in concrete numeric classes ``complex``, "
"``float`` and ``int`` are ubiquitous (especially the latter two :-)."
msgstr ""

#: ../../pep-0484.txt:850
msgid ""
"Rather than requiring that users write ``import numbers`` and then use "
"``numbers.Float`` etc., this PEP proposes a straightforward shortcut that"
" is almost as effective: when an argument is annotated as having type "
"``float``, an argument of type ``int`` is acceptable; similar, for an "
"argument annotated as having type ``complex``, arguments of type "
"``float`` or ``int`` are acceptable.  This does not handle classes "
"implementing the corresponding ABCs or the ``fractions.Fraction`` class, "
"but we believe those use cases are exceedingly rare."
msgstr ""

#: ../../pep-0484.txt:862
msgid "Forward references"
msgstr ""

#: ../../pep-0484.txt:864
msgid ""
"When a type hint contains names that have not been defined yet, that "
"definition may be expressed as a string literal, to be resolved later."
msgstr ""

#: ../../pep-0484.txt:867
msgid ""
"A situation where this occurs commonly is the definition of a container "
"class, where the class being defined occurs in the signature of some of "
"the methods.  For example, the following code (the start of a simple "
"binary tree implementation) does not work::"
msgstr ""

#: ../../pep-0484.txt:877
msgid "To address this, we write::"
msgstr ""

#: ../../pep-0484.txt:884
msgid ""
"The string literal should contain a valid Python expression (i.e., "
"``compile(lit, '', 'eval')`` should be a valid code object) and it should"
" evaluate without errors once the module has been fully loaded. The local"
" and global namespace in which it is evaluated should be the same "
"namespaces in which default arguments to the same function would be "
"evaluated."
msgstr ""

#: ../../pep-0484.txt:891
msgid ""
"Moreover, the expression should be parseable as a valid type hint, i.e., "
"it is constrained by the rules from the section `Acceptable type hints`_ "
"above."
msgstr ""

#: ../../pep-0484.txt:895
msgid ""
"It is allowable to use string literals as *part* of a type hint, for "
"example::"
msgstr ""

#: ../../pep-0484.txt:903
msgid ""
"A common use for forward references is when e.g. Django models are needed"
" in the signatures.  Typically, each model is in a separate file, and has"
" methods taking arguments whose type involves other models. Because of "
"the way circular imports work in Python, it is often not possible to "
"import all the needed models directly::"
msgstr ""

#: ../../pep-0484.txt:923
msgid ""
"Assuming main is imported first, this will fail with an ImportError at "
"the line ``from models.a import A`` in models/b.py, which is being "
"imported from models/a.py before a has defined class A.  The solution is "
"to switch to module-only imports and reference the models by their "
"_module_._class_ name::"
msgstr ""

#: ../../pep-0484.txt:945
msgid "Union types"
msgstr ""

#: ../../pep-0484.txt:947
msgid ""
"Since accepting a small, limited set of expected types for a single "
"argument is common, there is a new special factory called ``Union``. "
"Example::"
msgstr ""

#: ../../pep-0484.txt:958
msgid ""
"A type factored by ``Union[T1, T2, ...]`` is a supertype of all types "
"``T1``, ``T2``, etc., so that a value that is a member of one of these "
"types is acceptable for an argument annotated by ``Union[T1, T2, ...]``."
msgstr ""

#: ../../pep-0484.txt:963
msgid ""
"One common case of union types are *optional* types.  By default, "
"``None`` is an invalid value for any type, unless a default value of "
"``None`` has been provided in the function definition.  Examples::"
msgstr ""

#: ../../pep-0484.txt:969
msgid ""
"As a shorthand for ``Union[T1, None]`` you can write ``Optional[T1]``; "
"for example, the above is equivalent to::"
msgstr ""

#: ../../pep-0484.txt:976
msgid ""
"A past version of this PEP allowed type checkers to assume an optional "
"type when the default value is ``None``, as in this code::"
msgstr ""

#: ../../pep-0484.txt:981
msgid "This would have been treated as equivalent to::"
msgstr ""

#: ../../pep-0484.txt:985
msgid ""
"This is no longer the recommended behavior. Type checkers should move "
"towards requiring the optional type to be made explicit."
msgstr ""

#: ../../pep-0484.txt:989
msgid "Support for singleton types in unions"
msgstr ""

#: ../../pep-0484.txt:991
msgid ""
"A singleton instance is frequently used to mark some special condition, "
"in particular in situations where ``None`` is also a valid value for a "
"variable. Example::"
msgstr ""

#: ../../pep-0484.txt:1005
msgid ""
"To allow precise typing in such situations, the user should use the "
"``Union`` type in conjunction with the ``enum.Enum`` class provided by "
"the standard library, so that type errors can be caught statically::"
msgstr ""

#: ../../pep-0484.txt:1027
msgid ""
"Since the subclasses of ``Enum`` cannot be further subclassed, the type "
"of variable ``x`` can be statically inferred in all branches of the above"
" example. The same approach is applicable if more than one singleton "
"object is needed: one can use an enumeration that has more than one "
"value::"
msgstr ""

#: ../../pep-0484.txt:1048
msgid "The ``Any`` type"
msgstr ""

#: ../../pep-0484.txt:1050
msgid ""
"A special kind of type is ``Any``.  Every type is consistent with "
"``Any``.  It can be considered a type that has all values and all "
"methods. Note that ``Any`` and builtin type ``object`` are completely "
"different."
msgstr ""

#: ../../pep-0484.txt:1054
msgid ""
"When the type of a value is ``object``, the type checker will reject "
"almost all operations on it, and assigning it to a variable (or using it "
"as a return value) of a more specialized type is a type error.  On the "
"other hand, when a value has type ``Any``, the type checker will allow "
"all operations on it, and a value of type ``Any`` can be assigned to a "
"variable (or used as a return value) of a more constrained type."
msgstr ""

#: ../../pep-0484.txt:1061
msgid ""
"A function parameter without an annotation is assumed to be annotated "
"with ``Any``. If a generic type is used without specifying type "
"parameters, they are assumed to be ``Any``::"
msgstr ""

#: ../../pep-0484.txt:1070
msgid ""
"This rule also applies to ``Tuple``, in annotation context it is "
"equivalent to ``Tuple[Any, ...]`` and, in turn, to ``tuple``. As well, a "
"bare ``Callable`` in an annotation is equivalent to ``Callable[..., "
"Any]`` and, in turn, to ``collections.abc.Callable``::"
msgstr ""

#: ../../pep-0484.txt:1090
msgid "The ``NoReturn`` type"
msgstr ""

#: ../../pep-0484.txt:1092
msgid ""
"The ``typing`` module provides a special type ``NoReturn`` to annotate "
"functions that never return normally. For example, a function that "
"unconditionally raises an exception::"
msgstr ""

#: ../../pep-0484.txt:1101
msgid ""
"The ``NoReturn`` annotation is used for functions such as ``sys.exit``. "
"Static type checkers will ensure that functions annotated as returning "
"``NoReturn`` truly never return, either implicitly or explicitly::"
msgstr ""

#: ../../pep-0484.txt:1112
msgid ""
"The checkers will also recognize that the code after calls to such "
"functions is unreachable and will behave accordingly::"
msgstr ""

#: ../../pep-0484.txt:1123
msgid ""
"The ``NoReturn`` type is only valid as a return annotation of functions, "
"and considered an error if it appears in other positions::"
msgstr ""

#: ../../pep-0484.txt:1137
msgid "The type of class objects"
msgstr ""

#: ../../pep-0484.txt:1139
msgid ""
"Sometimes you want to talk about class objects, in particular class "
"objects that inherit from a given class.  This can be spelled as "
"``Type[C]`` where ``C`` is a class.  To clarify: while ``C`` (when used "
"as an annotation) refers to instances of class ``C``, ``Type[C]`` refers "
"to *subclasses* of ``C``.  (This is a similar distinction as between "
"``object`` and ``type``.)"
msgstr ""

#: ../../pep-0484.txt:1146
msgid "For example, suppose we have the following classes::"
msgstr ""

#: ../../pep-0484.txt:1153
msgid ""
"And suppose we have a function that creates an instance of one of these "
"classes if you pass it a class object::"
msgstr ""

#: ../../pep-0484.txt:1161
msgid ""
"Without ``Type[]`` the best we could do to annotate ``new_user()`` would "
"be::"
msgstr ""

#: ../../pep-0484.txt:1167
msgid ""
"However using ``Type[]`` and a type variable with an upper bound we can "
"do much better::"
msgstr ""

#: ../../pep-0484.txt:1174
msgid ""
"Now when we call ``new_user()`` with a specific subclass of ``User`` a "
"type checker will infer the correct type of the result::"
msgstr ""

#: ../../pep-0484.txt:1179
msgid ""
"The value corresponding to ``Type[C]`` must be an actual class object "
"that's a subtype of ``C``, not a special form.  In other words, in the "
"above example calling e.g. ``new_user(Union[BasicUser, ProUser])`` is "
"rejected by the type checker (in addition to failing at runtime because "
"you can't instantiate a union)."
msgstr ""

#: ../../pep-0484.txt:1185
msgid ""
"Note that it is legal to use a union of classes as the parameter for "
"``Type[]``, as in::"
msgstr ""

#: ../../pep-0484.txt:1192
msgid ""
"However the actual argument passed in at runtime must still be a concrete"
" class object, e.g. in the above example::"
msgstr ""

#: ../../pep-0484.txt:1198
msgid "``Type[Any]`` is also supported (see below for its meaning)."
msgstr ""

#: ../../pep-0484.txt:1200
msgid ""
"``Type[T]`` where ``T`` is a type variable is allowed when annotating the"
" first argument of a class method (see the relevant section)."
msgstr ""

#: ../../pep-0484.txt:1203
msgid ""
"Any other special constructs like ``Tuple`` or ``Callable`` are not "
"allowed as an argument to ``Type``."
msgstr ""

#: ../../pep-0484.txt:1206
msgid ""
"There are some concerns with this feature: for example when "
"``new_user()`` calls ``user_class()`` this implies that all subclasses of"
" ``User`` must support this in their constructor signature.  However this"
" is not unique to ``Type[]``: class methods have similar concerns. A type"
" checker ought to flag violations of such assumptions, but by default "
"constructor calls that match the constructor signature in the indicated "
"base class (``User`` in the example above) should be allowed.  A program "
"containing a complex or extensible class hierarchy might also handle this"
" by using a factory class method.  A future revision of this PEP may "
"introduce better ways of dealing with these concerns."
msgstr ""

#: ../../pep-0484.txt:1218
msgid ""
"When ``Type`` is parameterized it requires exactly one parameter. Plain "
"``Type`` without brackets is equivalent to ``Type[Any]`` and this in turn"
" is equivalent to ``type`` (the root of Python's metaclass hierarchy).  "
"This equivalence also motivates the name, ``Type``, as opposed to "
"alternatives like ``Class`` or ``SubType``, which were proposed while "
"this feature was under discussion; this is similar to the relationship "
"between e.g. ``List`` and ``list``."
msgstr ""

#: ../../pep-0484.txt:1226
msgid ""
"Regarding the behavior of ``Type[Any]`` (or ``Type`` or ``type``), "
"accessing attributes of a variable with this type only provides "
"attributes and methods defined by ``type`` (for example, ``__repr__()`` "
"and ``__mro__``).  Such a variable can be called with arbitrary "
"arguments, and the return type is ``Any``."
msgstr ""

#: ../../pep-0484.txt:1232
msgid ""
"``Type`` is covariant in its parameter, because ``Type[Derived]`` is a "
"subtype of ``Type[Base]``::"
msgstr ""

#: ../../pep-0484.txt:1241
msgid "Annotating instance and class methods"
msgstr ""

#: ../../pep-0484.txt:1243
msgid ""
"In most cases the first argument of class and instance methods does not "
"need to be annotated, and it is assumed to have the type of the "
"containing class for instance methods, and a type object type "
"corresponding to the containing class object for class methods. In "
"addition, the first argument in an instance method can be annotated with "
"a type variable. In this case the return type may use the same type "
"variable, thus making that method a generic function. For example::"
msgstr ""

#: ../../pep-0484.txt:1260
msgid ""
"The same applies to class methods using ``Type[]`` in an annotation of "
"the first argument::"
msgstr ""

#: ../../pep-0484.txt:1272
msgid ""
"Note that some type checkers may apply restrictions on this use, such as "
"requiring an appropriate upper bound for the type variable used (see "
"examples)."
msgstr ""

#: ../../pep-0484.txt:1278
msgid "Version and platform checking"
msgstr ""

#: ../../pep-0484.txt:1280
msgid ""
"Type checkers are expected to understand simple version and platform "
"checks, e.g.::"
msgstr ""

#: ../../pep-0484.txt:1295
msgid ""
"Don't expect a checker to understand obfuscations like "
"``\"\".join(reversed(sys.platform)) == \"xunil\"``."
msgstr ""

#: ../../pep-0484.txt:1300
msgid "Runtime or type checking?"
msgstr ""

#: ../../pep-0484.txt:1302
msgid ""
"Sometimes there's code that must be seen by a type checker (or other "
"static analysis tools) but should not be executed.  For such situations "
"the ``typing`` module defines a constant, ``TYPE_CHECKING``, that is "
"considered ``True`` during type checking (or other static analysis) but "
"``False`` at runtime.  Example::"
msgstr ""

#: ../../pep-0484.txt:1317
msgid ""
"(Note that the type annotation must be enclosed in quotes, making it a "
"\"forward reference\", to hide the ``expensive_mod`` reference from the "
"interpreter runtime.  In the ``# type`` comment no quotes are needed.)"
msgstr ""

#: ../../pep-0484.txt:1321
msgid "This approach may also be useful to handle import cycles."
msgstr ""

#: ../../pep-0484.txt:1325
msgid "Arbitrary argument lists and default argument values"
msgstr ""

#: ../../pep-0484.txt:1327
msgid ""
"Arbitrary argument lists can as well be type annotated, so that the "
"definition::"
msgstr ""

#: ../../pep-0484.txt:1332
msgid ""
"is acceptable and it means that, e.g., all of the following represent "
"function calls with valid types of arguments::"
msgstr ""

#: ../../pep-0484.txt:1339
msgid ""
"In the body of function ``foo``, the type of variable ``args`` is deduced"
" as ``Tuple[str, ...]`` and the type of variable ``kwds`` is ``Dict[str, "
"int]``."
msgstr ""

#: ../../pep-0484.txt:1343
msgid ""
"In stubs it may be useful to declare an argument as having a default "
"without specifying the actual default value.  For example::"
msgstr ""

#: ../../pep-0484.txt:1348
msgid ""
"What should the default value look like?  Any of the options ``\"\"``, "
"``b\"\"`` or ``None`` fails to satisfy the type constraint."
msgstr ""

#: ../../pep-0484.txt:1351
msgid ""
"In such cases the default value may be specified as a literal ellipsis, "
"i.e. the above example is literally what you would write."
msgstr ""

#: ../../pep-0484.txt:1356
msgid "Positional-only arguments"
msgstr ""

#: ../../pep-0484.txt:1358
msgid ""
"Some functions are designed to take their arguments only positionally, "
"and expect their callers never to use the argument's name to provide that"
" argument by keyword. All arguments with names beginning with ``__`` are "
"assumed to be positional-only, except if their names also end with "
"``__``::"
msgstr ""

#: ../../pep-0484.txt:1372
msgid "Annotating generator functions and coroutines"
msgstr ""

#: ../../pep-0484.txt:1374
msgid ""
"The return type of generator functions can be annotated by the generic "
"type ``Generator[yield_type, send_type, return_type]`` provided by "
"``typing.py`` module::"
msgstr ""

#: ../../pep-0484.txt:1384
msgid ""
"Coroutines introduced in PEP 492 are annotated with the same syntax as "
"ordinary functions. However, the return type annotation corresponds to "
"the type of ``await`` expression, not to the coroutine type::"
msgstr ""

#: ../../pep-0484.txt:1394
msgid ""
"The ``typing.py`` module provides a generic version of ABC "
"``collections.abc.Coroutine`` to specify awaitables that also support "
"``send()`` and ``throw()`` methods. The variance and order of type "
"variables correspond to those of ``Generator``, namely ``Coroutine[T_co, "
"T_contra, V_co]``, for example::"
msgstr ""

#: ../../pep-0484.txt:1407
msgid ""
"The module also provides generic ABCs ``Awaitable``, ``AsyncIterable``, "
"and ``AsyncIterator`` for situations where more precise types cannot be "
"specified::"
msgstr ""

#: ../../pep-0484.txt:1419
msgid "Compatibility with other uses of function annotations"
msgstr ""

#: ../../pep-0484.txt:1421
msgid ""
"A number of existing or potential use cases for function annotations "
"exist, which are incompatible with type hinting.  These may confuse a "
"static type checker.  However, since type hinting annotations have no "
"runtime behavior (other than evaluation of the annotation expression and "
"storing annotations in the ``__annotations__`` attribute of the function "
"object), this does not make the program incorrect -- it just may cause a "
"type checker to emit spurious warnings or errors."
msgstr ""

#: ../../pep-0484.txt:1429
msgid ""
"To mark portions of the program that should not be covered by type "
"hinting, you can use one or more of the following:"
msgstr ""

#: ../../pep-0484.txt:1432
msgid "a ``# type: ignore`` comment;"
msgstr ""

#: ../../pep-0484.txt:1434
msgid "a ``@no_type_check`` decorator on a class or function;"
msgstr ""

#: ../../pep-0484.txt:1436
msgid ""
"a custom class or function decorator marked with "
"``@no_type_check_decorator``."
msgstr ""

#: ../../pep-0484.txt:1439
msgid "For more details see later sections."
msgstr ""

#: ../../pep-0484.txt:1441
msgid ""
"In order for maximal compatibility with offline type checking it may "
"eventually be a good idea to change interfaces that rely on annotations "
"to switch to a different mechanism, for example a decorator.  In Python "
"3.5 there is no pressure to do this, however.  See also the longer "
"discussion under `Rejected alternatives`_ below."
msgstr ""

#: ../../pep-0484.txt:1449
msgid "Type comments"
msgstr ""

#: ../../pep-0484.txt:1451
msgid ""
"No first-class syntax support for explicitly marking variables as being "
"of a specific type is added by this PEP.  To help with type inference in "
"complex cases, a comment of the following format may be used::"
msgstr ""

#: ../../pep-0484.txt:1461
msgid ""
"Type comments should be put on the last line of the statement that "
"contains the variable definition. They can also be placed on ``with`` "
"statements and ``for`` statements, right after the colon."
msgstr ""

#: ../../pep-0484.txt:1465
msgid "Examples of type comments on ``with`` and ``for`` statements::"
msgstr ""

#: ../../pep-0484.txt:1475
msgid ""
"In stubs it may be useful to declare the existence of a variable without "
"giving it an initial value.  This can be done using PEP 526 variable "
"annotation syntax::"
msgstr ""

#: ../../pep-0484.txt:1483
msgid ""
"The above syntax is acceptable in stubs for all versions of Python. "
"However, in non-stub code for versions of Python 3.5 and earlier there is"
" a special case::"
msgstr ""

#: ../../pep-0484.txt:1491
msgid ""
"Type checkers should not complain about this (despite the value ``None`` "
"not matching the given type), nor should they change the inferred type to"
" ``Optional[...]`` (despite the rule that does this for annotated "
"arguments with a default value of ``None``).  The assumption here is that"
" other code will ensure that the variable is given a value of the proper "
"type, and all uses can assume that the variable has the given type."
msgstr ""

#: ../../pep-0484.txt:1499
msgid ""
"The ``# type: ignore`` comment should be put on the line that the error "
"refers to::"
msgstr ""

#: ../../pep-0484.txt:1507
msgid ""
"A ``# type: ignore`` comment on a line by itself at the top of a file, "
"before any docstrings, imports, or other executable code, silences all "
"errors in the file. Blank lines and other comments, such as shebang lines"
" and coding cookies, may precede the ``# type: ignore`` comment."
msgstr ""

#: ../../pep-0484.txt:1512
msgid ""
"In some cases, linting tools or other comments may be needed on the same "
"line as a type comment. In these cases, the type comment should be before"
" other comments and linting markers:"
msgstr ""

#: ../../pep-0484.txt:1516
msgid "# type: ignore # <comment or other marker>"
msgstr ""

#: ../../pep-0484.txt:1518
msgid ""
"If type hinting proves useful in general, a syntax for typing variables "
"may be provided in a future Python version. (**UPDATE**: This syntax was "
"added in Python 3.6 through PEP 526.)"
msgstr ""

#: ../../pep-0484.txt:1523
msgid "Casts"
msgstr ""

#: ../../pep-0484.txt:1525
msgid ""
"Occasionally the type checker may need a different kind of hint: the "
"programmer may know that an expression is of a more constrained type than"
" a type checker may be able to infer.  For example::"
msgstr ""

#: ../../pep-0484.txt:1536
msgid ""
"Some type checkers may not be able to infer that the type of ``a[index]``"
" is ``str`` and only infer ``object`` or ``Any``, but we know that (if "
"the code gets to that point) it must be a string.  The ``cast(t, x)`` "
"call tells the type checker that we are confident that the type of ``x`` "
"is ``t``.  At runtime a cast always returns the expression unchanged -- "
"it does not check the type, and it does not convert or coerce the value."
msgstr ""

#: ../../pep-0484.txt:1544
msgid ""
"Casts differ from type comments (see the previous section).  When using a"
" type comment, the type checker should still verify that the inferred "
"type is consistent with the stated type.  When using a cast, the type "
"checker should blindly believe the programmer.  Also, casts can be used "
"in expressions, while type comments only apply to assignments."
msgstr ""

#: ../../pep-0484.txt:1552
msgid "NewType helper function"
msgstr ""

#: ../../pep-0484.txt:1554
msgid ""
"There are also situations where a programmer might want to avoid logical "
"errors by creating simple classes. For example::"
msgstr ""

#: ../../pep-0484.txt:1563
msgid ""
"However, this approach introduces a runtime overhead. To avoid this, "
"``typing.py`` provides a helper function ``NewType`` that creates simple "
"unique types with almost zero runtime overhead. For a static type checker"
" ``Derived = NewType('Derived', Base)`` is roughly equivalent to a "
"definition::"
msgstr ""

#: ../../pep-0484.txt:1573
msgid ""
"While at runtime, ``NewType('Derived', Base)`` returns a dummy function "
"that simply returns its argument. Type checkers require explicit casts "
"from ``int`` where ``UserId`` is expected, while implicitly casting from "
"``UserId`` where ``int`` is expected. Examples::"
msgstr ""

#: ../../pep-0484.txt:1590
msgid ""
"``NewType`` accepts exactly two arguments: a name for the new unique "
"type, and a base class. The latter should be a proper class (i.e., not a "
"type construct like ``Union``, etc.), or another unique type created by "
"calling ``NewType``. The function returned by ``NewType`` accepts only "
"one argument; this is equivalent to supporting only one constructor "
"accepting an instance of the base class (see above). Example::"
msgstr ""

#: ../../pep-0484.txt:1609
msgid ""
"Both ``isinstance`` and ``issubclass``, as well as subclassing will fail "
"for ``NewType('Derived', Base)`` since function objects don't support "
"these operations."
msgstr ""

#: ../../pep-0484.txt:1615
msgid "Stub Files"
msgstr ""

#: ../../pep-0484.txt:1617
msgid ""
"Stub files are files containing type hints that are only for use by the "
"type checker, not at runtime.  There are several use cases for stub "
"files:"
msgstr ""

#: ../../pep-0484.txt:1621
msgid "Extension modules"
msgstr ""

#: ../../pep-0484.txt:1623
msgid "Third-party modules whose authors have not yet added type hints"
msgstr ""

#: ../../pep-0484.txt:1625
msgid "Standard library modules for which type hints have not yet been written"
msgstr ""

#: ../../pep-0484.txt:1628
msgid "Modules that must be compatible with Python 2 and 3"
msgstr ""

#: ../../pep-0484.txt:1630
msgid "Modules that use annotations for other purposes"
msgstr ""

#: ../../pep-0484.txt:1632
msgid ""
"Stub files have the same syntax as regular Python modules.  There is one "
"feature of the ``typing`` module that is different in stub files: the "
"``@overload`` decorator described below."
msgstr ""

#: ../../pep-0484.txt:1636
msgid ""
"The type checker should only check function signatures in stub files; It "
"is recommended that function bodies in stub files just be a single "
"ellipsis (``...``)."
msgstr ""

#: ../../pep-0484.txt:1640
msgid ""
"The type checker should have a configurable search path for stub files. "
"If a stub file is found the type checker should not read the "
"corresponding \"real\" module."
msgstr ""

#: ../../pep-0484.txt:1644
msgid ""
"While stub files are syntactically valid Python modules, they use the "
"``.pyi`` extension to make it possible to maintain stub files in the same"
" directory as the corresponding real module.  This also reinforces the "
"notion that no runtime behavior should be expected of stub files."
msgstr ""

#: ../../pep-0484.txt:1649
msgid "Additional notes on stub files:"
msgstr ""

#: ../../pep-0484.txt:1651
msgid ""
"Modules and variables imported into the stub are not considered exported "
"from the stub unless the import uses the ``import ... as ...`` form or "
"the equivalent ``from ... import ... as ...`` form. (*UPDATE:* To "
"clarify, the intention here is that only names imported using the form "
"``X as X`` will be exported, i.e. the name before and after ``as`` must "
"be the same.)"
msgstr ""

#: ../../pep-0484.txt:1658
msgid ""
"However, as an exception to the previous bullet, all objects imported "
"into a stub using ``from ... import *`` are considered exported.  (This "
"makes it easier to re-export all objects from a given module that may "
"vary by Python version.)"
msgstr ""

#: ../../pep-0484.txt:1663
msgid ""
"Just like in normal Python files [importdocs]_, submodules automatically "
"become exported attributes of their parent module when imported. For "
"example, if the ``spam`` package has the following directory structure::"
msgstr ""

#: ../../pep-0484.txt:1672
msgid ""
"where ``__init__.pyi`` contains a line such as ``from . import ham`` or "
"``from .ham import Ham``, then ``ham`` is an exported attribute of "
"``spam``."
msgstr ""

#: ../../pep-0484.txt:1676
msgid ""
"Stub files may be incomplete. To make type checkers aware of this, the "
"file can contain the following code::"
msgstr ""

#: ../../pep-0484.txt:1681
msgid ""
"Any identifier not defined in the stub is therefore assumed to be of type"
" ``Any``."
msgstr ""

#: ../../pep-0484.txt:1685
msgid "Function/method overloading"
msgstr ""

#: ../../pep-0484.txt:1687
msgid ""
"The ``@overload`` decorator allows describing functions and methods that "
"support multiple different combinations of argument types.  This pattern "
"is used frequently in builtin modules and types.  For example, the "
"``__getitem__()`` method of the ``bytes`` type can be described as "
"follows::"
msgstr ""

#: ../../pep-0484.txt:1702
msgid ""
"This description is more precise than would be possible using unions "
"(which cannot express the relationship between the argument and return "
"types)::"
msgstr ""

#: ../../pep-0484.txt:1712
msgid ""
"Another example where ``@overload`` comes in handy is the type of the "
"builtin ``map()`` function, which takes a different number of arguments "
"depending on the type of the callable::"
msgstr ""

#: ../../pep-0484.txt:1729
msgid "Note that we could also easily add items to support ``map(None, ...)``::"
msgstr ""

#: ../../pep-0484.txt:1738
msgid ""
"Uses of the ``@overload`` decorator as shown above are suitable for stub "
"files.  In regular modules, a series of ``@overload``-decorated "
"definitions must be followed by exactly one non-``@overload``-decorated "
"definition (for the same function/method). The ``@overload``-decorated "
"definitions are for the benefit of the type checker only, since they will"
" be overwritten by the non-``@overload``-decorated definition, while the "
"latter is used at runtime but should be ignored by a type checker.  At "
"runtime, calling a ``@overload``-decorated function directly will raise "
"``NotImplementedError``.  Here's an example of a non-stub overload that "
"can't easily be expressed using a union or a type variable::"
msgstr ""

#: ../../pep-0484.txt:1762
msgid ""
"NOTE: While it would be possible to provide a multiple dispatch "
"implementation using this syntax, its implementation would require using "
"``sys._getframe()``, which is frowned upon.  Also, designing and "
"implementing an efficient multiple dispatch mechanism is hard, which is "
"why previous attempts were abandoned in favor of "
"``functools.singledispatch()``.  (See PEP 443, especially its section "
"\"Alternative approaches\".)  In the future we may come up with a "
"satisfactory multiple dispatch design, but we don't want such a design to"
" be constrained by the overloading syntax defined for type hints in stub "
"files.  It is also possible that both features will develop independent "
"from each other (since overloading in the type checker has different use "
"cases and requirements than multiple dispatch at runtime -- e.g. the "
"latter is unlikely to support generic types)."
msgstr ""

#: ../../pep-0484.txt:1776
msgid ""
"A constrained ``TypeVar`` type can often be used instead of using the "
"``@overload`` decorator.  For example, the definitions of ``concat1`` and"
" ``concat2`` in this stub file are equivalent::"
msgstr ""

#: ../../pep-0484.txt:1791
msgid ""
"Some functions, such as ``map`` or ``bytes.__getitem__`` above, can't be "
"represented precisely using type variables.  However, unlike "
"``@overload``, type variables can also be used outside stub files.  We "
"recommend that ``@overload`` is only used in cases where a type variable "
"is not sufficient, due to its special stub-only status."
msgstr ""

#: ../../pep-0484.txt:1797
msgid ""
"Another important difference between type variables such as ``AnyStr`` "
"and using ``@overload`` is that the prior can also be used to define "
"constraints for generic class type parameters.  For example, the type "
"parameter of the generic class ``typing.IO`` is constrained (only "
"``IO[str]``, ``IO[bytes]`` and ``IO[Any]`` are valid)::"
msgstr ""

#: ../../pep-0484.txt:1806
msgid "Storing and distributing stub files"
msgstr ""

#: ../../pep-0484.txt:1808
msgid ""
"The easiest form of stub file storage and distribution is to put them "
"alongside Python modules in the same directory.  This makes them easy to "
"find by both programmers and the tools.  However, since package "
"maintainers are free not to add type hinting to their packages, third-"
"party stubs installable by ``pip`` from PyPI are also supported. In this "
"case we have to consider three issues: naming, versioning, installation "
"path."
msgstr ""

#: ../../pep-0484.txt:1816
msgid ""
"This PEP does not provide a recommendation on a naming scheme that should"
" be used for third-party stub file packages.  Discoverability will "
"hopefully be based on package popularity, like with Django packages for "
"example."
msgstr ""

#: ../../pep-0484.txt:1821
msgid ""
"Third-party stubs have to be versioned using the lowest version of the "
"source package that is compatible.  Example: FooPackage has versions 1.0,"
" 1.1, 1.2, 1.3, 2.0, 2.1, 2.2.  There are API changes in versions 1.1, "
"2.0 and 2.2.  The stub file package maintainer is free to release stubs "
"for all versions but at least 1.0, 1.1, 2.0 and 2.2 are needed to enable "
"the end user type check all versions.  This is because the user knows "
"that the closest *lower or equal* version of stubs is compatible.  In the"
" provided example, for FooPackage 1.3 the user would choose stubs version"
" 1.1."
msgstr ""

#: ../../pep-0484.txt:1831
msgid ""
"Note that if the user decides to use the \"latest\" available source "
"package, using the \"latest\" stub files should generally also work if "
"they're updated often."
msgstr ""

#: ../../pep-0484.txt:1835
msgid ""
"Third-party stub packages can use any location for stub storage.  Type "
"checkers should search for them using PYTHONPATH.  A default fallback "
"directory that is always checked is ``shared/typehints/pythonX.Y/`` (for "
"some PythonX.Y as determined by the type checker, not just the installed "
"version).  Since there can only be one package installed for a given "
"Python version per environment, no additional versioning is performed "
"under that directory (just like bare directory installs by ``pip`` in "
"site-packages). Stub file package authors might use the following snippet"
" in ``setup.py``::"
msgstr ""

#: ../../pep-0484.txt:1853
msgid ""
"(*UPDATE:* As of June 2018 the recommended way to distribute type hints "
"for third-party packages has changed -- in addition to typeshed (see the "
"next section) there is now a standard for distributing type hints, PEP "
"561. It supports separately installable packages containing stubs, stub "
"files included in the same distribution as the executable code of a "
"package, and inline type hints, the latter two options enabled by "
"including a file named ``py.typed`` in the package.)"
msgstr ""

#: ../../pep-0484.txt:1862
msgid "The Typeshed Repo"
msgstr ""

#: ../../pep-0484.txt:1864
msgid ""
"There is a shared repository where useful stubs are being collected "
"[typeshed]_.  Policies regarding the stubs collected here will be decided"
" separately and reported in the repo's documentation. Note that stubs for"
" a given package will not be included here if the package owners have "
"specifically requested that they be omitted."
msgstr ""

#: ../../pep-0484.txt:1872
msgid "Exceptions"
msgstr ""

#: ../../pep-0484.txt:1874
msgid ""
"No syntax for listing explicitly raised exceptions is proposed. Currently"
" the only known use case for this feature is documentational, in which "
"case the recommendation is to put this information in a docstring."
msgstr ""

#: ../../pep-0484.txt:1881
msgid "The ``typing`` Module"
msgstr ""

#: ../../pep-0484.txt:1883
msgid ""
"To open the usage of static type checking to Python 3.5 as well as older "
"versions, a uniform namespace is required.  For this purpose, a new "
"module in the standard library is introduced called ``typing``."
msgstr ""

#: ../../pep-0484.txt:1887
msgid ""
"It defines the fundamental building blocks for constructing types (e.g. "
"``Any``), types representing generic variants of builtin collections "
"(e.g. ``List``), types representing generic collection ABCs (e.g. "
"``Sequence``), and a small collection of convenience definitions."
msgstr ""

#: ../../pep-0484.txt:1893
msgid ""
"Note that special type constructs, such as ``Any``, ``Union``, and type "
"variables defined using ``TypeVar`` are only supported in the type "
"annotation context, and ``Generic`` may only be used as a base class. All"
" of these (except for unparameterized generics) will raise ``TypeError`` "
"if appear in ``isinstance`` or ``issubclass``."
msgstr ""

#: ../../pep-0484.txt:1899
msgid "Fundamental building blocks:"
msgstr ""

#: ../../pep-0484.txt:1901
msgid "Any, used as ``def get(key: str) -> Any: ...``"
msgstr ""

#: ../../pep-0484.txt:1903
msgid "Union, used as ``Union[Type1, Type2, Type3]``"
msgstr ""

#: ../../pep-0484.txt:1905
msgid "Callable, used as ``Callable[[Arg1Type, Arg2Type], ReturnType]``"
msgstr ""

#: ../../pep-0484.txt:1907
msgid ""
"Tuple, used by listing the element types, for example ``Tuple[int, int, "
"str]``. The empty tuple can be typed as ``Tuple[()]``. Arbitrary-length "
"homogeneous tuples can be expressed using one type and ellipsis, for "
"example ``Tuple[int, ...]``. (The ``...`` here are part of the syntax, a "
"literal ellipsis.)"
msgstr ""

#: ../../pep-0484.txt:1914
msgid ""
"TypeVar, used as ``X = TypeVar('X', Type1, Type2, Type3)`` or simply ``Y "
"= TypeVar('Y')`` (see above for more details)"
msgstr ""

#: ../../pep-0484.txt:1917
msgid "Generic, used to create user-defined generic classes"
msgstr ""

#: ../../pep-0484.txt:1919
msgid "Type, used to annotate class objects"
msgstr ""

#: ../../pep-0484.txt:1921
msgid "Generic variants of builtin collections:"
msgstr ""

#: ../../pep-0484.txt:1923
msgid "Dict, used as ``Dict[key_type, value_type]``"
msgstr ""

#: ../../pep-0484.txt:1925
msgid ""
"DefaultDict, used as ``DefaultDict[key_type, value_type]``, a generic "
"variant of ``collections.defaultdict``"
msgstr ""

#: ../../pep-0484.txt:1928
msgid "List, used as ``List[element_type]``"
msgstr ""

#: ../../pep-0484.txt:1930
msgid "Set, used as ``Set[element_type]``. See remark for ``AbstractSet`` below."
msgstr ""

#: ../../pep-0484.txt:1933
msgid "FrozenSet, used as ``FrozenSet[element_type]``"
msgstr ""

#: ../../pep-0484.txt:1935
msgid ""
"Note: ``Dict``, ``DefaultDict``, ``List``, ``Set`` and ``FrozenSet`` are "
"mainly useful for annotating return values. For arguments, prefer the "
"abstract collection types defined below, e.g.  ``Mapping``, ``Sequence`` "
"or ``AbstractSet``."
msgstr ""

#: ../../pep-0484.txt:1940
msgid "Generic variants of container ABCs (and a few non-containers):"
msgstr ""

#: ../../pep-0484.txt:1942
msgid "Awaitable"
msgstr ""

#: ../../pep-0484.txt:1944
msgid "AsyncIterable"
msgstr ""

#: ../../pep-0484.txt:1946
msgid "AsyncIterator"
msgstr ""

#: ../../pep-0484.txt:1948
msgid "ByteString"
msgstr ""

#: ../../pep-0484.txt:1950
msgid "Callable (see above, listed here for completeness)"
msgstr ""

#: ../../pep-0484.txt:1952
msgid "Collection"
msgstr ""

#: ../../pep-0484.txt:1954
msgid "Container"
msgstr ""

#: ../../pep-0484.txt:1956
msgid "ContextManager"
msgstr ""

#: ../../pep-0484.txt:1958
msgid "Coroutine"
msgstr ""

#: ../../pep-0484.txt:1960
msgid ""
"Generator, used as ``Generator[yield_type, send_type, return_type]``.  "
"This represents the return value of generator functions.  It is a subtype"
" of ``Iterable`` and it has additional type variables for the type "
"accepted by the ``send()`` method (it is contravariant in this variable "
"-- a generator that accepts sending it ``Employee`` instance is valid in "
"a context where a generator is required that accepts sending it "
"``Manager`` instances) and the return type of the generator."
msgstr ""

#: ../../pep-0484.txt:1969
msgid "Hashable (not generic, but present for completeness)"
msgstr ""

#: ../../pep-0484.txt:1971
msgid "ItemsView"
msgstr ""

#: ../../pep-0484.txt:1973
msgid "Iterable"
msgstr ""

#: ../../pep-0484.txt:1975
msgid "Iterator"
msgstr ""

#: ../../pep-0484.txt:1977
msgid "KeysView"
msgstr ""

#: ../../pep-0484.txt:1979
msgid "Mapping"
msgstr ""

#: ../../pep-0484.txt:1981
msgid "MappingView"
msgstr ""

#: ../../pep-0484.txt:1983
msgid "MutableMapping"
msgstr ""

#: ../../pep-0484.txt:1985
msgid "MutableSequence"
msgstr ""

#: ../../pep-0484.txt:1987
msgid "MutableSet"
msgstr ""

#: ../../pep-0484.txt:1989
msgid "Sequence"
msgstr ""

#: ../../pep-0484.txt:1991
msgid ""
"Set, renamed to ``AbstractSet``. This name change was required because "
"``Set`` in the ``typing`` module means ``set()`` with generics."
msgstr ""

#: ../../pep-0484.txt:1995
msgid "Sized (not generic, but present for completeness)"
msgstr ""

#: ../../pep-0484.txt:1997
msgid "ValuesView"
msgstr ""

#: ../../pep-0484.txt:1999
msgid ""
"A few one-off types are defined that test for single special methods "
"(similar to ``Hashable`` or ``Sized``):"
msgstr ""

#: ../../pep-0484.txt:2002
msgid "Reversible, to test for ``__reversed__``"
msgstr ""

#: ../../pep-0484.txt:2004
msgid "SupportsAbs, to test for ``__abs__``"
msgstr ""

#: ../../pep-0484.txt:2006
msgid "SupportsComplex, to test for ``__complex__``"
msgstr ""

#: ../../pep-0484.txt:2008
msgid "SupportsFloat, to test for ``__float__``"
msgstr ""

#: ../../pep-0484.txt:2010
msgid "SupportsInt, to test for ``__int__``"
msgstr ""

#: ../../pep-0484.txt:2012
msgid "SupportsRound, to test for ``__round__``"
msgstr ""

#: ../../pep-0484.txt:2014
msgid "SupportsBytes, to test for ``__bytes__``"
msgstr ""

#: ../../pep-0484.txt:2016
msgid "Convenience definitions:"
msgstr ""

#: ../../pep-0484.txt:2018
msgid "Optional, defined by ``Optional[t] == Union[t, None]``"
msgstr ""

#: ../../pep-0484.txt:2020
msgid "Text, a simple alias for ``str`` in Python 3, for ``unicode`` in Python 2"
msgstr ""

#: ../../pep-0484.txt:2022
msgid "AnyStr, defined as ``TypeVar('AnyStr', Text, bytes)``"
msgstr ""

#: ../../pep-0484.txt:2024
msgid ""
"NamedTuple, used as ``NamedTuple(type_name, [(field_name, field_type), "
"...])`` and equivalent to ``collections.namedtuple(type_name, "
"[field_name, ...])``. This is useful to declare the types of the fields "
"of a named tuple type."
msgstr ""

#: ../../pep-0484.txt:2031
msgid ""
"NewType, used to create unique types with little runtime overhead "
"``UserId = NewType('UserId', int)``"
msgstr ""

#: ../../pep-0484.txt:2034
msgid "cast(), described earlier"
msgstr ""

#: ../../pep-0484.txt:2036
msgid ""
"@no_type_check, a decorator to disable type checking per class or "
"function (see below)"
msgstr ""

#: ../../pep-0484.txt:2039
msgid ""
"@no_type_check_decorator, a decorator to create your own decorators with "
"the same meaning as ``@no_type_check`` (see below)"
msgstr ""

#: ../../pep-0484.txt:2042
msgid ""
"@type_check_only, a decorator only available during type checking for use"
" in stub files (see above); marks a class or function as unavailable "
"during runtime"
msgstr ""

#: ../../pep-0484.txt:2046
msgid "@overload, described earlier"
msgstr ""

#: ../../pep-0484.txt:2048
msgid ""
"get_type_hints(), a utility function to retrieve the type hints from a "
"function or method.  Given a function or method object, it returns a dict"
" with the same format as ``__annotations__``, but evaluating forward "
"references (which are given as string literals) as expressions in the "
"context of the original function or method definition."
msgstr ""

#: ../../pep-0484.txt:2054
msgid "TYPE_CHECKING, ``False`` at runtime but ``True`` to  type checkers"
msgstr ""

#: ../../pep-0484.txt:2056
msgid "I/O related types:"
msgstr ""

#: ../../pep-0484.txt:2058
msgid "IO (generic over ``AnyStr``)"
msgstr ""

#: ../../pep-0484.txt:2060
msgid "BinaryIO (a simple subtype of ``IO[bytes]``)"
msgstr ""

#: ../../pep-0484.txt:2062
msgid "TextIO (a simple subtype of ``IO[str]``)"
msgstr ""

#: ../../pep-0484.txt:2064
msgid "Types related to regular expressions and the ``re`` module:"
msgstr ""

#: ../../pep-0484.txt:2066
msgid ""
"Match and Pattern, types of ``re.match()`` and ``re.compile()`` results "
"(generic over ``AnyStr``)"
msgstr ""

#: ../../pep-0484.txt:2071
msgid "Suggested syntax for Python 2.7 and straddling code"
msgstr ""

#: ../../pep-0484.txt:2073
msgid ""
"Some tools may want to support type annotations in code that must be "
"compatible with Python 2.7.  For this purpose this PEP has a suggested "
"(but not mandatory) extension where function annotations are placed in a "
"``# type:`` comment.  Such a comment must be placed immediately following"
" the function header (before the docstring).  An example: the following "
"Python 3 code::"
msgstr ""

#: ../../pep-0484.txt:2084
msgid "is equivalent to the following::"
msgstr ""

#: ../../pep-0484.txt:2091
msgid "Note that for methods, no type is needed for ``self``."
msgstr ""

#: ../../pep-0484.txt:2093
msgid "For an argument-less method it would look like this::"
msgstr ""

#: ../../pep-0484.txt:2099
msgid ""
"Sometimes you want to specify the return type for a function or method "
"without (yet) specifying the argument types.  To support this explicitly,"
" the argument list may be replaced with an ellipsis. Example::"
msgstr ""

#: ../../pep-0484.txt:2109
msgid ""
"Sometimes you have a long list of parameters and specifying their types "
"in a single ``# type:`` comment would be awkward.  To this end you may "
"list the arguments one per line and add a ``# type:`` comment per line "
"after an argument's associated comma, if any. To specify the return type "
"use the ellipsis syntax. Specifying the return type is not mandatory and "
"not every argument needs to be given a type. A line with a ``# type:`` "
"comment should contain exactly one argument. The type comment for the "
"last argument (if any) should precede the close parenthesis. Example::"
msgstr ""

#: ../../pep-0484.txt:2130
msgid "Notes:"
msgstr ""

#: ../../pep-0484.txt:2132
msgid ""
"Tools that support this syntax should support it regardless of the Python"
" version being checked.  This is necessary in order to support code that "
"straddles Python 2 and Python 3."
msgstr ""

#: ../../pep-0484.txt:2136
msgid ""
"It is not allowed for an argument or return value to have both a type "
"annotation and a type comment."
msgstr ""

#: ../../pep-0484.txt:2139
msgid ""
"When using the short form (e.g. ``# type: (str, int) -> None``) every "
"argument must be accounted for, except the first argument of instance and"
" class methods (those are usually omitted, but it's allowed to include "
"them)."
msgstr ""

#: ../../pep-0484.txt:2144
msgid ""
"The return type is mandatory for the short form.  If in Python 3 you "
"would omit some argument or the return type, the Python 2 notation should"
" use ``Any``."
msgstr ""

#: ../../pep-0484.txt:2148
msgid ""
"When using the short form, for ``*args`` and ``**kwds``, put 1 or 2 stars"
" in front of the corresponding type annotation.  (As with Python 3 "
"annotations, the annotation here denotes the type of the individual "
"argument values, not of the tuple/dict that you receive as the special "
"argument value ``args`` or ``kwds``.)"
msgstr ""

#: ../../pep-0484.txt:2154
msgid ""
"Like other type comments, any names used in the annotations must be "
"imported or defined by the module containing the annotation."
msgstr ""

#: ../../pep-0484.txt:2157
msgid "When using the short form, the entire annotation must be one line."
msgstr ""

#: ../../pep-0484.txt:2159
msgid ""
"The short form may also occur on the same line as the close parenthesis, "
"e.g.::"
msgstr ""

#: ../../pep-0484.txt:2165
msgid ""
"Misplaced type comments will be flagged as errors by a type checker. If "
"necessary, such comments could be commented twice. For example::"
msgstr ""

#: ../../pep-0484.txt:2176
msgid ""
"When checking Python 2.7 code, type checkers should treat the ``int`` and"
" ``long`` types as equivalent. For parameters typed as ``Text``, "
"arguments of type ``str`` as well as ``unicode`` should be acceptable."
msgstr ""

#: ../../pep-0484.txt:2181
msgid "Rejected Alternatives"
msgstr ""

#: ../../pep-0484.txt:2183
msgid ""
"During discussion of earlier drafts of this PEP, various objections were "
"raised and alternatives were proposed.  We discuss some of these here and"
" explain why we reject them."
msgstr ""

#: ../../pep-0484.txt:2187
msgid "Several main objections were raised."
msgstr ""

#: ../../pep-0484.txt:2190
msgid "Which brackets for generic type parameters?"
msgstr ""

#: ../../pep-0484.txt:2192
msgid ""
"Most people are familiar with the use of angular brackets (e.g. "
"``List<int>``) in languages like C++, Java, C# and Swift to express the "
"parameterization of generic types.  The problem with these is that they "
"are really hard to parse, especially for a simple-minded parser like "
"Python.  In most languages the ambiguities are usually dealt with by only"
" allowing angular brackets in specific syntactic positions, where general"
" expressions aren't allowed.  (And also by using very powerful parsing "
"techniques that can backtrack over an arbitrary section of code.)"
msgstr ""

#: ../../pep-0484.txt:2202
msgid ""
"But in Python, we'd like type expressions to be (syntactically) the same "
"as other expressions, so that we can use e.g. variable assignment to "
"create type aliases.  Consider this simple type expression::"
msgstr ""

#: ../../pep-0484.txt:2208
msgid ""
"From the Python parser's perspective, the expression begins with the same"
" four tokens (NAME, LESS, NAME, GREATER) as a chained comparison::"
msgstr ""

#: ../../pep-0484.txt:2213
msgid "We can even make up an example that could be parsed both ways::"
msgstr ""

#: ../../pep-0484.txt:2217
msgid ""
"Assuming we had angular brackets in the language, this could be "
"interpreted as either of the following two::"
msgstr ""

#: ../../pep-0484.txt:2223
msgid ""
"It would surely be possible to come up with a rule to disambiguate such "
"cases, but to most users the rules would feel arbitrary and complex.  It "
"would also require us to dramatically change the CPython parser (and "
"every other parser for Python).  It should be noted that Python's current"
" parser is intentionally \"dumb\" -- a simple grammar is easier for users"
" to reason about."
msgstr ""

#: ../../pep-0484.txt:2230
msgid ""
"For all these reasons, square brackets (e.g. ``List[int]``) are (and have"
" long been) the preferred syntax for generic type parameters. They can be"
" implemented by defining the ``__getitem__()`` method on the metaclass, "
"and no new syntax is required at all.  This option works in all recent "
"versions of Python (starting with Python 2.2). Python is not alone in "
"this syntactic choice -- generic classes in Scala also use square "
"brackets."
msgstr ""

#: ../../pep-0484.txt:2239
msgid "What about existing uses of annotations?"
msgstr ""

#: ../../pep-0484.txt:2241
msgid ""
"One line of argument points out that PEP 3107 explicitly supports the use"
" of arbitrary expressions in function annotations.  The new proposal is "
"then considered incompatible with the specification of PEP 3107."
msgstr ""

#: ../../pep-0484.txt:2246
msgid ""
"Our response to this is that, first of all, the current proposal does not"
" introduce any direct incompatibilities, so programs using annotations in"
" Python 3.4 will still work correctly and without prejudice in Python "
"3.5."
msgstr ""

#: ../../pep-0484.txt:2251
msgid ""
"We do hope that type hints will eventually become the sole use for "
"annotations, but this will require additional discussion and a "
"deprecation period after the initial roll-out of the typing module with "
"Python 3.5.  The current PEP will have provisional status (see PEP 411) "
"until Python 3.6 is released.  The fastest conceivable scheme would "
"introduce silent deprecation of non-type-hint annotations in 3.6, full "
"deprecation in 3.7, and declare type hints as the only allowed use of "
"annotations in Python 3.8.  This should give authors of packages that use"
" annotations plenty of time to devise another approach, even if type "
"hints become an overnight success."
msgstr ""

#: ../../pep-0484.txt:2262
msgid ""
"(*UPDATE:* As of fall 2017, the timeline for the end of provisional "
"status for this PEP and for the ``typing.py`` module has changed, and so "
"has the deprecation schedule for other uses of annotations.  For the "
"updated schedule see PEP 563.)"
msgstr ""

#: ../../pep-0484.txt:2267
msgid ""
"Another possible outcome would be that type hints will eventually become "
"the default meaning for annotations, but that there will always remain an"
" option to disable them.  For this purpose the current proposal defines a"
" decorator ``@no_type_check`` which disables the default interpretation "
"of annotations as type hints in a given class or function.  It also "
"defines a meta-decorator ``@no_type_check_decorator`` which can be used "
"to decorate a decorator (!), causing annotations in any function or class"
" decorated with the latter to be ignored by the type checker."
msgstr ""

#: ../../pep-0484.txt:2277
msgid ""
"There are also ``# type: ignore`` comments, and static checkers should "
"support configuration options to disable type checking in selected "
"packages."
msgstr ""

#: ../../pep-0484.txt:2281
msgid ""
"Despite all these options, proposals have been circulated to allow type "
"hints and other forms of annotations to coexist for individual arguments."
"  One proposal suggests that if an annotation for a given argument is a "
"dictionary literal, each key represents a different form of annotation, "
"and the key ``'type'`` would be use for type hints. The problem with this"
" idea and its variants is that the notation becomes very \"noisy\" and "
"hard to read.  Also, in most cases where existing libraries use "
"annotations, there would be little need to combine them with type hints."
"  So the simpler approach of selectively disabling type hints appears "
"sufficient."
msgstr ""

#: ../../pep-0484.txt:2293
msgid "The problem of forward declarations"
msgstr ""

#: ../../pep-0484.txt:2295
msgid ""
"The current proposal is admittedly sub-optimal when type hints must "
"contain forward references.  Python requires all names to be defined by "
"the time they are used.  Apart from circular imports this is rarely a "
"problem: \"use\" here means \"look up at runtime\", and with most "
"\"forward\" references there is no problem in ensuring that a name is "
"defined before the function using it is called."
msgstr ""

#: ../../pep-0484.txt:2302
msgid ""
"The problem with type hints is that annotations (per PEP 3107, and "
"similar to default values) are evaluated at the time a function is "
"defined, and thus any names used in an annotation must be already defined"
" when the function is being defined.  A common scenario is a class "
"definition whose methods need to reference the class itself in their "
"annotations.  (More general, it can also occur with mutually recursive "
"classes.)  This is natural for container types, for example::"
msgstr ""

#: ../../pep-0484.txt:2318
msgid ""
"As written this will not work, because of the peculiarity in Python that "
"class names become defined once the entire body of the class has been "
"executed.  Our solution, which isn't particularly elegant, but gets the "
"job done, is to allow using string literals in annotations. Most of the "
"time you won't have to use this though -- most *uses* of type hints are "
"expected to reference builtin types or types defined in other modules."
msgstr ""

#: ../../pep-0484.txt:2326
msgid ""
"A counterproposal would change the semantics of type hints so they aren't"
" evaluated at runtime at all (after all, type checking happens off-line, "
"so why would type hints need to be evaluated at runtime at all).  This of"
" course would run afoul of backwards compatibility, since the Python "
"interpreter doesn't actually know whether a particular annotation is "
"meant to be a type hint or something else."
msgstr ""

#: ../../pep-0484.txt:2333
msgid ""
"A compromise is possible where a ``__future__`` import could enable "
"turning *all* annotations in a given module into string literals, as "
"follows::"
msgstr ""

#: ../../pep-0484.txt:2344
msgid "Such a ``__future__`` import statement may be proposed in a separate PEP."
msgstr ""

#: ../../pep-0484.txt:2347
msgid ""
"(*UPDATE:* That ``__future__`` import statement and its consequences are "
"discussed in PEP 563.)"
msgstr ""

#: ../../pep-0484.txt:2352
msgid "The double colon"
msgstr ""

#: ../../pep-0484.txt:2354
msgid ""
"A few creative souls have tried to invent solutions for this problem. For"
" example, it was proposed to use a double colon (``::``) for type hints, "
"solving two problems at once: disambiguating between type hints and other"
" annotations, and changing the semantics to preclude runtime evaluation."
"  There are several things wrong with this idea, however."
msgstr ""

#: ../../pep-0484.txt:2360
msgid ""
"It's ugly.  The single colon in Python has many uses, and all of them "
"look familiar because they resemble the use of the colon in English text."
"  This is a general rule of thumb by which Python abides for most forms "
"of punctuation; the exceptions are typically well known from other "
"programming languages.  But this use of ``::`` is unheard of in English, "
"and in other languages (e.g. C++) it is used as a scoping operator, which"
" is a very different beast.  In contrast, the single colon for type hints"
" reads naturally -- and no wonder, since it was carefully designed for "
"this purpose (the idea long predates PEP 3107 [gvr-artima]_).  It is also"
" used in the same fashion in other languages from Pascal to Swift."
msgstr ""

#: ../../pep-0484.txt:2372
msgid "What would you do for return type annotations?"
msgstr ""

#: ../../pep-0484.txt:2374
msgid "It's actually a feature that type hints are evaluated at runtime."
msgstr ""

#: ../../pep-0484.txt:2376
msgid ""
"Making type hints available at runtime allows runtime type checkers to be"
" built on top of type hints."
msgstr ""

#: ../../pep-0484.txt:2379
msgid ""
"It catches mistakes even when the type checker is not run.  Since it is a"
" separate program, users may choose not to run it (or even install it), "
"but might still want to use type hints as a concise form of "
"documentation.  Broken type hints are no use even for documentation."
msgstr ""

#: ../../pep-0484.txt:2385
msgid ""
"Because it's new syntax, using the double colon for type hints would "
"limit them to code that works with Python 3.5 only.  By using existing "
"syntax, the current proposal can easily work for older versions of Python"
" 3.  (And in fact mypy supports Python 3.2 and newer.)"
msgstr ""

#: ../../pep-0484.txt:2391
msgid ""
"If type hints become successful we may well decide to add new syntax in "
"the future to declare the type for variables, for example ``var age: int "
"= 42``.  If we were to use a double colon for argument type hints, for "
"consistency we'd have to use the same convention for future syntax, "
"perpetuating the ugliness."
msgstr ""

#: ../../pep-0484.txt:2398
msgid "Other forms of new syntax"
msgstr ""

#: ../../pep-0484.txt:2400
msgid ""
"A few other forms of alternative syntax have been proposed, e.g. the "
"introduction of a ``where`` keyword [roberge]_, and Cobra-inspired "
"``requires`` clauses.  But these all share a problem with the double "
"colon: they won't work for earlier versions of Python 3.  The same would "
"apply to a new ``__future__`` import."
msgstr ""

#: ../../pep-0484.txt:2407
msgid "Other backwards compatible conventions"
msgstr ""

#: ../../pep-0484.txt:2409
msgid "The ideas put forward include:"
msgstr ""

#: ../../pep-0484.txt:2411
msgid ""
"A decorator, e.g. ``@typehints(name=str, returns=str)``.  This could "
"work, but it's pretty verbose (an extra line, and the argument names must"
" be repeated), and a far cry in elegance from the PEP 3107 notation."
msgstr ""

#: ../../pep-0484.txt:2416
msgid ""
"Stub files.  We do want stub files, but they are primarily useful for "
"adding type hints to existing code that doesn't lend itself to adding "
"type hints, e.g. 3rd party packages, code that needs to support both "
"Python 2 and Python 3, and especially extension modules.  For most "
"situations, having the annotations in line with the function definitions "
"makes them much more useful."
msgstr ""

#: ../../pep-0484.txt:2423
msgid ""
"Docstrings.  There is an existing convention for docstrings, based on the"
" Sphinx notation (``:type arg1: description``).  This is pretty verbose "
"(an extra line per parameter), and not very elegant. We could also make "
"up something new, but the annotation syntax is hard to beat (because it "
"was designed for this very purpose)."
msgstr ""

#: ../../pep-0484.txt:2429
msgid ""
"It's also been proposed to simply wait another release.  But what problem"
" would that solve?  It would just be procrastination."
msgstr ""

#: ../../pep-0484.txt:2434
msgid "PEP Development Process"
msgstr ""

#: ../../pep-0484.txt:2436
msgid ""
"A live draft for this PEP lives on GitHub [github]_.  There is also an "
"issue tracker [issues]_, where much of the technical discussion takes "
"place."
msgstr ""

#: ../../pep-0484.txt:2440
msgid ""
"The draft on GitHub is updated regularly in small increments.  The "
"official PEPS repo [peps_] is (usually) only updated when a new draft is "
"posted to python-dev."
msgstr ""

#: ../../pep-0484.txt:2446
msgid "Acknowledgements"
msgstr ""

#: ../../pep-0484.txt:2448
msgid ""
"This document could not be completed without valuable input, "
"encouragement and advice from Jim Baker, Jeremy Siek, Michael Matson "
"Vitousek, Andrey Vlasovskikh, Radomir Dopieralski, Peter Ludemann, and "
"the BDFL-Delegate, Mark Shannon."
msgstr ""

#: ../../pep-0484.txt:2453
msgid ""
"Influences include existing languages, libraries and frameworks mentioned"
" in PEP 482.  Many thanks to their creators, in alphabetical order: "
"Stefan Behnel, William Edwards, Greg Ewing, Larry Hastings, Anders "
"Hejlsberg, Alok Menghrajani, Travis E. Oliphant, Joe Pamer, Raoul-Gabriel"
" Urma, and Julien Verlaguet."
msgstr ""

#: ../../pep-0484.txt:2461
msgid "References"
msgstr ""

#: ../../pep-0484.txt:2464
msgid "http://mypy-lang.org"
msgstr ""

#: ../../pep-0484.txt:2467
msgid "http://www.artima.com/weblogs/viewpost.jsp?thread=85551"
msgstr ""

#: ../../pep-0484.txt:2470
#, python-format
msgid "http://en.wikipedia.org/wiki/Covariance_and_contravariance_%28computer_science%29"
msgstr ""

#: ../../pep-0484.txt:2473
msgid "https://github.com/python/typeshed/"
msgstr ""

#: ../../pep-0484.txt:2476
msgid "https://github.com/pyflakes/pyflakes/"
msgstr ""

#: ../../pep-0484.txt:2479
msgid "http://www.pylint.org"
msgstr ""

#: ../../pep-0484.txt:2482
msgid "http://aroberge.blogspot.com/2015/01/type-hinting-in-python-focus-on.html"
msgstr ""

#: ../../pep-0484.txt:2485
msgid "https://github.com/python/typing"
msgstr ""

#: ../../pep-0484.txt:2488
msgid "https://github.com/python/typing/issues"
msgstr ""

#: ../../pep-0484.txt:2491
msgid "https://hg.python.org/peps/file/tip/pep-0484.txt"
msgstr ""

#: ../../pep-0484.txt:2494
msgid "https://docs.python.org/3/reference/import.html#submodules"
msgstr ""

#: ../../pep-0484.txt:2498
msgid "Copyright"
msgstr ""

#: ../../pep-0484.txt:2500
msgid "This document has been placed in the public domain."
msgstr ""

