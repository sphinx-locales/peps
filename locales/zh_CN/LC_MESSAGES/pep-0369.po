# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0369.txt
msgid "PEP"
msgstr ""

#: ../../pep-0369.txt:1
msgid "369"
msgstr ""

#: ../../pep-0369.txt
msgid "Title"
msgstr ""

#: ../../pep-0369.txt:2
msgid "Post import hooks"
msgstr ""

#: ../../pep-0369.txt
msgid "Author"
msgstr ""

#: ../../pep-0369.txt:5
msgid "Christian Heimes <christian@python.org>"
msgstr ""

#: ../../pep-0369.txt
msgid "Status"
msgstr ""

#: ../../pep-0369.txt:6
msgid "Withdrawn"
msgstr ""

#: ../../pep-0369.txt
msgid "Type"
msgstr ""

#: ../../pep-0369.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0369.txt
msgid "Created"
msgstr ""

#: ../../pep-0369.txt:9
msgid "02-Jan-2008"
msgstr ""

#: ../../pep-0369.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0369.txt:10
msgid "2.6, 3.0"
msgstr ""

#: ../../pep-0369.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0369.txt:11
msgid "02-Dec-2012"
msgstr ""

#: ../../pep-0369.txt:15
msgid "Withdrawal Notice"
msgstr ""

#: ../../pep-0369.txt:17
msgid ""
"This PEP has been withdrawn by its author, as much of the detailed design"
" is no longer valid following the migration to importlib in Python 3.3."
msgstr ""

#: ../../pep-0369.txt:22
msgid "Abstract"
msgstr ""

#: ../../pep-0369.txt:24
msgid ""
"This PEP proposes enhancements for the import machinery to add post "
"import hooks. It is intended primarily to support the wider use of "
"abstract base classes that is expected in Python 3.0."
msgstr ""

#: ../../pep-0369.txt:28
msgid ""
"The PEP originally started as a combined PEP for lazy imports and post "
"import hooks. After some discussion on the python-dev mailing list the "
"PEP was parted in two separate PEPs. [1]_"
msgstr ""

#: ../../pep-0369.txt:34
msgid "Rationale"
msgstr ""

#: ../../pep-0369.txt:36
msgid ""
"Python has no API to hook into the import machinery and execute code "
"*after* a module is successfully loaded. The import hooks of PEP 302 are "
"about finding modules and loading modules but they were not designed to "
"as post import hooks."
msgstr ""

#: ../../pep-0369.txt:43
msgid "Use cases"
msgstr ""

#: ../../pep-0369.txt:45
msgid ""
"A use case for a post import hook is mentioned in Nick Coghlan's initial "
"posting [2]_. about callbacks on module import. It was found during the "
"development of Python 3.0 and its ABCs. We wanted to register classes "
"like decimal.Decimal with an ABC but the module should not be imported on"
" every interpreter startup. Nick came up with this example::"
msgstr ""

#: ../../pep-0369.txt:55
msgid ""
"The function ``register`` is registered as callback for the module named "
"'decimal'. When decimal is imported the function is called with the "
"module object as argument."
msgstr ""

#: ../../pep-0369.txt:59
msgid ""
"While this particular example isn't necessary in practice, (as "
"decimal.Decimal will inherit from the appropriate abstract Number base "
"class in 2.6 and 3.0), it still illustrates the principle."
msgstr ""

#: ../../pep-0369.txt:65
msgid "Existing implementations"
msgstr ""

#: ../../pep-0369.txt:67
msgid ""
"PJE's peak.util.imports [3]_ implements post load hooks. My "
"implementation shares a lot with his and it's partly based on his ideas."
msgstr ""

#: ../../pep-0369.txt:72
msgid "Post import hook implementation"
msgstr ""

#: ../../pep-0369.txt:74
msgid ""
"Post import hooks are called after a module has been loaded. The hooks "
"are callable which take one argument, the module instance. They are "
"registered by the dotted name of the module, e.g. 'os' or 'os.path'."
msgstr ""

#: ../../pep-0369.txt:78
msgid ""
"The callable are stored in the dict ``sys.post_import_hooks`` which is a "
"mapping from names (as string) to a list of callables or None."
msgstr ""

#: ../../pep-0369.txt:83
msgid "States"
msgstr ""

#: ../../pep-0369.txt:86
msgid "No hook was registered"
msgstr ""

#: ../../pep-0369.txt:88
msgid "sys.post_import_hooks contains no entry for the module"
msgstr ""

#: ../../pep-0369.txt:92
msgid "A hook is registered and the module is not loaded yet"
msgstr ""

#: ../../pep-0369.txt:94
msgid ""
"The import hook registry contains an entry "
"sys.post_import_hooks[\"name\"] = [hook1]"
msgstr ""

#: ../../pep-0369.txt:99
msgid "A module is successfully loaded"
msgstr ""

#: ../../pep-0369.txt:101
msgid ""
"The import machinery checks if sys.post_import_hooks contains post import"
" hooks for the newly loaded module. If hooks are found then the hooks are"
" called in the order they were registered with the module instance as "
"first argument. The processing of the hooks is stopped when a method "
"raises an exception. At the end the entry for the module name set to "
"None, even when an error has occurred."
msgstr ""

#: ../../pep-0369.txt:108
msgid ""
"Additionally the new ``__notified__`` slot of the module object is set to"
" ``True`` in order to prevent infinity recursions when the notification "
"method is called inside a hook. For object which don't subclass from "
"``PyModule`` a new attribute is added instead."
msgstr ""

#: ../../pep-0369.txt:115
msgid "A module can't be loaded"
msgstr ""

#: ../../pep-0369.txt:117
msgid ""
"The import hooks are neither called nor removed from the registry. It may"
" be possible to load the module later."
msgstr ""

#: ../../pep-0369.txt:122
msgid "A hook is registered but the module is already loaded"
msgstr ""

#: ../../pep-0369.txt:124
msgid "The hook is fired immediately."
msgstr ""

#: ../../pep-0369.txt:128
msgid "Invariants"
msgstr ""

#: ../../pep-0369.txt:130
msgid "The import hook system guarantees certain invariants. XXX"
msgstr ""

#: ../../pep-0369.txt:134
msgid "Sample Python implementation"
msgstr ""

#: ../../pep-0369.txt:136
msgid "A Python implementation may look like::"
msgstr ""

#: ../../pep-0369.txt:158
msgid "C API"
msgstr ""

#: ../../pep-0369.txt:161
msgid "New C API functions"
msgstr ""

#: ../../pep-0369.txt:164
msgid "``PyObject* PyImport_GetPostImportHooks(void)``"
msgstr ""

#: ../../pep-0369.txt:164
msgid "Returns the dict sys.post_import_hooks or NULL"
msgstr ""

#: ../../pep-0369.txt:170
msgid "``PyObject* PyImport_NotifyLoadedByModule(PyObject *module)``"
msgstr ""

#: ../../pep-0369.txt:167
msgid ""
"Notify the post import system that a module was requested. Returns the a "
"borrowed reference to the same module object or NULL if an error has "
"occurred. The function calls only the hooks for the module itself and not"
" its parents. The function must be called with the import lock acquired."
msgstr ""

#: ../../pep-0369.txt:179
msgid "``PyObject* PyImport_NotifyLoadedByName(const char *name)``"
msgstr ""

#: ../../pep-0369.txt:173
msgid ""
"``PyImport_NotifyLoadedByName(\"a.b.c\")`` calls "
"``PyImport_NotifyLoadedByModule()`` for ``a``, ``a.b`` and ``a.b.c`` in "
"that particular order. The modules are retrieved from ``sys.modules``. If"
" a module can't be retrieved, an exception is raised otherwise the a "
"borrowed reference to ``modname`` is returned. The hook calls always "
"start with the prime parent module. The caller of "
"PyImport_NotifyLoadedByName() must hold the import lock!"
msgstr ""

#: ../../pep-0369.txt:182
msgid ""
"``PyObject* PyImport_RegisterPostImportHook(PyObject *callable, PyObject "
"*mod_name)``"
msgstr ""

#: ../../pep-0369.txt:182
msgid "Register a new hook ``callable`` for the module ``mod_name``"
msgstr ""

#: ../../pep-0369.txt:185
msgid "``int PyModule_GetNotified(PyObject *module)``"
msgstr ""

#: ../../pep-0369.txt:185
msgid "Returns the status of the ``__notified__`` slot / attribute."
msgstr ""

#: ../../pep-0369.txt:189
msgid "``int PyModule_SetNotified(PyObject *module, int status)``"
msgstr ""

#: ../../pep-0369.txt:188
msgid "Set the status of the ``__notified__`` slot / attribute."
msgstr ""

#: ../../pep-0369.txt:191
msgid ""
"The ``PyImport_NotifyLoadedByModule()`` method is called inside "
"``import_submodule()``. The import system makes sure that the import lock"
" is acquired and the hooks for the parent modules are already called."
msgstr ""

#: ../../pep-0369.txt:197
msgid "Python API"
msgstr ""

#: ../../pep-0369.txt:199
msgid ""
"The import hook registry and two new API methods are exposed through the "
"``sys`` and ``imp`` module."
msgstr ""

#: ../../pep-0369.txt:205
msgid "``sys.post_import_hooks``"
msgstr ""

#: ../../pep-0369.txt:203
msgid "The dict contains the post import hooks::"
msgstr ""

#: ../../pep-0369.txt:208
msgid "``imp.register_post_import_hook(hook: \"callable\", name: str)``"
msgstr ""

#: ../../pep-0369.txt:208
msgid "Register a new hook *hook* for the module *name*"
msgstr ""

#: ../../pep-0369.txt:212
msgid "``imp.notify_module_loaded(module: \"module instance\") -> module``"
msgstr ""

#: ../../pep-0369.txt:211
msgid ""
"Notify the system that a module has been loaded. The method is provided "
"for compatibility with existing lazy / deferred import extensions."
msgstr ""

#: ../../pep-0369.txt:215
msgid "``module.__notified__``"
msgstr ""

#: ../../pep-0369.txt:215
msgid "A slot of a module instance. XXX"
msgstr ""

#: ../../pep-0369.txt:217
msgid ""
"The when_imported function decorator is also in the imp module, which is "
"equivalent to::"
msgstr ""

#: ../../pep-0369.txt:227
msgid "imp.when_imported(name) -> decorator function"
msgstr ""

#: ../../pep-0369.txt:226
msgid "for @when_imported(name) def hook(module): pass"
msgstr ""

#: ../../pep-0369.txt:230
msgid "Open issues"
msgstr ""

#: ../../pep-0369.txt:232
msgid "The when_imported decorator hasn't been written."
msgstr ""

#: ../../pep-0369.txt:234
msgid ""
"The code contains several XXX comments. They are mostly about error "
"handling in edge cases."
msgstr ""

#: ../../pep-0369.txt:239
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0369.txt:241
msgid ""
"The new features and API don't conflict with old import system of Python "
"and don't cause any backward compatibility issues for most software. "
"However systems like PEAK and Zope which implement their own lazy import "
"magic need to follow some rules."
msgstr ""

#: ../../pep-0369.txt:246
msgid ""
"The post import hooks carefully designed to cooperate with existing "
"deferred and lazy import systems. It's the suggestion of the PEP author "
"to replace own on-load-hooks with the new hook API. The alternative lazy "
"or deferred imports will still work but the implementations must call the"
" ``imp.notify_module_loaded`` function."
msgstr ""

#: ../../pep-0369.txt:254
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0369.txt:256
msgid ""
"A reference implementation is already written and is available in the "
"*py3k-importhook* branch. [4]_ It still requires some cleanups, "
"documentation updates and additional unit tests."
msgstr ""

#: ../../pep-0369.txt:262
msgid "Acknowledgments"
msgstr ""

#: ../../pep-0369.txt:264
msgid ""
"Nick Coghlan, for proof reading and the initial discussion Phillip J. "
"Eby, for his implementation in PEAK and help with my own implementation"
msgstr ""

#: ../../pep-0369.txt:269
msgid "Copyright"
msgstr ""

#: ../../pep-0369.txt:271
msgid "This document has been placed in the public domain."
msgstr ""

#: ../../pep-0369.txt:275
msgid "References"
msgstr ""

#: ../../pep-0369.txt:277
msgid ""
"PEP: Lazy module imports and post import hook "
"http://permalink.gmane.org/gmane.comp.python.devel/90949"
msgstr ""

#: ../../pep-0369.txt:280
msgid ""
"Interest in PEP for callbacks on module import "
"http://permalink.gmane.org/gmane.comp.python.python-3000.devel/11126"
msgstr ""

#: ../../pep-0369.txt:283
msgid ""
"peak.utils.imports http://svn.eby-"
"sarna.com/Importing/peak/util/imports.py?view=markup"
msgstr ""

#: ../../pep-0369.txt:286
msgid ""
"py3k-importhook branch http://svn.python.org/view/python/branches/py3k-"
"importhook/"
msgstr ""

