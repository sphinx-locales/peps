# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0445.txt
msgid "PEP"
msgstr ""

#: ../../pep-0445.txt:1
msgid "445"
msgstr ""

#: ../../pep-0445.txt
msgid "Title"
msgstr ""

#: ../../pep-0445.txt:2
msgid "Add new APIs to customize Python memory allocators"
msgstr ""

#: ../../pep-0445.txt
msgid "Author"
msgstr ""

#: ../../pep-0445.txt:5
msgid "Victor Stinner <vstinner@python.org>"
msgstr ""

#: ../../pep-0445.txt
msgid "BDFL-Delegate"
msgstr ""

#: ../../pep-0445.txt:6
msgid "Antoine Pitrou <solipsis@pitrou.net>"
msgstr ""

#: ../../pep-0445.txt
msgid "Status"
msgstr ""

#: ../../pep-0445.txt:7
msgid "Final"
msgstr ""

#: ../../pep-0445.txt
msgid "Type"
msgstr ""

#: ../../pep-0445.txt:8
msgid "Standards Track"
msgstr ""

#: ../../pep-0445.txt
msgid "Created"
msgstr ""

#: ../../pep-0445.txt:10
msgid "15-Jun-2013"
msgstr ""

#: ../../pep-0445.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0445.txt:11
msgid "3.4"
msgstr ""

#: ../../pep-0445.txt
msgid "Resolution"
msgstr ""

#: ../../pep-0445.txt:12
msgid "https://mail.python.org/pipermail/python-dev/2013-July/127222.html"
msgstr ""

#: ../../pep-0445.txt:15
msgid "Abstract"
msgstr ""

#: ../../pep-0445.txt:17
msgid ""
"This PEP proposes new Application Programming Interfaces (API) to "
"customize Python memory allocators.  The only implementation required to "
"conform to this PEP is CPython, but other implementations may choose to "
"be compatible, or to re-use a similar scheme."
msgstr ""

#: ../../pep-0445.txt:24
msgid "Rationale"
msgstr ""

#: ../../pep-0445.txt:26
msgid "Use cases:"
msgstr ""

#: ../../pep-0445.txt:28
msgid ""
"Applications embedding Python which want to isolate Python memory from "
"the memory of the application, or want to use a different memory "
"allocator optimized for its Python usage"
msgstr ""

#: ../../pep-0445.txt:31
msgid ""
"Python running on embedded devices with low memory and slow CPU. A custom"
" memory allocator can be used for efficiency and/or to get access all the"
" memory of the device."
msgstr ""

#: ../../pep-0445.txt:34
msgid "Debug tools for memory allocators:"
msgstr ""

#: ../../pep-0445.txt:36
msgid "track the memory usage (find memory leaks)"
msgstr ""

#: ../../pep-0445.txt:37
msgid ""
"get the location of a memory allocation: Python filename and line number,"
" and the size of a memory block"
msgstr ""

#: ../../pep-0445.txt:39
msgid ""
"detect buffer underflow, buffer overflow and misuse of Python allocator "
"APIs (see `Redesign Debug Checks on Memory Block Allocators as Hooks`_)"
msgstr ""

#: ../../pep-0445.txt:42
msgid ""
"force memory allocations to fail to test handling of the ``MemoryError`` "
"exception"
msgstr ""

#: ../../pep-0445.txt:47
msgid "Proposal"
msgstr ""

#: ../../pep-0445.txt:50
msgid "New Functions and Structures"
msgstr ""

#: ../../pep-0445.txt:52
msgid "Add a new GIL-free (no need to hold the GIL) memory allocator:"
msgstr ""

#: ../../pep-0445.txt:54
msgid "``void* PyMem_RawMalloc(size_t size)``"
msgstr ""

#: ../../pep-0445.txt:55
msgid "``void* PyMem_RawRealloc(void *ptr, size_t new_size)``"
msgstr ""

#: ../../pep-0445.txt:56
msgid "``void PyMem_RawFree(void *ptr)``"
msgstr ""

#: ../../pep-0445.txt:57
msgid "The newly allocated memory will not have been initialized in any way."
msgstr ""

#: ../../pep-0445.txt:59
msgid ""
"Requesting zero bytes returns a distinct non-*NULL* pointer if possible, "
"as if ``PyMem_Malloc(1)`` had been called instead."
msgstr ""

#: ../../pep-0445.txt:62
msgid "Add a new ``PyMemAllocator`` structure::"
msgstr ""

#: ../../pep-0445.txt:78
msgid ""
"Add a new ``PyMemAllocatorDomain`` enum to choose the Python allocator "
"domain. Domains:"
msgstr ""

#: ../../pep-0445.txt:81
msgid ""
"``PYMEM_DOMAIN_RAW``: ``PyMem_RawMalloc()``, ``PyMem_RawRealloc()`` and "
"``PyMem_RawFree()``"
msgstr ""

#: ../../pep-0445.txt:84
msgid ""
"``PYMEM_DOMAIN_MEM``: ``PyMem_Malloc()``, ``PyMem_Realloc()`` and "
"``PyMem_Free()``"
msgstr ""

#: ../../pep-0445.txt:87
msgid ""
"``PYMEM_DOMAIN_OBJ``: ``PyObject_Malloc()``, ``PyObject_Realloc()`` and "
"``PyObject_Free()``"
msgstr ""

#: ../../pep-0445.txt:90
msgid "Add new functions to get and set memory block allocators:"
msgstr ""

#: ../../pep-0445.txt:92
msgid ""
"``void PyMem_GetAllocator(PyMemAllocatorDomain domain, PyMemAllocator "
"*allocator)``"
msgstr ""

#: ../../pep-0445.txt:93
msgid ""
"``void PyMem_SetAllocator(PyMemAllocatorDomain domain, PyMemAllocator "
"*allocator)``"
msgstr ""

#: ../../pep-0445.txt:94
msgid ""
"The new allocator must return a distinct non-*NULL* pointer when "
"requesting zero bytes"
msgstr ""

#: ../../pep-0445.txt:96
msgid ""
"For the ``PYMEM_DOMAIN_RAW`` domain, the allocator must be thread-safe: "
"the GIL is not held when the allocator is called."
msgstr ""

#: ../../pep-0445.txt:99
msgid "Add a new ``PyObjectArenaAllocator`` structure::"
msgstr ""

#: ../../pep-0445.txt:112
msgid "Add new functions to get and set the arena allocator used by *pymalloc*:"
msgstr ""

#: ../../pep-0445.txt:115
msgid "``void PyObject_GetArenaAllocator(PyObjectArenaAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:116
msgid "``void PyObject_SetArenaAllocator(PyObjectArenaAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:118
msgid ""
"Add a new function to reinstall the debug checks on memory allocators "
"when a memory allocator is replaced with ``PyMem_SetAllocator()``:"
msgstr ""

#: ../../pep-0445.txt:121
msgid "``void PyMem_SetupDebugHooks(void)``"
msgstr ""

#: ../../pep-0445.txt:122
msgid ""
"Install the debug hooks on all memory block allocators. The function can "
"be called more than once, hooks are only installed once."
msgstr ""

#: ../../pep-0445.txt:124
msgid "The function does nothing is Python is not compiled in debug mode."
msgstr ""

#: ../../pep-0445.txt:126
msgid ""
"Memory block allocators always return *NULL* if *size* is greater than "
"``PY_SSIZE_T_MAX``. The check is done before calling the inner function."
msgstr ""

#: ../../pep-0445.txt:131
msgid ""
"The *pymalloc* allocator is optimized for objects smaller than 512 bytes "
"with a short lifetime. It uses memory mappings with a fixed size of 256 "
"KB called \"arenas\"."
msgstr ""

#: ../../pep-0445.txt:135
msgid "Here is how the allocators are set up by default:"
msgstr ""

#: ../../pep-0445.txt:137
msgid ""
"``PYMEM_DOMAIN_RAW``, ``PYMEM_DOMAIN_MEM``: ``malloc()``, ``realloc()`` "
"and ``free()``; call ``malloc(1)`` when requesting zero bytes"
msgstr ""

#: ../../pep-0445.txt:140
msgid ""
"``PYMEM_DOMAIN_OBJ``: *pymalloc* allocator which falls back on "
"``PyMem_Malloc()`` for allocations larger than 512 bytes"
msgstr ""

#: ../../pep-0445.txt:142
msgid ""
"*pymalloc* arena allocator: ``VirtualAlloc()`` and ``VirtualFree()`` on "
"Windows, ``mmap()`` and ``munmap()`` when available, or ``malloc()`` and "
"``free()``"
msgstr ""

#: ../../pep-0445.txt:148
msgid "Redesign Debug Checks on Memory Block Allocators as Hooks"
msgstr ""

#: ../../pep-0445.txt:150
msgid ""
"Since Python 2.3, Python implements different checks on memory allocators"
" in debug mode:"
msgstr ""

#: ../../pep-0445.txt:153
msgid ""
"Newly allocated memory is filled with the byte ``0xCB``, freed memory is "
"filled with the byte ``0xDB``."
msgstr ""

#: ../../pep-0445.txt:155
msgid ""
"Detect API violations, ex: ``PyObject_Free()`` called on a memory block "
"allocated by ``PyMem_Malloc()``"
msgstr ""

#: ../../pep-0445.txt:157
msgid "Detect write before the start of the buffer (buffer underflow)"
msgstr ""

#: ../../pep-0445.txt:158
msgid "Detect write after the end of the buffer (buffer overflow)"
msgstr ""

#: ../../pep-0445.txt:160
msgid ""
"In Python 3.3, the checks are installed by replacing ``PyMem_Malloc()``, "
"``PyMem_Realloc()``, ``PyMem_Free()``, ``PyObject_Malloc()``, "
"``PyObject_Realloc()`` and ``PyObject_Free()`` using macros. The new "
"allocator allocates a larger buffer and writes a pattern to detect buffer"
" underflow, buffer overflow and use after free (by filling the buffer "
"with the byte ``0xDB``). It uses the original ``PyObject_Malloc()`` "
"function to allocate memory. So ``PyMem_Malloc()`` and "
"``PyMem_Realloc()`` indirectly call ``PyObject_Malloc()`` and "
"``PyObject_Realloc()``."
msgstr ""

#: ../../pep-0445.txt:170
msgid ""
"This PEP redesigns the debug checks as hooks on the existing allocators "
"in debug mode. Examples of call traces without the hooks:"
msgstr ""

#: ../../pep-0445.txt:173
msgid "``PyMem_RawMalloc()`` => ``_PyMem_RawMalloc()`` => ``malloc()``"
msgstr ""

#: ../../pep-0445.txt:174
msgid "``PyMem_Realloc()`` => ``_PyMem_RawRealloc()`` => ``realloc()``"
msgstr ""

#: ../../pep-0445.txt:175
msgid "``PyObject_Free()`` => ``_PyObject_Free()``"
msgstr ""

#: ../../pep-0445.txt:177
msgid "Call traces when the hooks are installed (debug mode):"
msgstr ""

#: ../../pep-0445.txt:179
msgid ""
"``PyMem_RawMalloc()`` => ``_PyMem_DebugMalloc()`` => "
"``_PyMem_RawMalloc()`` => ``malloc()``"
msgstr ""

#: ../../pep-0445.txt:181
msgid ""
"``PyMem_Realloc()`` => ``_PyMem_DebugRealloc()`` => "
"``_PyMem_RawRealloc()`` => ``realloc()``"
msgstr ""

#: ../../pep-0445.txt:183
msgid "``PyObject_Free()`` => ``_PyMem_DebugFree()`` => ``_PyObject_Free()``"
msgstr ""

#: ../../pep-0445.txt:186
msgid ""
"As a result, ``PyMem_Malloc()`` and ``PyMem_Realloc()`` now call "
"``malloc()`` and ``realloc()`` in both release mode and debug mode, "
"instead of calling ``PyObject_Malloc()`` and ``PyObject_Realloc()`` in "
"debug mode."
msgstr ""

#: ../../pep-0445.txt:191
msgid ""
"When at least one memory allocator is replaced with "
"``PyMem_SetAllocator()``, the ``PyMem_SetupDebugHooks()`` function must "
"be called to reinstall the debug hooks on top on the new allocator."
msgstr ""

#: ../../pep-0445.txt:197
msgid "Don't call malloc() directly anymore"
msgstr ""

#: ../../pep-0445.txt:199
msgid ""
"``PyObject_Malloc()`` falls back on ``PyMem_Malloc()`` instead of "
"``malloc()`` if size is greater or equal than 512 bytes, and "
"``PyObject_Realloc()`` falls back on ``PyMem_Realloc()`` instead of "
"``realloc()``"
msgstr ""

#: ../../pep-0445.txt:204
msgid ""
"Direct calls to ``malloc()`` are replaced with ``PyMem_Malloc()``, or "
"``PyMem_RawMalloc()`` if the GIL is not held."
msgstr ""

#: ../../pep-0445.txt:207
msgid ""
"External libraries like zlib or OpenSSL can be configured to allocate "
"memory using ``PyMem_Malloc()`` or ``PyMem_RawMalloc()``. If the "
"allocator of a library can only be replaced globally (rather than on an "
"object-by-object basis), it shouldn't be replaced when Python is embedded"
" in an application."
msgstr ""

#: ../../pep-0445.txt:212
msgid ""
"For the \"track memory usage\" use case, it is important to track memory "
"allocated in external libraries to have accurate reports, because these "
"allocations can be large (e.g. they can raise a ``MemoryError`` "
"exception) and would otherwise be missed in memory usage reports."
msgstr ""

#: ../../pep-0445.txt:219
msgid "Examples"
msgstr ""

#: ../../pep-0445.txt:222
msgid "Use case 1: Replace Memory Allocators, keep pymalloc"
msgstr ""

#: ../../pep-0445.txt:224
msgid ""
"Dummy example wasting 2 bytes per memory block, and 10 bytes per "
"*pymalloc* arena::"
msgstr ""

#: ../../pep-0445.txt:284
msgid "Use case 2: Replace Memory Allocators, override pymalloc"
msgstr ""

#: ../../pep-0445.txt:286
msgid ""
"If you have a dedicated allocator optimized for allocations of objects "
"smaller than 512 bytes with a short lifetime, pymalloc can be overridden "
"(replace ``PyObject_Malloc()``)."
msgstr ""

#: ../../pep-0445.txt:290
msgid "Dummy example wasting 2 bytes per memory block::"
msgstr ""

#: ../../pep-0445.txt:328
msgid ""
"The *pymalloc* arena does not need to be replaced, because it is no more "
"used by the new allocator."
msgstr ""

#: ../../pep-0445.txt:333
msgid "Use case 3: Setup Hooks On Memory Block Allocators"
msgstr ""

#: ../../pep-0445.txt:335
msgid "Example to setup hooks on all memory block allocators::"
msgstr ""

#: ../../pep-0445.txt:399
msgid ""
"``PyMem_SetupDebugHooks()`` does not need to be called because memory "
"allocator are not replaced: the debug checks on memory block allocators "
"are installed automatically at startup."
msgstr ""

#: ../../pep-0445.txt:405
msgid "Performances"
msgstr ""

#: ../../pep-0445.txt:407
msgid ""
"The implementation of this PEP (issue #3329) has no visible overhead on "
"the Python benchmark suite."
msgstr ""

#: ../../pep-0445.txt:410
msgid ""
"Results of the `Python benchmarks suite "
"<http://hg.python.org/benchmarks>`_ (-b 2n3): some tests are 1.04x "
"faster, some tests are 1.04 slower. Results of pybench microbenchmark: "
"\"+0.1%\" slower globally (diff between -4.9% and +5.6%)."
msgstr ""

#: ../../pep-0445.txt:415
msgid "The full output of benchmarks is attached to the issue #3329."
msgstr ""

#: ../../pep-0445.txt:419
msgid "Rejected Alternatives"
msgstr ""

#: ../../pep-0445.txt:422
msgid "More specific functions to get/set memory allocators"
msgstr ""

#: ../../pep-0445.txt:424
msgid ""
"It was originally proposed a larger set of C API functions, with one pair"
" of functions for each allocator domain:"
msgstr ""

#: ../../pep-0445.txt:427
msgid "``void PyMem_GetRawAllocator(PyMemAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:428
msgid "``void PyMem_GetAllocator(PyMemAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:429
msgid "``void PyObject_GetAllocator(PyMemAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:430
msgid "``void PyMem_SetRawAllocator(PyMemAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:431
msgid "``void PyMem_SetAllocator(PyMemAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:432
msgid "``void PyObject_SetAllocator(PyMemAllocator *allocator)``"
msgstr ""

#: ../../pep-0445.txt:434
msgid ""
"This alternative was rejected because it is not possible to write generic"
" code with more specific functions: code must be duplicated for each "
"memory allocator domain."
msgstr ""

#: ../../pep-0445.txt:440
msgid "Make PyMem_Malloc() reuse PyMem_RawMalloc() by default"
msgstr ""

#: ../../pep-0445.txt:442
msgid ""
"If ``PyMem_Malloc()`` called ``PyMem_RawMalloc()`` by default, calling "
"``PyMem_SetAllocator(PYMEM_DOMAIN_RAW, alloc)`` would also patch "
"``PyMem_Malloc()`` indirectly."
msgstr ""

#: ../../pep-0445.txt:446
msgid ""
"This alternative was rejected because ``PyMem_SetAllocator()`` would have"
" a different behaviour depending on the domain. Always having the same "
"behaviour is less error-prone."
msgstr ""

#: ../../pep-0445.txt:452
msgid "Add a new PYDEBUGMALLOC environment variable"
msgstr ""

#: ../../pep-0445.txt:454
msgid ""
"It was proposed to add a new ``PYDEBUGMALLOC`` environment variable to "
"enable debug checks on memory block allocators. It would have had the "
"same effect as calling the ``PyMem_SetupDebugHooks()``, without the need "
"to write any C code.  Another advantage is to allow to enable debug "
"checks even in release mode: debug checks would always be compiled in, "
"but only enabled when the environment variable is present and non-empty."
msgstr ""

#: ../../pep-0445.txt:461
msgid ""
"This alternative was rejected because a new environment variable would "
"make Python initialization even more complex. `PEP 432 "
"<http://www.python.org/dev/peps/pep-0432/>`_ tries to simplify the "
"CPython startup sequence."
msgstr ""

#: ../../pep-0445.txt:468
msgid "Use macros to get customizable allocators"
msgstr ""

#: ../../pep-0445.txt:470
msgid ""
"To have no overhead in the default configuration, customizable allocators"
" would be an optional feature enabled by a configuration option or by "
"macros."
msgstr ""

#: ../../pep-0445.txt:474
msgid ""
"This alternative was rejected because the use of macros implies having to"
" recompile extensions modules to use the new allocator and allocator "
"hooks. Not having to recompile Python nor extension modules makes debug "
"hooks easier to use in practice."
msgstr ""

#: ../../pep-0445.txt:481
msgid "Pass the C filename and line number"
msgstr ""

#: ../../pep-0445.txt:483
msgid ""
"Define allocator functions as macros using ``__FILE__`` and ``__LINE__`` "
"to get the C filename and line number of a memory allocation."
msgstr ""

#: ../../pep-0445.txt:486
msgid ""
"Example of ``PyMem_Malloc`` macro with the modified ``PyMemAllocator`` "
"structure::"
msgstr ""

#: ../../pep-0445.txt:516
msgid ""
"The GC allocator functions would also have to be patched. For example, "
"``_PyObject_GC_Malloc()`` is used in many C functions and so objects of "
"different types would have the same allocation location."
msgstr ""

#: ../../pep-0445.txt:520
msgid ""
"This alternative was rejected because passing a filename and a line "
"number to each allocator makes the API more complex: pass 3 new arguments"
" (ctx, filename, lineno) to each allocator function, instead of just a "
"context argument (ctx). Having to also modify GC allocator functions adds"
" too much complexity for a little gain."
msgstr ""

#: ../../pep-0445.txt:528
msgid "GIL-free PyMem_Malloc()"
msgstr ""

#: ../../pep-0445.txt:530
msgid ""
"In Python 3.3, when Python is compiled in debug mode, ``PyMem_Malloc()`` "
"indirectly calls ``PyObject_Malloc()`` which requires the GIL to be held "
"(it isn't thread-safe).  That's why ``PyMem_Malloc()`` must be called "
"with the GIL held."
msgstr ""

#: ../../pep-0445.txt:535
msgid ""
"This PEP changes ``PyMem_Malloc()``: it now always calls ``malloc()`` "
"rather than ``PyObject_Malloc()``.  The \"GIL must be held\" restriction "
"could therefore be removed from ``PyMem_Malloc()``."
msgstr ""

#: ../../pep-0445.txt:539
msgid ""
"This alternative was rejected because allowing to call ``PyMem_Malloc()``"
" without holding the GIL can break applications which setup their own "
"allocators or allocator hooks.  Holding the GIL is convenient to develop "
"a custom allocator: no need to care about other threads.  It is also "
"convenient for a debug allocator hook: Python objects can be safely "
"inspected, and the C API may be used for reporting."
msgstr ""

#: ../../pep-0445.txt:546
msgid ""
"Moreover, calling ``PyGILState_Ensure()`` in a memory allocator has "
"unexpected behaviour, especially at Python startup and when creating of a"
" new Python thread state.  It is better to free custom allocators of the "
"responsibility of acquiring the GIL."
msgstr ""

#: ../../pep-0445.txt:553
msgid "Don't add PyMem_RawMalloc()"
msgstr ""

#: ../../pep-0445.txt:555
msgid ""
"Replace ``malloc()`` with ``PyMem_Malloc()``, but only if the GIL is "
"held.  Otherwise, keep ``malloc()`` unchanged."
msgstr ""

#: ../../pep-0445.txt:558
msgid ""
"The ``PyMem_Malloc()`` is used without the GIL held in some Python "
"functions.  For example, the ``main()`` and ``Py_Main()`` functions of "
"Python call ``PyMem_Malloc()`` whereas the GIL do not exist yet. In this "
"case, ``PyMem_Malloc()`` would be replaced with ``malloc()`` (or "
"``PyMem_RawMalloc()``)."
msgstr ""

#: ../../pep-0445.txt:564
msgid ""
"This alternative was rejected because ``PyMem_RawMalloc()`` is required "
"for accurate reports of the memory usage. When a debug hook is used to "
"track the memory usage, the memory allocated by direct calls to "
"``malloc()`` cannot be tracked. ``PyMem_RawMalloc()`` can be hooked and "
"so all the memory allocated by Python can be tracked, including memory "
"allocated without holding the GIL."
msgstr ""

#: ../../pep-0445.txt:573
msgid "Use existing debug tools to analyze memory use"
msgstr ""

#: ../../pep-0445.txt:575
msgid ""
"There are many existing debug tools to analyze memory use. Some examples:"
" `Valgrind <http://valgrind.org/>`_, `Purify "
"<http://ibm.com/software/awdtools/purify/>`_, `Clang AddressSanitizer "
"<http://code.google.com/p/address-sanitizer/>`_, `failmalloc "
"<http://www.nongnu.org/failmalloc/>`_, etc."
msgstr ""

#: ../../pep-0445.txt:581
msgid ""
"The problem is to retrieve the Python object related to a memory pointer "
"to read its type and/or its content. Another issue is to retrieve the "
"source of the memory allocation: the C backtrace is usually useless (same"
" reasoning than macros using ``__FILE__`` and ``__LINE__``, see `Pass the"
" C filename and line number`_), the Python filename and line number (or "
"even the Python traceback) is more useful."
msgstr ""

#: ../../pep-0445.txt:588
msgid ""
"This alternative was rejected because classic tools are unable to "
"introspect Python internals to collect such information. Being able to "
"setup a hook on allocators called with the GIL held allows to collect a "
"lot of useful data from Python internals."
msgstr ""

#: ../../pep-0445.txt:595
msgid "Add a msize() function"
msgstr ""

#: ../../pep-0445.txt:597
msgid ""
"Add another function to ``PyMemAllocator`` and ``PyObjectArenaAllocator``"
" structures::"
msgstr ""

#: ../../pep-0445.txt:602
msgid ""
"This function returns the size of a memory block or a memory mapping. "
"Return (size_t)-1 if the function is not implemented or if the pointer is"
" unknown (ex: NULL pointer)."
msgstr ""

#: ../../pep-0445.txt:606
msgid ""
"On Windows, this function can be implemented using ``_msize()`` and "
"``VirtualQuery()``."
msgstr ""

#: ../../pep-0445.txt:609
msgid ""
"The function can be used to implement a hook tracking the memory usage. "
"The ``free()`` method of an allocator only gets the address of a memory "
"block, whereas the size of the memory block is required to update the "
"memory usage."
msgstr ""

#: ../../pep-0445.txt:614
msgid ""
"The additional ``msize()`` function was rejected because only few "
"platforms implement it. For example, Linux with the GNU libc does not "
"provide a function to get the size of a memory block. ``msize()`` is not "
"currently used in the Python source code. The function would only be used"
" to track memory use, and make the API more complex. A debug hook can "
"implement the function internally, there is no need to add it to "
"``PyMemAllocator`` and ``PyObjectArenaAllocator`` structures."
msgstr ""

#: ../../pep-0445.txt:624
msgid "No context argument"
msgstr ""

#: ../../pep-0445.txt:626
msgid ""
"Simplify the signature of allocator functions, remove the context "
"argument:"
msgstr ""

#: ../../pep-0445.txt:629
msgid "``void* malloc(size_t size)``"
msgstr ""

#: ../../pep-0445.txt:630
msgid "``void* realloc(void *ptr, size_t new_size)``"
msgstr ""

#: ../../pep-0445.txt:631
msgid "``void free(void *ptr)``"
msgstr ""

#: ../../pep-0445.txt:633
msgid ""
"It is likely for an allocator hook to be reused for "
"``PyMem_SetAllocator()`` and ``PyObject_SetAllocator()``, or even "
"``PyMem_SetRawAllocator()``, but the hook must call a different function "
"depending on the allocator. The context is a convenient way to reuse the "
"same custom allocator or hook for different Python allocators."
msgstr ""

#: ../../pep-0445.txt:639
msgid "In C++, the context can be used to pass *this*."
msgstr ""

#: ../../pep-0445.txt:643
msgid "External Libraries"
msgstr ""

#: ../../pep-0445.txt:645
msgid "Examples of API used to customize memory allocators."
msgstr ""

#: ../../pep-0445.txt:647
msgid "Libraries used by Python:"
msgstr ""

#: ../../pep-0445.txt:649
msgid ""
"OpenSSL: `CRYPTO_set_mem_functions() "
"<http://git.openssl.org/gitweb/?p=openssl.git;a=blob;f=crypto/mem.c;h=f7984fa958eb1edd6c61f6667f3f2b29753be662;hb=HEAD#l124>`_"
" to set memory management functions globally"
msgstr ""

#: ../../pep-0445.txt:652
msgid ""
"expat: `parserCreate() "
"<http://hg.python.org/cpython/file/cc27d50bd91a/Modules/expat/xmlparse.c#l724>`_"
" has a per-instance memory handler"
msgstr ""

#: ../../pep-0445.txt:655
msgid ""
"zlib: `zlib 1.2.8 Manual <http://www.zlib.net/manual.html#Usage>`_, pass "
"an opaque pointer"
msgstr ""

#: ../../pep-0445.txt:657
msgid ""
"bz2: `bzip2 and libbzip2, version 1.0.5 "
"<http://www.bzip.org/1.0.5/bzip2-manual-1.0.5.html>`_, pass an opaque "
"pointer"
msgstr ""

#: ../../pep-0445.txt:660
msgid ""
"lzma: `LZMA SDK - How to Use "
"<http://www.asawicki.info/news_1368_lzma_sdk_-_how_to_use.html>`_, pass "
"an opaque pointer"
msgstr ""

#: ../../pep-0445.txt:663
msgid "lipmpdec: no opaque pointer (classic malloc API)"
msgstr ""

#: ../../pep-0445.txt:665
msgid "Other libraries:"
msgstr ""

#: ../../pep-0445.txt:667
msgid ""
"glib: `g_mem_set_vtable() <http://developer.gnome.org/glib/unstable/glib-"
"Memory-Allocation.html#g-mem-set-vtable>`_"
msgstr ""

#: ../../pep-0445.txt:669
msgid ""
"libxml2: `xmlGcMemSetup() <http://xmlsoft.org/html/libxml-"
"xmlmemory.html>`_, global"
msgstr ""

#: ../../pep-0445.txt:672
msgid ""
"Oracle's OCI: `Oracle Call Interface Programmer's Guide, Release 2 (9.2) "
"<http://docs.oracle.com/cd/B10501_01/appdev.920/a96584/oci15re4.htm>`_, "
"pass an opaque pointer"
msgstr ""

#: ../../pep-0445.txt:677
msgid ""
"The new *ctx* parameter of this PEP was inspired by the API of zlib and "
"Oracle's OCI libraries."
msgstr ""

#: ../../pep-0445.txt:680
msgid ""
"See also the `GNU libc: Memory Allocation Hooks "
"<http://www.gnu.org/software/libc/manual/html_node/Hooks-for-"
"Malloc.html>`_ which uses a different approach to hook memory allocators."
msgstr ""

#: ../../pep-0445.txt:686
msgid "Memory Allocators"
msgstr ""

#: ../../pep-0445.txt:688
msgid ""
"The C standard library provides the well known ``malloc()`` function. Its"
" implementation depends on the platform and of the C library. The GNU C "
"library uses a modified ptmalloc2, based on \"Doug Lea's Malloc\" "
"(dlmalloc). FreeBSD uses `jemalloc "
"<http://www.canonware.com/jemalloc/>`_. Google provides *tcmalloc* which "
"is part of `gperftools <http://code.google.com/p/gperftools/>`_."
msgstr ""

#: ../../pep-0445.txt:695
msgid ""
"``malloc()`` uses two kinds of memory: heap and memory mappings. Memory "
"mappings are usually used for large allocations (ex: larger than 256 KB),"
" whereas the heap is used for small allocations."
msgstr ""

#: ../../pep-0445.txt:699
msgid ""
"On UNIX, the heap is handled by ``brk()`` and ``sbrk()`` system calls, "
"and it is contiguous.  On Windows, the heap is handled by ``HeapAlloc()``"
" and can be discontiguous. Memory mappings are handled by ``mmap()`` on "
"UNIX and ``VirtualAlloc()`` on Windows, they can be discontiguous."
msgstr ""

#: ../../pep-0445.txt:705
msgid ""
"Releasing a memory mapping gives back immediately the memory to the "
"system. On UNIX, the heap memory is only given back to the system if the "
"released block is located at the end of the heap. Otherwise, the memory "
"will only be given back to the system when all the memory located after "
"the released memory is also released."
msgstr ""

#: ../../pep-0445.txt:711
msgid ""
"To allocate memory on the heap, an allocator tries to reuse free space. "
"If there is no contiguous space big enough, the heap must be enlarged, "
"even if there is more free space than required size.  This issue is "
"called the \"memory fragmentation\": the memory usage seen by the system "
"is higher than real usage. On Windows, ``HeapAlloc()`` creates a new "
"memory mapping with ``VirtualAlloc()`` if there is not enough free "
"contiguous memory."
msgstr ""

#: ../../pep-0445.txt:719
msgid ""
"CPython has a *pymalloc* allocator for allocations smaller than 512 "
"bytes. This allocator is optimized for small objects with a short "
"lifetime. It uses memory mappings called \"arenas\" with a fixed size of "
"256 KB."
msgstr ""

#: ../../pep-0445.txt:724
msgid "Other allocators:"
msgstr ""

#: ../../pep-0445.txt:726
msgid ""
"Windows provides a `Low-fragmentation Heap <http://msdn.microsoft.com/en-"
"us/library/windows/desktop/aa366750%28v=vs.85%29.aspx>`_."
msgstr ""

#: ../../pep-0445.txt:729
msgid ""
"The Linux kernel uses `slab allocation "
"<http://en.wikipedia.org/wiki/Slab_allocation>`_."
msgstr ""

#: ../../pep-0445.txt:732
msgid ""
"The glib library has a `Memory Slice API "
"<https://developer.gnome.org/glib/unstable/glib-Memory-Slices.html>`_: "
"efficient way to allocate groups of equal-sized chunks of memory"
msgstr ""

#: ../../pep-0445.txt:736
msgid ""
"This PEP allows to choose exactly which memory allocator is used for your"
" application depending on its usage of the memory (number of allocations,"
" size of allocations, lifetime of objects, etc.)."
msgstr ""

#: ../../pep-0445.txt:742
msgid "Links"
msgstr ""

#: ../../pep-0445.txt:744
msgid "CPython issues related to memory allocation:"
msgstr ""

#: ../../pep-0445.txt:746
msgid ""
"`Issue #3329: Add new APIs to customize memory allocators "
"<http://bugs.python.org/issue3329>`_"
msgstr ""

#: ../../pep-0445.txt:748
msgid ""
"`Issue #13483: Use VirtualAlloc to allocate memory arenas "
"<http://bugs.python.org/issue13483>`_"
msgstr ""

#: ../../pep-0445.txt:750
msgid ""
"`Issue #16742: PyOS_Readline drops GIL and calls PyOS_StdioReadline, "
"which isn't thread safe <http://bugs.python.org/issue16742>`_"
msgstr ""

#: ../../pep-0445.txt:752
msgid ""
"`Issue #18203: Replace calls to malloc() with PyMem_Malloc() or "
"PyMem_RawMalloc() <http://bugs.python.org/issue18203>`_"
msgstr ""

#: ../../pep-0445.txt:754
msgid ""
"`Issue #18227: Use Python memory allocators in external libraries like "
"zlib or OpenSSL <http://bugs.python.org/issue18227>`_"
msgstr ""

#: ../../pep-0445.txt:757
msgid "Projects analyzing the memory usage of Python applications:"
msgstr ""

#: ../../pep-0445.txt:759
msgid "`pytracemalloc <https://pypi.python.org/pypi/pytracemalloc>`_"
msgstr ""

#: ../../pep-0445.txt:761
msgid ""
"`Meliae: Python Memory Usage Analyzer "
"<https://pypi.python.org/pypi/meliae>`_"
msgstr ""

#: ../../pep-0445.txt:763
msgid ""
"`Guppy-PE: umbrella package combining Heapy and GSL <http://guppy-"
"pe.sourceforge.net/>`_"
msgstr ""

#: ../../pep-0445.txt:765
msgid "`PySizer (developed for Python 2.4) <http://pysizer.8325.org/>`_"
msgstr ""

#: ../../pep-0445.txt:770
msgid "Copyright"
msgstr ""

#: ../../pep-0445.txt:772
msgid "This document has been placed into the public domain."
msgstr ""

