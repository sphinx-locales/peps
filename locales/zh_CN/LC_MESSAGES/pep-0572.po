# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0572.rst
msgid "PEP"
msgstr ""

#: ../../pep-0572.rst:1
msgid "572"
msgstr ""

#: ../../pep-0572.rst
msgid "Title"
msgstr ""

#: ../../pep-0572.rst:2
msgid "Assignment Expressions"
msgstr ""

#: ../../pep-0572.rst
msgid "Author"
msgstr ""

#: ../../pep-0572.rst:3
msgid ""
"Chris Angelico <rosuav@gmail.com>, Tim Peters <tim.peters@gmail.com>, "
"Guido van Rossum <guido@python.org>"
msgstr ""

#: ../../pep-0572.rst
msgid "Status"
msgstr ""

#: ../../pep-0572.rst:5
msgid "Accepted"
msgstr ""

#: ../../pep-0572.rst
msgid "Type"
msgstr ""

#: ../../pep-0572.rst:6
msgid "Standards Track"
msgstr ""

#: ../../pep-0572.rst
msgid "Created"
msgstr ""

#: ../../pep-0572.rst:8
msgid "28-Feb-2018"
msgstr ""

#: ../../pep-0572.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0572.rst:9
msgid "3.8"
msgstr ""

#: ../../pep-0572.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0572.rst:10
msgid ""
"28-Feb-2018, 02-Mar-2018, 23-Mar-2018, 04-Apr-2018, 17-Apr-2018, "
"25-Apr-2018, 09-Jul-2018, 05-Aug-2019"
msgstr ""

#: ../../pep-0572.rst
msgid "Resolution"
msgstr ""

#: ../../pep-0572.rst:12
msgid "https://mail.python.org/pipermail/python-dev/2018-July/154601.html"
msgstr ""

#: ../../pep-0572.rst:16
msgid "Abstract"
msgstr ""

#: ../../pep-0572.rst:18
msgid ""
"This is a proposal for creating a way to assign to variables within an "
"expression using the notation ``NAME := expr``."
msgstr ""

#: ../../pep-0572.rst:21
msgid ""
"As part of this change, there is also an update to dictionary "
"comprehension evaluation order to ensure key expressions are executed "
"before value expressions (allowing the key to be bound to a name and then"
" re-used as part of calculating the corresponding value)."
msgstr ""

#: ../../pep-0572.rst:26
msgid ""
"During discussion of this PEP, the operator became informally known as "
"\"the walrus operator\". The construct's formal name is \"Assignment "
"Expressions\" (as per the PEP title), but they may also be referred to as"
" \"Named Expressions\" (e.g. the CPython reference implementation uses "
"that name internally)."
msgstr ""

#: ../../pep-0572.rst:33
msgid "Rationale"
msgstr ""

#: ../../pep-0572.rst:35
msgid ""
"Naming the result of an expression is an important part of programming, "
"allowing a descriptive name to be used in place of a longer expression, "
"and permitting reuse.  Currently, this feature is available only in "
"statement form, making it unavailable in list comprehensions and other "
"expression contexts."
msgstr ""

#: ../../pep-0572.rst:41
msgid ""
"Additionally, naming sub-parts of a large expression can assist an "
"interactive debugger, providing useful display hooks and partial results."
" Without a way to capture sub-expressions inline, this would require "
"refactoring of the original code; with assignment expressions, this "
"merely requires the insertion of a few ``name :=`` markers. Removing the "
"need to refactor reduces the likelihood that the code be inadvertently "
"changed as part of debugging (a common cause of Heisenbugs), and is "
"easier to dictate to another programmer."
msgstr ""

#: ../../pep-0572.rst:50
msgid "The importance of real code"
msgstr ""

#: ../../pep-0572.rst:52
msgid ""
"During the development of this PEP many people (supporters and critics "
"both) have had a tendency to focus on toy examples on the one hand, and "
"on overly complex examples on the other."
msgstr ""

#: ../../pep-0572.rst:56
msgid ""
"The danger of toy examples is twofold: they are often too abstract to "
"make anyone go \"ooh, that's compelling\", and they are easily refuted "
"with \"I would never write it that way anyway\"."
msgstr ""

#: ../../pep-0572.rst:60
msgid ""
"The danger of overly complex examples is that they provide a convenient "
"strawman for critics of the proposal to shoot down (\"that's "
"obfuscated\")."
msgstr ""

#: ../../pep-0572.rst:64
msgid ""
"Yet there is some use for both extremely simple and extremely complex "
"examples: they are helpful to clarify the intended semantics. Therefore, "
"there will be some of each below."
msgstr ""

#: ../../pep-0572.rst:68
msgid ""
"However, in order to be *compelling*, examples should be rooted in real "
"code, i.e. code that was written without any thought of this PEP, as part"
" of a useful application, however large or small.  Tim Peters has been "
"extremely helpful by going over his own personal code repository and "
"picking examples of code he had written that (in his view) would have "
"been *clearer* if rewritten with (sparing) use of assignment expressions."
"  His conclusion: the current proposal would have allowed a modest but "
"clear improvement in quite a few bits of code."
msgstr ""

#: ../../pep-0572.rst:78
msgid ""
"Another use of real code is to observe indirectly how much value "
"programmers place on compactness.  Guido van Rossum searched through a "
"Dropbox code base and discovered some evidence that programmers value "
"writing fewer lines over shorter lines."
msgstr ""

#: ../../pep-0572.rst:83
msgid ""
"Case in point: Guido found several examples where a programmer repeated a"
" subexpression, slowing down the program, in order to save one line of "
"code, e.g. instead of writing::"
msgstr ""

#: ../../pep-0572.rst:90
msgid "they would write::"
msgstr ""

#: ../../pep-0572.rst:94
msgid ""
"Another example illustrates that programmers sometimes do more work to "
"save an extra level of indentation::"
msgstr ""

#: ../../pep-0572.rst:106
msgid ""
"This code tries to match ``pattern2`` even if ``pattern1`` has a match "
"(in which case the match on ``pattern2`` is never used).  The more "
"efficient rewrite would have been::"
msgstr ""

#: ../../pep-0572.rst:122
msgid "Syntax and semantics"
msgstr ""

#: ../../pep-0572.rst:124
msgid ""
"In most contexts where arbitrary Python expressions can be used, a "
"**named expression** can appear.  This is of the form ``NAME := expr`` "
"where ``expr`` is any valid Python expression other than an "
"unparenthesized tuple, and ``NAME`` is an identifier."
msgstr ""

#: ../../pep-0572.rst:129
msgid ""
"The value of such a named expression is the same as the incorporated "
"expression, with the additional side-effect that the target is assigned "
"that value::"
msgstr ""

#: ../../pep-0572.rst:148
msgid "Exceptional cases"
msgstr ""

#: ../../pep-0572.rst:150
msgid ""
"There are a few places where assignment expressions are not allowed, in "
"order to avoid ambiguities or user confusion:"
msgstr ""

#: ../../pep-0572.rst:153
msgid ""
"Unparenthesized assignment expressions are prohibited at the top level of"
" an expression statement.  Example::"
msgstr ""

#: ../../pep-0572.rst:159
msgid ""
"This rule is included to simplify the choice for the user between an "
"assignment statement and an assignment expression -- there is no "
"syntactic position where both are valid."
msgstr ""

#: ../../pep-0572.rst:163
msgid ""
"Unparenthesized assignment expressions are prohibited at the top level of"
" the right hand side of an assignment statement.  Example::"
msgstr ""

#: ../../pep-0572.rst:169
msgid ""
"Again, this rule is included to avoid two visually similar ways of saying"
" the same thing."
msgstr ""

#: ../../pep-0572.rst:172
msgid ""
"Unparenthesized assignment expressions are prohibited for the value of a "
"keyword argument in a call.  Example::"
msgstr ""

#: ../../pep-0572.rst:178
msgid ""
"This rule is included to disallow excessively confusing code, and because"
" parsing keyword arguments is complex enough already."
msgstr ""

#: ../../pep-0572.rst:181
msgid ""
"Unparenthesized assignment expressions are prohibited at the top level of"
" a function default value.  Example::"
msgstr ""

#: ../../pep-0572.rst:189
msgid ""
"This rule is included to discourage side effects in a position whose "
"exact semantics are already confusing to many users (cf. the common style"
" recommendation against mutable default values), and also to echo the "
"similar prohibition in calls (the previous bullet)."
msgstr ""

#: ../../pep-0572.rst:194
msgid ""
"Unparenthesized assignment expressions are prohibited as annotations for "
"arguments, return values and assignments.  Example::"
msgstr ""

#: ../../pep-0572.rst:202
msgid ""
"The reasoning here is similar to the two previous cases; this ungrouped "
"assortment of symbols and operators composed of ``:`` and ``=`` is hard "
"to read correctly."
msgstr ""

#: ../../pep-0572.rst:206
msgid ""
"Unparenthesized assignment expressions are prohibited in lambda "
"functions. Example::"
msgstr ""

#: ../../pep-0572.rst:214
msgid ""
"This allows ``lambda`` to always bind less tightly than ``:=``; having a "
"name binding at the top level inside a lambda function is unlikely to be "
"of value, as there is no way to make use of it. In cases where the name "
"will be used more than once, the expression is likely to need "
"parenthesizing anyway, so this prohibition will rarely affect code."
msgstr ""

#: ../../pep-0572.rst:220
msgid "Assignment expressions inside of f-strings require parentheses. Example::"
msgstr ""

#: ../../pep-0572.rst:228
msgid ""
"This shows that what looks like an assignment operator in an f-string is "
"not always an assignment operator.  The f-string parser uses ``:`` to "
"indicate formatting options.  To preserve backwards compatibility, "
"assignment operator usage inside of f-strings must be parenthesized. As "
"noted above, this usage of the assignment operator is not recommended."
msgstr ""

#: ../../pep-0572.rst:235
msgid "Scope of the target"
msgstr ""

#: ../../pep-0572.rst:237
msgid ""
"An assignment expression does not introduce a new scope.  In most cases "
"the scope in which the target will be bound is self-explanatory: it is "
"the current scope.  If this scope contains a ``nonlocal`` or ``global`` "
"declaration for the target, the assignment expression honors that.  A "
"lambda (being an explicit, if anonymous, function definition) counts as a"
" scope for this purpose."
msgstr ""

#: ../../pep-0572.rst:244
msgid ""
"There is one special case: an assignment expression occurring in a list, "
"set or dict comprehension or in a generator expression (below "
"collectively referred to as \"comprehensions\") binds the target in the "
"containing scope, honoring a ``nonlocal`` or ``global`` declaration for "
"the target in that scope, if one exists.  For the purpose of this rule "
"the containing scope of a nested comprehension is the scope that contains"
" the outermost comprehension.  A lambda counts as a containing scope."
msgstr ""

#: ../../pep-0572.rst:253
msgid ""
"The motivation for this special case is twofold.  First, it allows us to "
"conveniently capture a \"witness\" for an ``any()`` expression, or a "
"counterexample for ``all()``, for example::"
msgstr ""

#: ../../pep-0572.rst:267
msgid ""
"Second, it allows a compact way of updating mutable state from a "
"comprehension, for example::"
msgstr ""

#: ../../pep-0572.rst:275
msgid ""
"However, an assignment expression target name cannot be the same as a "
"``for``-target name appearing in any comprehension containing the "
"assignment expression.  The latter names are local to the comprehension "
"in which they appear, so it would be contradictory for a contained use of"
" the same name to refer to the scope containing the outermost "
"comprehension instead."
msgstr ""

#: ../../pep-0572.rst:282
msgid ""
"For example, ``[i := i+1 for i in range(5)]`` is invalid: the ``for i`` "
"part establishes that ``i`` is local to the comprehension, but the ``i "
":=`` part insists that ``i`` is not local to the comprehension. The same "
"reason makes these examples invalid too::"
msgstr ""

#: ../../pep-0572.rst:291
msgid ""
"While it's technically possible to assign consistent semantics to these "
"cases, it's difficult to determine whether those semantics actually make "
"*sense* in the absence of real use cases. Accordingly, the reference "
"implementation will ensure that such cases raise ``SyntaxError``, rather "
"than executing with implementation defined behaviour."
msgstr ""

#: ../../pep-0572.rst:297
msgid ""
"This restriction applies even if the assignment expression is never "
"executed::"
msgstr ""

#: ../../pep-0572.rst:302
msgid ""
"For the comprehension body (the part before the first \"for\" keyword) "
"and the filter expression (the part after \"if\" and before any nested "
"\"for\"), this restriction applies solely to target names that are also "
"used as iteration variables in the comprehension. Lambda expressions "
"appearing in these positions introduce a new explicit function scope, and"
" hence may use assignment expressions with no additional restrictions."
msgstr ""

#: ../../pep-0572.rst:309
msgid ""
"Due to design constraints in the reference implementation (the symbol "
"table analyser cannot easily detect when names are re-used between the "
"leftmost comprehension iterable expression and the rest of the "
"comprehension), named expressions are disallowed entirely as part of "
"comprehension iterable expressions (the part after each \"in\", and "
"before any subsequent \"if\" or \"for\" keyword)::"
msgstr ""

#: ../../pep-0572.rst:321
msgid ""
"A further exception applies when an assignment expression occurs in a "
"comprehension whose containing scope is a class scope.  If the rules "
"above were to result in the target being assigned in that class's scope, "
"the assignment expression is expressly invalid. This case also raises "
"``SyntaxError``::"
msgstr ""

#: ../../pep-0572.rst:330
msgid ""
"(The reason for the latter exception is the implicit function scope "
"created for comprehensions -- there is currently no runtime mechanism for"
" a function to refer to a variable in the containing class scope, and we "
"do not want to add such a mechanism.  If this issue ever gets resolved "
"this special case may be removed from the specification of assignment "
"expressions.  Note that the problem already exists for *using* a variable"
" defined in the class scope from a comprehension.)"
msgstr ""

#: ../../pep-0572.rst:338
msgid ""
"See Appendix B for some examples of how the rules for targets in "
"comprehensions translate to equivalent code."
msgstr ""

#: ../../pep-0572.rst:343
msgid "Relative precedence of ``:=``"
msgstr ""

#: ../../pep-0572.rst:345
msgid ""
"The ``:=`` operator groups more tightly than a comma in all syntactic "
"positions where it is legal, but less tightly than all other operators, "
"including ``or``, ``and``, ``not``, and conditional expressions (``A if C"
" else B``).  As follows from section \"Exceptional cases\" above, it is "
"never allowed at the same level as ``=``.  In case a different grouping "
"is desired, parentheses should be used."
msgstr ""

#: ../../pep-0572.rst:353
msgid ""
"The ``:=`` operator may be used directly in a positional function call "
"argument; however it is invalid directly in a keyword argument."
msgstr ""

#: ../../pep-0572.rst:356
msgid "Some examples to clarify what's technically valid or invalid::"
msgstr ""

#: ../../pep-0572.rst:382
msgid ""
"Most of the \"valid\" examples above are not recommended, since human "
"readers of Python source code who are quickly glancing at some code may "
"miss the distinction.  But simple cases are not objectionable::"
msgstr ""

#: ../../pep-0572.rst:390
msgid ""
"This PEP recommends always putting spaces around ``:=``, similar to PEP "
"8's recommendation for ``=`` when used for assignment, whereas the latter"
" disallows spaces around ``=`` used for keyword arguments.)"
msgstr ""

#: ../../pep-0572.rst:395
msgid "Change to evaluation order"
msgstr ""

#: ../../pep-0572.rst:397
msgid ""
"In order to have precisely defined semantics, the proposal requires "
"evaluation order to be well-defined.  This is technically not a new "
"requirement, as function calls may already have side effects.  Python "
"already has a rule that subexpressions are generally evaluated from left "
"to right.  However, assignment expressions make these side effects more "
"visible, and we propose a single change to the current evaluation order:"
msgstr ""

#: ../../pep-0572.rst:405
msgid ""
"In a dict comprehension ``{X: Y for ...}``, ``Y`` is currently evaluated "
"before ``X``.  We propose to change this so that ``X`` is evaluated "
"before ``Y``.  (In a dict display like ``{X: Y}`` this is already the "
"case, and also in ``dict((X, Y) for ...)`` which should clearly be "
"equivalent to the dict comprehension.)"
msgstr ""

#: ../../pep-0572.rst:412
msgid "Differences between  assignment expressions and assignment statements"
msgstr ""

#: ../../pep-0572.rst:414
msgid ""
"Most importantly, since ``:=`` is an expression, it can be used in "
"contexts where statements are illegal, including lambda functions and "
"comprehensions."
msgstr ""

#: ../../pep-0572.rst:417
msgid ""
"Conversely, assignment expressions don't support the advanced features "
"found in assignment statements:"
msgstr ""

#: ../../pep-0572.rst:420
msgid "Multiple targets are not directly supported::"
msgstr ""

#: ../../pep-0572.rst:424
msgid "Single assignment targets other than a single ``NAME`` are not supported::"
msgstr ""

#: ../../pep-0572.rst:431
msgid "Priority around commas is different::"
msgstr ""

#: ../../pep-0572.rst:436
msgid ""
"Iterable packing and unpacking (both regular or extended forms) are not "
"supported::"
msgstr ""

#: ../../pep-0572.rst:447
msgid "Inline type annotations are not supported::"
msgstr ""

#: ../../pep-0572.rst:452
msgid "Augmented assignment is not supported::"
msgstr ""

#: ../../pep-0572.rst:458
msgid "Specification changes during implementation"
msgstr ""

#: ../../pep-0572.rst:460
msgid ""
"The following changes have been made based on implementation experience "
"and additional review after the PEP was first accepted and before Python "
"3.8 was released:"
msgstr ""

#: ../../pep-0572.rst:464
msgid ""
"for consistency with other similar exceptions, and to avoid locking in an"
" exception name that is not necessarily going to improve clarity for end "
"users, the originally proposed ``TargetScopeError`` subclass of "
"``SyntaxError`` was dropped in favour of just raising ``SyntaxError`` "
"directly. [3]_"
msgstr ""

#: ../../pep-0572.rst:468
msgid ""
"due to a limitation in CPython's symbol table analysis process, the "
"reference implementation raises ``SyntaxError`` for all uses of named "
"expressions inside comprehension iterable expressions, rather than only "
"raising them when the named expression target conflicts with one of the "
"iteration variables in the comprehension. This could be revisited given "
"sufficiently compelling examples, but the extra complexity needed to "
"implement the more selective restriction doesn't seem worthwhile for "
"purely hypothetical use cases."
msgstr ""

#: ../../pep-0572.rst:478
msgid "Examples"
msgstr ""

#: ../../pep-0572.rst:481
msgid "Examples from the Python standard library"
msgstr ""

#: ../../pep-0572.rst:484
msgid "site.py"
msgstr ""

#: ../../pep-0572.rst:486
msgid ""
"*env_base* is only used on these lines, putting its assignment on the if "
"moves it as the \"header\" of the block."
msgstr ""

#: ../../pep-0572.rst:489 ../../pep-0572.rst:505 ../../pep-0572.rst:523
#: ../../pep-0572.rst:557 ../../pep-0572.rst:583
msgid "Current::"
msgstr ""

#: ../../pep-0572.rst:495 ../../pep-0572.rst:512 ../../pep-0572.rst:540
#: ../../pep-0572.rst:567 ../../pep-0572.rst:602
msgid "Improved::"
msgstr ""

#: ../../pep-0572.rst:501
msgid "_pydecimal.py"
msgstr ""

#: ../../pep-0572.rst:503
msgid "Avoid nested ``if`` and remove one indentation level."
msgstr ""

#: ../../pep-0572.rst:518
msgid "copy.py"
msgstr ""

#: ../../pep-0572.rst:520
msgid ""
"Code looks more regular and avoid multiple nested if. (See Appendix A for"
" the origin of this example.)"
msgstr ""

#: ../../pep-0572.rst:552
msgid "datetime.py"
msgstr ""

#: ../../pep-0572.rst:554
msgid ""
"*tz* is only used for ``s += tz``, moving its assignment inside the if "
"helps to show its scope."
msgstr ""

#: ../../pep-0572.rst:577
msgid "sysconfig.py"
msgstr ""

#: ../../pep-0572.rst:579
msgid ""
"Calling ``fp.readline()`` in the ``while`` condition and calling "
"``.match()`` on the if lines make the code more compact without making it"
" harder to understand."
msgstr ""

#: ../../pep-0572.rst:617
msgid "Simplifying list comprehensions"
msgstr ""

#: ../../pep-0572.rst:619
msgid ""
"A list comprehension can map and filter efficiently by capturing the "
"condition::"
msgstr ""

#: ../../pep-0572.rst:624
msgid ""
"Similarly, a subexpression can be reused within the main expression, by "
"giving it a name on first use::"
msgstr ""

#: ../../pep-0572.rst:629
msgid ""
"Note that in both cases the variable ``y`` is bound in the containing "
"scope (i.e. at the same level as ``results`` or ``stuff``)."
msgstr ""

#: ../../pep-0572.rst:634
msgid "Capturing condition values"
msgstr ""

#: ../../pep-0572.rst:636
msgid ""
"Assignment expressions can be used to good effect in the header of an "
"``if`` or ``while`` statement::"
msgstr ""

#: ../../pep-0572.rst:659
msgid ""
"Particularly with the ``while`` loop, this can remove the need to have an"
" infinite loop, an assignment, and a condition. It also creates a smooth "
"parallel between a loop which simply uses a function call as its "
"condition, and one which uses that as its condition but also uses the "
"actual value."
msgstr ""

#: ../../pep-0572.rst:665
msgid "Fork"
msgstr ""

#: ../../pep-0572.rst:667
msgid "An example from the low-level UNIX world::"
msgstr ""

#: ../../pep-0572.rst:676
msgid "Rejected alternative proposals"
msgstr ""

#: ../../pep-0572.rst:678
msgid ""
"Proposals broadly similar to this one have come up frequently on python-"
"ideas. Below are a number of alternative syntaxes, some of them specific "
"to comprehensions, which have been rejected in favour of the one given "
"above."
msgstr ""

#: ../../pep-0572.rst:684
msgid "Changing the scope rules for comprehensions"
msgstr ""

#: ../../pep-0572.rst:686
msgid ""
"A previous version of this PEP proposed subtle changes to the scope rules"
" for comprehensions, to make them more usable in class scope and to unify"
" the scope of the \"outermost iterable\" and the rest of the "
"comprehension.  However, this part of the proposal would have caused "
"backwards incompatibilities, and has been withdrawn so the PEP can focus "
"on assignment expressions."
msgstr ""

#: ../../pep-0572.rst:695
msgid "Alternative spellings"
msgstr ""

#: ../../pep-0572.rst:697
msgid ""
"Broadly the same semantics as the current proposal, but spelled "
"differently."
msgstr ""

#: ../../pep-0572.rst:699
msgid "``EXPR as NAME``::"
msgstr ""

#: ../../pep-0572.rst:703
msgid ""
"Since ``EXPR as NAME`` already has meaning in ``import``, ``except`` and "
"``with`` statements (with different semantics), this would create "
"unnecessary confusion or require special-casing (e.g. to forbid "
"assignment within the headers of these statements)."
msgstr ""

#: ../../pep-0572.rst:708
msgid ""
"(Note that ``with EXPR as VAR`` does *not* simply assign the value of "
"``EXPR`` to ``VAR`` -- it calls ``EXPR.__enter__()`` and assigns the "
"result of *that* to ``VAR``.)"
msgstr ""

#: ../../pep-0572.rst:712
msgid "Additional reasons to prefer ``:=`` over this spelling include:"
msgstr ""

#: ../../pep-0572.rst:714
msgid ""
"In ``if f(x) as y`` the assignment target doesn't jump out at you -- it "
"just reads like ``if f x blah blah`` and it is too similar visually to "
"``if f(x) and y``."
msgstr ""

#: ../../pep-0572.rst:718
msgid ""
"In all other situations where an ``as`` clause is allowed, even readers "
"with intermediary skills are led to anticipate that clause (however "
"optional) by the keyword that starts the line, and the grammar ties that "
"keyword closely to the as clause:"
msgstr ""

#: ../../pep-0572.rst:723
msgid "``import foo as bar``"
msgstr ""

#: ../../pep-0572.rst:724
msgid "``except Exc as var``"
msgstr ""

#: ../../pep-0572.rst:725
msgid "``with ctxmgr() as var``"
msgstr ""

#: ../../pep-0572.rst:727
msgid ""
"To the contrary, the assignment expression does not belong to the ``if`` "
"or ``while`` that starts the line, and we intentionally allow assignment "
"expressions in other contexts as well."
msgstr ""

#: ../../pep-0572.rst:731
msgid "The parallel cadence between"
msgstr ""

#: ../../pep-0572.rst:733
msgid "``NAME = EXPR``"
msgstr ""

#: ../../pep-0572.rst:734
msgid "``if NAME := EXPR``"
msgstr ""

#: ../../pep-0572.rst:736
msgid "reinforces the visual recognition of assignment expressions."
msgstr ""

#: ../../pep-0572.rst:738
msgid "``EXPR -> NAME``::"
msgstr ""

#: ../../pep-0572.rst:742
msgid ""
"This syntax is inspired by languages such as R and Haskell, and some "
"programmable calculators. (Note that a left-facing arrow ``y <- f(x)`` is"
" not possible in Python, as it would be interpreted as less-than and "
"unary minus.) This syntax has a slight advantage over 'as' in that it "
"does not conflict with ``with``, ``except`` and ``import``, but otherwise"
" is equivalent.  But it is entirely unrelated to Python's other use of "
"``->`` (function return type annotations), and compared to ``:=`` (which "
"dates back to Algol-58) it has a much weaker tradition."
msgstr ""

#: ../../pep-0572.rst:751
msgid "Adorning statement-local names with a leading dot::"
msgstr ""

#: ../../pep-0572.rst:756
msgid ""
"This has the advantage that leaked usage can be readily detected, "
"removing some forms of syntactic ambiguity.  However, this would be the "
"only place in Python where a variable's scope is encoded into its name, "
"making refactoring harder."
msgstr ""

#: ../../pep-0572.rst:761
msgid "Adding a ``where:`` to any statement to create local name bindings::"
msgstr ""

#: ../../pep-0572.rst:766
msgid ""
"Execution order is inverted (the indented body is performed first, "
"followed by the \"header\").  This requires a new keyword, unless an "
"existing keyword is repurposed (most likely ``with:``).  See PEP 3150 for"
" prior discussion on this subject (with the proposed keyword being "
"``given:``)."
msgstr ""

#: ../../pep-0572.rst:771
msgid "``TARGET from EXPR``::"
msgstr ""

#: ../../pep-0572.rst:775
msgid ""
"This syntax has fewer conflicts than ``as`` does (conflicting only with "
"the ``raise Exc from Exc`` notation), but is otherwise comparable to it. "
"Instead of paralleling ``with expr as target:`` (which can be useful but "
"can also be confusing), this has no parallels, but is evocative."
msgstr ""

#: ../../pep-0572.rst:782
msgid "Special-casing conditional statements"
msgstr ""

#: ../../pep-0572.rst:784
msgid ""
"One of the most popular use-cases is ``if`` and ``while`` statements.  "
"Instead of a more general solution, this proposal enhances the syntax of "
"these two statements to add a means of capturing the compared value::"
msgstr ""

#: ../../pep-0572.rst:791
msgid ""
"This works beautifully if and ONLY if the desired condition is based on "
"the truthiness of the captured value.  It is thus effective for specific "
"use-cases (regex matches, socket reads that return ``''`` when done), and"
" completely useless in more complicated cases (e.g. where the condition "
"is ``f(x) < 0`` and you want to capture the value of ``f(x)``).  It also "
"has no benefit to list comprehensions."
msgstr ""

#: ../../pep-0572.rst:798
msgid ""
"Advantages: No syntactic ambiguities. Disadvantages: Answers only a "
"fraction of possible use-cases, even in ``if``/``while`` statements."
msgstr ""

#: ../../pep-0572.rst:803
msgid "Special-casing comprehensions"
msgstr ""

#: ../../pep-0572.rst:805
msgid ""
"Another common use-case is comprehensions (list/set/dict, and genexps). "
"As above, proposals have been made for comprehension-specific solutions."
msgstr ""

#: ../../pep-0572.rst:808
msgid "``where``, ``let``, or ``given``::"
msgstr ""

#: ../../pep-0572.rst:814
msgid ""
"This brings the subexpression to a location in between the 'for' loop and"
" the expression. It introduces an additional language keyword, which "
"creates conflicts. Of the three, ``where`` reads the most cleanly, but "
"also has the greatest potential for conflict (e.g. SQLAlchemy and numpy "
"have ``where`` methods, as does ``tkinter.dnd.Icon`` in the standard "
"library)."
msgstr ""

#: ../../pep-0572.rst:820
msgid "``with NAME = EXPR``::"
msgstr ""

#: ../../pep-0572.rst:824
msgid ""
"As above, but reusing the ``with`` keyword. Doesn't read too badly, and "
"needs no additional language keyword. Is restricted to comprehensions, "
"though, and cannot as easily be transformed into \"longhand\" for-loop "
"syntax. Has the C problem that an equals sign in an expression can now "
"create a name binding, rather than performing a comparison. Would raise "
"the question of why \"with NAME = EXPR:\" cannot be used as a statement "
"on its own."
msgstr ""

#: ../../pep-0572.rst:831
msgid "``with EXPR as NAME``::"
msgstr ""

#: ../../pep-0572.rst:835
msgid ""
"As per option 2, but using ``as`` rather than an equals sign. Aligns "
"syntactically with other uses of ``as`` for name binding, but a simple "
"transformation to for-loop longhand would create drastically different "
"semantics; the meaning of ``with`` inside a comprehension would be "
"completely different from the meaning as a stand-alone statement, while "
"retaining identical syntax."
msgstr ""

#: ../../pep-0572.rst:842
msgid ""
"Regardless of the spelling chosen, this introduces a stark difference "
"between comprehensions and the equivalent unrolled long-hand form of the "
"loop.  It is no longer possible to unwrap the loop into statement form "
"without reworking any name bindings.  The only keyword that can be "
"repurposed to this task is ``with``, thus giving it sneakily different "
"semantics in a comprehension than in a statement; alternatively, a new "
"keyword is needed, with all the costs therein."
msgstr ""

#: ../../pep-0572.rst:852
msgid "Lowering operator precedence"
msgstr ""

#: ../../pep-0572.rst:854
msgid ""
"There are two logical precedences for the ``:=`` operator. Either it "
"should bind as loosely as possible, as does statement-assignment; or it "
"should bind more tightly than comparison operators. Placing its "
"precedence between the comparison and arithmetic operators (to be "
"precise: just lower than bitwise OR) allows most uses inside ``while`` "
"and ``if`` conditions to be spelled without parentheses, as it is most "
"likely that you wish to capture the value of something, then perform a "
"comparison on it::"
msgstr ""

#: ../../pep-0572.rst:866
msgid ""
"Once find() returns -1, the loop terminates. If ``:=`` binds as loosely "
"as ``=`` does, this would capture the result of the comparison (generally"
" either ``True`` or ``False``), which is less useful."
msgstr ""

#: ../../pep-0572.rst:870
msgid ""
"While this behaviour would be convenient in many situations, it is also "
"harder to explain than \"the := operator behaves just like the assignment"
" statement\", and as such, the precedence for ``:=`` has been made as "
"close as possible to that of ``=`` (with the exception that it binds "
"tighter than comma)."
msgstr ""

#: ../../pep-0572.rst:877
msgid "Allowing commas to the right"
msgstr ""

#: ../../pep-0572.rst:879
msgid ""
"Some critics have claimed that the assignment expressions should allow "
"unparenthesized tuples on the right, so that these two would be "
"equivalent::"
msgstr ""

#: ../../pep-0572.rst:885
msgid ""
"(With the current version of the proposal, the latter would be equivalent"
" to ``((point := x), y)``.)"
msgstr ""

#: ../../pep-0572.rst:888
msgid ""
"However, adopting this stance would logically lead to the conclusion that"
" when used in a function call, assignment expressions also bind less "
"tight than comma, so we'd have the following confusing equivalence::"
msgstr ""

#: ../../pep-0572.rst:895
msgid "The less confusing option is to make ``:=`` bind more tightly than comma."
msgstr ""

#: ../../pep-0572.rst:899
msgid "Always requiring parentheses"
msgstr ""

#: ../../pep-0572.rst:901
msgid ""
"It's been proposed to just always require parenthesize around an "
"assignment expression.  This would resolve many ambiguities, and indeed "
"parentheses will frequently be needed to extract the desired "
"subexpression.  But in the following cases the extra parentheses feel "
"redundant::"
msgstr ""

#: ../../pep-0572.rst:916
msgid "Frequently Raised Objections"
msgstr ""

#: ../../pep-0572.rst:919
msgid "Why not just turn existing assignment into an expression?"
msgstr ""

#: ../../pep-0572.rst:921
msgid ""
"C and its derivatives define the ``=`` operator as an expression, rather "
"than a statement as is Python's way.  This allows assignments in more "
"contexts, including contexts where comparisons are more common.  The "
"syntactic similarity between ``if (x == y)`` and ``if (x = y)`` belies "
"their drastically different semantics.  Thus this proposal uses ``:=`` to"
" clarify the distinction."
msgstr ""

#: ../../pep-0572.rst:929
msgid "With assignment expressions, why bother with assignment statements?"
msgstr ""

#: ../../pep-0572.rst:931
msgid ""
"The two forms have different flexibilities.  The ``:=`` operator can be "
"used inside a larger expression; the ``=`` statement can be augmented to "
"``+=`` and its friends, can be chained, and can assign to attributes and "
"subscripts."
msgstr ""

#: ../../pep-0572.rst:937
msgid "Why not use a sublocal scope and prevent namespace pollution?"
msgstr ""

#: ../../pep-0572.rst:939
msgid ""
"Previous revisions of this proposal involved sublocal scope (restricted "
"to a single statement), preventing name leakage and namespace pollution."
"  While a definite advantage in a number of situations, this increases "
"complexity in many others, and the costs are not justified by the "
"benefits. In the interests of language simplicity, the name bindings "
"created here are exactly equivalent to any other name bindings, including"
" that usage at class or module scope will create externally-visible "
"names.  This is no different from ``for`` loops or other constructs, and "
"can be solved the same way: ``del`` the name once it is no longer needed,"
" or prefix it with an underscore."
msgstr ""

#: ../../pep-0572.rst:949
msgid ""
"(The author wishes to thank Guido van Rossum and Christoph Groth for "
"their suggestions to move the proposal in this direction. [2]_)"
msgstr ""

#: ../../pep-0572.rst:954
msgid "Style guide recommendations"
msgstr ""

#: ../../pep-0572.rst:956
msgid ""
"As expression assignments can sometimes be used equivalently to statement"
" assignments, the question of which should be preferred will arise. For "
"the benefit of style guides such as PEP 8, two recommendations are "
"suggested."
msgstr ""

#: ../../pep-0572.rst:960
msgid ""
"If either assignment statements or assignment expressions can be used, "
"prefer statements; they are a clear declaration of intent."
msgstr ""

#: ../../pep-0572.rst:963
msgid ""
"If using assignment expressions would lead to ambiguity about execution "
"order, restructure it to use statements instead."
msgstr ""

#: ../../pep-0572.rst:968
msgid "Acknowledgements"
msgstr ""

#: ../../pep-0572.rst:970
msgid ""
"The authors wish to thank Nick Coghlan and Steven D'Aprano for their "
"considerable contributions to this proposal, and members of the core-"
"mentorship mailing list for assistance with implementation."
msgstr ""

#: ../../pep-0572.rst:976
msgid "Appendix A: Tim Peters's findings"
msgstr ""

#: ../../pep-0572.rst:978
msgid "Here's a brief essay Tim Peters wrote on the topic."
msgstr ""

#: ../../pep-0572.rst:980
msgid ""
"I dislike \"busy\" lines of code, and also dislike putting conceptually "
"unrelated logic on a single line.  So, for example, instead of::"
msgstr ""

#: ../../pep-0572.rst:985
msgid "I prefer::"
msgstr ""

#: ../../pep-0572.rst:991
msgid ""
"instead.  So I suspected I'd find few places I'd want to use assignment "
"expressions.  I didn't even consider them for lines already stretching "
"halfway across the screen.  In other cases, \"unrelated\" ruled::"
msgstr ""

#: ../../pep-0572.rst:999
msgid "is a vast improvement over the briefer::"
msgstr ""

#: ../../pep-0572.rst:1003
msgid ""
"The original two statements are doing entirely different conceptual "
"things, and slamming them together is conceptually insane."
msgstr ""

#: ../../pep-0572.rst:1006
msgid ""
"In other cases, combining related logic made it harder to understand, "
"such as rewriting::"
msgstr ""

#: ../../pep-0572.rst:1017
msgid "as the briefer::"
msgstr ""

#: ../../pep-0572.rst:1024
msgid ""
"The ``while`` test there is too subtle, crucially relying on strict left-"
"to-right evaluation in a non-short-circuiting or method-chaining context."
"  My brain isn't wired that way."
msgstr ""

#: ../../pep-0572.rst:1028
msgid ""
"But cases like that were rare.  Name binding is very frequent, and "
"\"sparse is better than dense\" does not mean \"almost empty is better "
"than sparse\".  For example, I have many functions that return ``None`` "
"or ``0`` to communicate \"I have nothing useful to return in this case, "
"but since that's expected often I'm not going to annoy you with an "
"exception\".  This is essentially the same as regular expression search "
"functions returning ``None`` when there is no match.  So there was lots "
"of code of the form::"
msgstr ""

#: ../../pep-0572.rst:1041
msgid ""
"I find that clearer, and certainly a bit less typing and pattern-matching"
" reading, as::"
msgstr ""

#: ../../pep-0572.rst:1047
msgid ""
"It's also nice to trade away a small amount of horizontal whitespace to "
"get another _line_ of surrounding code on screen.  I didn't give much "
"weight to this at first, but it was so very frequent it added up, and I "
"soon enough became annoyed that I couldn't actually run the briefer code."
"  That surprised me!"
msgstr ""

#: ../../pep-0572.rst:1053
msgid ""
"There are other cases where assignment expressions really shine. Rather "
"than pick another from my code, Kirill Balunov gave a lovely example from"
" the standard library's ``copy()`` function in ``copy.py``::"
msgstr ""

#: ../../pep-0572.rst:1071
msgid ""
"The ever-increasing indentation is semantically misleading: the logic is "
"conceptually flat, \"the first test that succeeds wins\"::"
msgstr ""

#: ../../pep-0572.rst:1083
msgid ""
"Using easy assignment expressions allows the visual structure of the code"
" to emphasize the conceptual flatness of the logic; ever-increasing "
"indentation obscured it."
msgstr ""

#: ../../pep-0572.rst:1087
msgid ""
"A smaller example from my code delighted me, both allowing to put "
"inherently related logic in a single line, and allowing to remove an "
"annoying \"artificial\" indentation level::"
msgstr ""

#: ../../pep-0572.rst:1097
msgid "became::"
msgstr ""

#: ../../pep-0572.rst:1102
msgid ""
"That ``if`` is about as long as I want my lines to get, but remains easy "
"to follow."
msgstr ""

#: ../../pep-0572.rst:1105
msgid ""
"So, in all, in most lines binding a name, I wouldn't use assignment "
"expressions, but because that construct is so very frequent, that leaves "
"many places I would.  In most of the latter, I found a small win that "
"adds up due to how often it occurs, and in the rest I found a moderate to"
" major win.  I'd certainly use it more often than ternary ``if``, but "
"significantly less often than augmented assignment."
msgstr ""

#: ../../pep-0572.rst:1113
msgid "A numeric example"
msgstr ""

#: ../../pep-0572.rst:1115
msgid "I have another example that quite impressed me at the time."
msgstr ""

#: ../../pep-0572.rst:1117
msgid ""
"Where all variables are positive integers, and a is at least as large as "
"the n'th root of x, this algorithm returns the floor of the n'th root of "
"x (and roughly doubling the number of accurate bits per iteration)::"
msgstr ""

#: ../../pep-0572.rst:1126
msgid ""
"It's not obvious why that works, but is no more obvious in the \"loop and"
" a half\" form. It's hard to prove correctness without building on the "
"right insight (the \"arithmetic mean - geometric mean inequality\"), and "
"knowing some non-trivial things about how nested floor functions behave. "
"That is, the challenges are in the math, not really in the coding."
msgstr ""

#: ../../pep-0572.rst:1133
msgid ""
"If you do know all that, then the assignment-expression form is easily "
"read as \"while the current guess is too large, get a smaller guess\", "
"where the \"too large?\" test and the new guess share an expensive sub-"
"expression."
msgstr ""

#: ../../pep-0572.rst:1138
msgid "To my eyes, the original form is harder to understand::"
msgstr ""

#: ../../pep-0572.rst:1149
msgid "Appendix B: Rough code translations for comprehensions"
msgstr ""

#: ../../pep-0572.rst:1151
msgid ""
"This appendix attempts to clarify (though not specify) the rules when a "
"target occurs in a comprehension or in a generator expression. For a "
"number of illustrative examples we show the original code, containing a "
"comprehension, and the translation, where the comprehension has been "
"replaced by an equivalent generator function plus some scaffolding."
msgstr ""

#: ../../pep-0572.rst:1158
msgid ""
"Since ``[x for ...]`` is equivalent to ``list(x for ...)`` these examples"
" all use list comprehensions without loss of generality. And since these "
"examples are meant to clarify edge cases of the rules, they aren't trying"
" to look like real code."
msgstr ""

#: ../../pep-0572.rst:1163
msgid ""
"Note: comprehensions are already implemented via synthesizing nested "
"generator functions like those in this appendix.  The new part is adding "
"appropriate declarations to establish the intended scope of assignment "
"expression targets (the same scope they resolve to as if the assignment "
"were performed in the block containing the outermost comprehension).  For"
" type inference purposes, these illustrative expansions do not imply that"
" assignment expression targets are always Optional (but they do indicate "
"the target binding scope)."
msgstr ""

#: ../../pep-0572.rst:1172
msgid ""
"Let's start with a reminder of what code is generated for a generator "
"expression without assignment expression."
msgstr ""

#: ../../pep-0572.rst:1175
msgid "Original code (EXPR usually references VAR)::"
msgstr ""

#: ../../pep-0572.rst:1180
msgid "Translation (let's not worry about name conflicts)::"
msgstr ""

#: ../../pep-0572.rst:1188
msgid "Let's add a simple assignment expression."
msgstr ""

#: ../../pep-0572.rst:1190 ../../pep-0572.rst:1209 ../../pep-0572.rst:1228
#: ../../pep-0572.rst:1251
msgid "Original code::"
msgstr ""

#: ../../pep-0572.rst:1195 ../../pep-0572.rst:1215 ../../pep-0572.rst:1236
#: ../../pep-0572.rst:1258
msgid "Translation::"
msgstr ""

#: ../../pep-0572.rst:1207
msgid "Let's add a ``global TARGET`` declaration in ``f()``."
msgstr ""

#: ../../pep-0572.rst:1226
msgid "Or instead let's add a ``nonlocal TARGET`` declaration in ``f()``."
msgstr ""

#: ../../pep-0572.rst:1249
msgid "Finally, let's nest two comprehensions."
msgstr ""

#: ../../pep-0572.rst:1277
msgid "Appendix C: No Changes to Scope Semantics"
msgstr ""

#: ../../pep-0572.rst:1279
msgid ""
"Because it has been a point of confusion, note that nothing about "
"Python's scoping semantics is changed.  Function-local scopes continue to"
" be resolved at compile time, and to have indefinite temporal extent at "
"run time (\"full closures\").  Example::"
msgstr ""

#: ../../pep-0572.rst:1297
msgid "Then::"
msgstr ""

#: ../../pep-0572.rst:1315
msgid "References"
msgstr ""

#: ../../pep-0572.rst:1317
msgid ""
"Proof of concept implementation (https://github.com/Rosuav/cpython/tree"
"/assignment-expressions)"
msgstr ""

#: ../../pep-0572.rst:1319
msgid ""
"Pivotal post regarding inline assignment semantics "
"(https://mail.python.org/pipermail/python-ideas/2018-March/049409.html)"
msgstr ""

#: ../../pep-0572.rst:1321
msgid ""
"Discussion of PEP 572 TargetScopeError "
"(https://mail.python.org/archives/list/python-"
"dev@python.org/thread/FXVSYCTQOTT7JCFACKPGPXKULBCGEPQY/)"
msgstr ""

#: ../../pep-0572.rst:1326
msgid "Copyright"
msgstr ""

#: ../../pep-0572.rst:1328
msgid "This document has been placed in the public domain."
msgstr ""

