# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0236.txt
msgid "PEP"
msgstr ""

#: ../../pep-0236.txt:1
msgid "236"
msgstr ""

#: ../../pep-0236.txt
msgid "Title"
msgstr ""

#: ../../pep-0236.txt:2
msgid "Back to the __future__"
msgstr ""

#: ../../pep-0236.txt
msgid "Author"
msgstr ""

#: ../../pep-0236.txt:5
msgid "Tim Peters <tim.peters@gmail.com>"
msgstr ""

#: ../../pep-0236.txt
msgid "Status"
msgstr ""

#: ../../pep-0236.txt:6
msgid "Final"
msgstr ""

#: ../../pep-0236.txt
msgid "Type"
msgstr ""

#: ../../pep-0236.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0236.txt
msgid "Created"
msgstr ""

#: ../../pep-0236.txt:9 ../../pep-0236.txt:11
msgid "26-Feb-2001"
msgstr ""

#: ../../pep-0236.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0236.txt:10
msgid "2.1"
msgstr ""

#: ../../pep-0236.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0236.txt:15
msgid "Motivation"
msgstr ""

#: ../../pep-0236.txt:17
msgid ""
"From time to time, Python makes an incompatible change to the advertised "
"semantics of core language constructs, or changes their accidental "
"(implementation-dependent) behavior in some way.  While this is never "
"done capriciously, and is always done with the aim of improving the "
"language over the long term, over the short term it's contentious and "
"disrupting."
msgstr ""

#: ../../pep-0236.txt:23
msgid ""
"PEP 5, Guidelines for Language Evolution [1]_ suggests ways to ease the "
"pain, and this PEP introduces some machinery in support of that."
msgstr ""

#: ../../pep-0236.txt:26
msgid ""
"PEP 227, Statically Nested Scopes [2]_ is the first application, and will"
" be used as an example here."
msgstr ""

#: ../../pep-0236.txt:31
msgid "Intent"
msgstr ""

#: ../../pep-0236.txt:33
msgid "[Note:  This is policy, and so should eventually move into PEP 5 [1]_]"
msgstr ""

#: ../../pep-0236.txt:35
msgid ""
"When an incompatible change to core language syntax or semantics is being"
" made:"
msgstr ""

#: ../../pep-0236.txt:38
msgid ""
"The release C that introduces the change does not change the syntax or "
"semantics by default."
msgstr ""

#: ../../pep-0236.txt:41
msgid ""
"A future release R is identified in which the new syntax or semantics "
"will be enforced."
msgstr ""

#: ../../pep-0236.txt:44
msgid ""
"The mechanisms described in PEP 3, Warning Framework [3]_ are used to "
"generate warnings, whenever possible, about constructs or operations "
"whose meaning may [4]_ change in release R."
msgstr ""

#: ../../pep-0236.txt:48
msgid ""
"The new future_statement (see below) can be explicitly included in a "
"module M to request that the code in module M use the new syntax or "
"semantics in the current release C."
msgstr ""

#: ../../pep-0236.txt:52
msgid ""
"So old code continues to work by default, for at least one release, "
"although it may start to generate new warning messages.  Migration to the"
" new syntax or semantics can proceed during that time, using the "
"future_statement to make modules containing it act as if the new syntax "
"or semantics were already being enforced."
msgstr ""

#: ../../pep-0236.txt:58
msgid ""
"Note that there is no need to involve the future_statement machinery in "
"new features unless they can break existing code; fully backward- "
"compatible additions can-- and should --be introduced without a "
"corresponding future_statement."
msgstr ""

#: ../../pep-0236.txt:65
msgid "Syntax"
msgstr ""

#: ../../pep-0236.txt:67
msgid ""
"A future_statement is simply a from/import statement using the reserved "
"module name ``__future__``::"
msgstr ""

#: ../../pep-0236.txt:76
msgid ""
"In addition, all future_statements must appear near the top of the "
"module.  The only lines that can appear before a future_statement are:"
msgstr ""

#: ../../pep-0236.txt:79
msgid "The module docstring (if any)."
msgstr ""

#: ../../pep-0236.txt:80
msgid "Comments."
msgstr ""

#: ../../pep-0236.txt:81
msgid "Blank lines."
msgstr ""

#: ../../pep-0236.txt:82
msgid "Other future_statements."
msgstr ""

#: ../../pep-0236.txt:84
msgid "Example::"
msgstr ""

#: ../../pep-0236.txt:98
msgid "Semantics"
msgstr ""

#: ../../pep-0236.txt:100
msgid ""
"A future_statement is recognized and treated specially at compile time: "
"changes to the semantics of core constructs are often implemented by "
"generating different code.  It may even be the case that a new feature "
"introduces new incompatible syntax (such as a new reserved word), in "
"which case the compiler may need to parse the module differently.  Such "
"decisions cannot be pushed off until runtime."
msgstr ""

#: ../../pep-0236.txt:107
msgid ""
"For any given release, the compiler knows which feature names have been "
"defined, and raises a compile-time error if a future_statement contains a"
" feature not known to it [5]_."
msgstr ""

#: ../../pep-0236.txt:111
msgid ""
"The direct runtime semantics are the same as for any ``import`` "
"statement: there is a standard module ``__future__.py``, described later,"
" and it will be imported in the usual way at the time the "
"future_statement is executed."
msgstr ""

#: ../../pep-0236.txt:115
msgid ""
"The *interesting* runtime semantics depend on the specific feature(s) "
"\"imported\" by the future_statement(s) appearing in the module."
msgstr ""

#: ../../pep-0236.txt:118
msgid "Note that there is nothing special about the statement::"
msgstr ""

#: ../../pep-0236.txt:122
msgid ""
"That is not a future_statement; it's an ordinary import statement, with "
"no special semantics or syntax restrictions."
msgstr ""

#: ../../pep-0236.txt:127
msgid "Example"
msgstr ""

#: ../../pep-0236.txt:129
msgid "Consider this code, in file scope.py::"
msgstr ""

#: ../../pep-0236.txt:139
msgid "Under 2.0, it prints::"
msgstr ""

#: ../../pep-0236.txt:143
msgid ""
"Nested scopes [2]_ are being introduced in 2.1.  But under 2.1, it still "
"prints::"
msgstr ""

#: ../../pep-0236.txt:148
msgid "and also generates a warning."
msgstr ""

#: ../../pep-0236.txt:150
msgid ""
"In 2.2, and also in 2.1 *if* ``from __future__ import nested_scopes`` is "
"included at the top of ``scope.py``, it prints::"
msgstr ""

#: ../../pep-0236.txt:157
msgid "Standard Module __future__.py"
msgstr ""

#: ../../pep-0236.txt:159
msgid "``Lib/__future__.py`` is a real module, and serves three purposes:"
msgstr ""

#: ../../pep-0236.txt:161
msgid ""
"To avoid confusing existing tools that analyze import statements and "
"expect to find the modules they're importing."
msgstr ""

#: ../../pep-0236.txt:164
msgid ""
"To ensure that future_statements run under releases prior to 2.1 at least"
" yield runtime exceptions (the import of ``__future__`` will fail, "
"because there was no module of that name prior to 2.1)."
msgstr ""

#: ../../pep-0236.txt:168
msgid ""
"To document when incompatible changes were introduced, and when they will"
" be-- or were --made mandatory.  This is a form of executable "
"documentation, and can be inspected programmatically via importing "
"``__future__`` and examining its contents."
msgstr ""

#: ../../pep-0236.txt:173
msgid "Each statement in ``__future__.py`` is of the form::"
msgstr ""

#: ../../pep-0236.txt:177
msgid ""
"where, normally, *OptionalRelease* <  *MandatoryRelease*, and both are "
"5-tuples of the same form as ``sys.version_info``::"
msgstr ""

#: ../../pep-0236.txt:186
msgid "*OptionalRelease* records the first release in which::"
msgstr ""

#: ../../pep-0236.txt:190
msgid "was accepted."
msgstr ""

#: ../../pep-0236.txt:192
msgid ""
"In the case of *MandatoryReleases* that have not yet occurred, "
"*MandatoryRelease* predicts the release in which the feature will become "
"part of the language."
msgstr ""

#: ../../pep-0236.txt:196
msgid ""
"Else *MandatoryRelease* records when the feature became part of the "
"language; in releases at or after that, modules no longer need::"
msgstr ""

#: ../../pep-0236.txt:201
msgid "to use the feature in question, but may continue to use such imports."
msgstr ""

#: ../../pep-0236.txt:203
msgid ""
"*MandatoryRelease* may also be ``None``, meaning that a planned feature "
"got dropped."
msgstr ""

#: ../../pep-0236.txt:206
msgid ""
"Instances of ``class _Feature`` have two corresponding methods, "
"``.getOptionalRelease()`` and ``.getMandatoryRelease()``."
msgstr ""

#: ../../pep-0236.txt:209
msgid "No feature line will ever be deleted from ``__future__.py``."
msgstr ""

#: ../../pep-0236.txt:211
msgid "Example line::"
msgstr ""

#: ../../pep-0236.txt:215
msgid "This means that::"
msgstr ""

#: ../../pep-0236.txt:219
msgid ""
"will work in all releases at or after 2.1b1, and that nested_scopes are "
"intended to be enforced starting in release 2.2."
msgstr ""

#: ../../pep-0236.txt:224
msgid "Resolved Problem:  Runtime Compilation"
msgstr ""

#: ../../pep-0236.txt:226
msgid "Several Python features can compile code during a module's runtime:"
msgstr ""

#: ../../pep-0236.txt:228
msgid "The ``exec`` statement."
msgstr ""

#: ../../pep-0236.txt:229
msgid "The ``execfile()`` function."
msgstr ""

#: ../../pep-0236.txt:230
msgid "The ``compile()`` function."
msgstr ""

#: ../../pep-0236.txt:231
msgid "The ``eval()`` function."
msgstr ""

#: ../../pep-0236.txt:232
msgid "The ``input()`` function."
msgstr ""

#: ../../pep-0236.txt:234
msgid ""
"Since a module M containing a future_statement naming feature F "
"explicitly requests that the current release act like a future release "
"with respect to F, any code compiled dynamically from text passed to one "
"of these from within M should probably also use the new syntax or "
"semantics associated with F.  The 2.1 release does behave this way."
msgstr ""

#: ../../pep-0236.txt:240
msgid ""
"This isn't always desired, though.  For example, ``doctest.testmod(M)`` "
"compiles examples taken from strings in M, and those examples should use "
"M's choices, not necessarily the doctest module's choices.  In the 2.1 "
"release, this isn't possible, and no scheme has yet been suggested for "
"working around this.  NOTE: PEP 264 later addressed this in a flexible "
"way, by adding optional arguments to ``compile()``."
msgstr ""

#: ../../pep-0236.txt:247
msgid ""
"In any case, a future_statement appearing \"near the top\" (see Syntax "
"above) of text compiled dynamically by an ``exec``, ``execfile()`` or "
"``compile()`` applies to the code block generated, but has no further "
"effect on the module that executes such an ``exec``, ``execfile()`` or "
"``compile()``.  This can't be used to affect ``eval()`` or ``input()``, "
"however, because they only allow expression input, and a future_statement"
" is not an expression."
msgstr ""

#: ../../pep-0236.txt:256
msgid "Resolved Problem:  Native Interactive Shells"
msgstr ""

#: ../../pep-0236.txt:258
msgid "There are two ways to get an interactive shell:"
msgstr ""

#: ../../pep-0236.txt:260
msgid "By invoking Python from a command line without a script argument."
msgstr ""

#: ../../pep-0236.txt:262
msgid ""
"By invoking Python from a command line with the ``-i`` switch and with a "
"script argument."
msgstr ""

#: ../../pep-0236.txt:265
msgid ""
"An interactive shell can be seen as an extreme case of runtime "
"compilation (see above):  in effect, each statement typed at an "
"interactive shell prompt runs a new instance of ``exec``, ``compile()`` "
"or ``execfile()``.  A future_statement typed at an interactive shell "
"applies to the rest of the shell session's life, as if the "
"future_statement had appeared at the top of a module."
msgstr ""

#: ../../pep-0236.txt:274
msgid "Resolved Problem:  Simulated Interactive Shells"
msgstr ""

#: ../../pep-0236.txt:276
msgid ""
"Interactive shells \"built by hand\" (by tools such as IDLE and the Emacs"
" Python-mode) should behave like native interactive shells (see above). "
"However, the machinery used internally by native interactive shells has "
"not been exposed, and there isn't a clear way for tools building their "
"own interactive shells to achieve the desired behavior."
msgstr ""

#: ../../pep-0236.txt:282
msgid ""
"NOTE:  PEP 264 later addressed this, by adding intelligence to the "
"standard ``codeop.py``.  Simulated shells that don't use the standard "
"library shell helpers can get a similar effect by exploiting the new "
"optional arguments to ``compile()`` added by PEP 264."
msgstr ""

#: ../../pep-0236.txt:289
msgid "Questions and Answers"
msgstr ""

#: ../../pep-0236.txt:292
msgid "What about a \"from __past__\" version, to get back *old* behavior?"
msgstr ""

#: ../../pep-0236.txt:294
msgid ""
"Outside the scope of this PEP.  Seems unlikely to the author, though.  "
"Write a PEP if you want to pursue it."
msgstr ""

#: ../../pep-0236.txt:298
msgid "What about incompatibilities due to changes in the Python virtual machine?"
msgstr ""

#: ../../pep-0236.txt:300
msgid ""
"Outside the scope of this PEP, although PEP 5 [1]_ suggests a grace "
"period there too, and the future_statement may also have a role to play "
"there."
msgstr ""

#: ../../pep-0236.txt:304
msgid "What about incompatibilities due to changes in Python's C API?"
msgstr ""

#: ../../pep-0236.txt:306
msgid "Outside the scope of this PEP."
msgstr ""

#: ../../pep-0236.txt:309
msgid ""
"I want to wrap future_statements in try/except blocks, so I can use "
"different code depending on which version of Python I'm running. Why "
"can't I?"
msgstr ""

#: ../../pep-0236.txt:311
msgid ""
"Sorry!  ``try/except`` is a runtime feature; future_statements are "
"primarily compile-time gimmicks, and your ``try/except`` happens long "
"after the compiler is done.  That is, by the time you do ``try/except``, "
"the semantics in effect for the module are already a done deal.  Since "
"the ``try/except`` wouldn't accomplish what it *looks* like it should "
"accomplish, it's simply not allowed. We also want to keep these special "
"statements very easy to find and to recognize."
msgstr ""

#: ../../pep-0236.txt:319
msgid ""
"Note that you *can* import ``__future__`` directly, and use the "
"information in it, along with ``sys.version_info``, to figure out where "
"the release you're running under stands in relation to a given feature's "
"status."
msgstr ""

#: ../../pep-0236.txt:324
msgid ""
"Going back to the nested_scopes example, what if release 2.2 comes along "
"and I still haven't changed my code?  How can I keep the 2.1 behavior "
"then?"
msgstr ""

#: ../../pep-0236.txt:326
msgid ""
"By continuing to use 2.1, and not moving to 2.2 until you do change your "
"code.  The purpose of future_statement is to make life easier for people "
"who keep current with the latest release in a timely fashion.  We don't "
"hate you if you don't, but your problems are much harder to solve, and "
"somebody with those problems will need to write a PEP addressing them.  "
"future_statement is aimed at a different audience."
msgstr ""

#: ../../pep-0236.txt:334
msgid "Overloading ``import`` sucks.  Why not introduce a new statement for this?"
msgstr ""

#: ../../pep-0236.txt:336
msgid ""
"Like maybe ``lambda lambda nested_scopes``?  That is, unless we introduce"
" a new keyword, we can't introduce an entirely new statement.  But if we "
"introduce a new keyword, that in itself would break old code.  That would"
" be too ironic to bear.  Yes, overloading ``import`` does suck, but not "
"as energetically as the alternatives -- as is, future_statements are 100%"
" backward compatible."
msgstr ""

#: ../../pep-0236.txt:345
msgid "Copyright"
msgstr ""

#: ../../pep-0236.txt:347
msgid "This document has been placed in the public domain."
msgstr ""

#: ../../pep-0236.txt:351
msgid "References and Footnotes"
msgstr ""

#: ../../pep-0236.txt:353
msgid ""
"PEP 5, Guidelines for Language Evolution, Prescod "
"http://www.python.org/dev/peps/pep-0005/"
msgstr ""

#: ../../pep-0236.txt:356
msgid ""
"PEP 227, Statically Nested Scopes, Hylton "
"http://www.python.org/dev/peps/pep-0227/"
msgstr ""

#: ../../pep-0236.txt:359
msgid ""
"PEP 230, Warning Framework, Van Rossum "
"http://www.python.org/dev/peps/pep-0230/"
msgstr ""

#: ../../pep-0236.txt:362
msgid ""
"Note that this is *may* and not *will*:  better safe than sorry.  Of "
"course spurious warnings won't be generated when avoidable with "
"reasonable cost."
msgstr ""

#: ../../pep-0236.txt:365
msgid ""
"This ensures that a future_statement run under a release prior to the "
"first one in which a given feature is known (but >= 2.1) will raise a "
"compile-time error rather than silently do a wrong thing. If transported "
"to a release prior to 2.1, a runtime error will be raised because of the "
"failure to import ``__future__`` (no such module existed in the standard "
"distribution before the 2.1 release, and the double underscores make it a"
" reserved name)."
msgstr ""

