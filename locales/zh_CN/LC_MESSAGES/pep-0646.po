# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0646.rst
msgid "PEP"
msgstr ""

#: ../../pep-0646.rst:1
msgid "646"
msgstr ""

#: ../../pep-0646.rst
msgid "Title"
msgstr ""

#: ../../pep-0646.rst:2
msgid "Variadic Generics"
msgstr ""

#: ../../pep-0646.rst
msgid "Author"
msgstr ""

#: ../../pep-0646.rst:3
msgid ""
"Mark Mendoza <mendoza.mark.a@gmail.com>, Matthew Rahtz "
"<mrahtz@google.com>, Pradeep Kumar Srinivasan <gohanpra@gmail.com>, "
"Vincent Siles <vsiles@fb.com>"
msgstr ""

#: ../../pep-0646.rst
msgid "Sponsor"
msgstr ""

#: ../../pep-0646.rst:7
msgid "Guido van Rossum <guido@python.org>"
msgstr ""

#: ../../pep-0646.rst
msgid "Status"
msgstr ""

#: ../../pep-0646.rst:8
msgid "Draft"
msgstr ""

#: ../../pep-0646.rst
msgid "Type"
msgstr ""

#: ../../pep-0646.rst:9
msgid "Standards Track"
msgstr ""

#: ../../pep-0646.rst
msgid "Created"
msgstr ""

#: ../../pep-0646.rst:11
msgid "16-Sep-2020"
msgstr ""

#: ../../pep-0646.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0646.rst:12
msgid "3.10"
msgstr ""

#: ../../pep-0646.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0646.rst:13
msgid "07-Oct-2020, 23-Dec-2020, 29-Dec-2020"
msgstr ""

#: ../../pep-0646.rst:16
msgid "Abstract"
msgstr ""

#: ../../pep-0646.rst:18
msgid ""
"PEP 484 introduced ``TypeVar``, enabling creation of generics "
"parameterised with a single type. In this PEP, we introduce "
"``TypeVarTuple``, enabling parameterisation with an *arbitrary* number of"
" types - that is, a *variadic* type variable, enabling *variadic* "
"generics. This enables a wide variety of use cases. In particular, it "
"allows the type of array-like structures in numerical computing libraries"
" such as NumPy and TensorFlow to be parameterised with the array *shape*,"
" enabling static type checkers to catch shape-related bugs in code that "
"uses these libraries."
msgstr ""

#: ../../pep-0646.rst:28
msgid "Motivation"
msgstr ""

#: ../../pep-0646.rst:30
msgid ""
"Variadic generics have long been a requested feature, for a myriad of use"
" cases [#typing193]_. One particular use case - a use case with "
"potentially large impact, and the main case this PEP targets - concerns "
"typing in numerical libraries."
msgstr ""

#: ../../pep-0646.rst:35
msgid ""
"In the context of numerical computation with libraries such as NumPy and "
"TensorFlow, the *shape* of variables is often just as important as the "
"variable *type*. For example, consider the following function which "
"converts a batch [#batch]_ of videos to grayscale:"
msgstr ""

#: ../../pep-0646.rst:44
msgid ""
"From the signature alone, it is not obvious what shape of array [#array]_"
" we should pass for the ``videos`` argument. Possibilities include, for "
"example,"
msgstr ""

#: ../../pep-0646.rst:48
msgid "batch × time × height × width × channels"
msgstr ""

#: ../../pep-0646.rst:50
msgid "and"
msgstr ""

#: ../../pep-0646.rst:52
msgid "time × batch × channels × height × width. [#timebatch]_"
msgstr ""

#: ../../pep-0646.rst:54
msgid "This is important for three reasons:"
msgstr ""

#: ../../pep-0646.rst:56
msgid ""
"**Documentation**. Without the required shape being clear in the "
"signature, the user must hunt in the docstring or the code in question to"
" determine what the input/output shape requirements are."
msgstr ""

#: ../../pep-0646.rst:59
msgid ""
"**Catching shape bugs before runtime**. Ideally, use of incorrect shapes "
"should be an error we can catch ahead of time using static analysis. "
"(This is particularly important for machine learning code, where "
"iteration times can be slow.)"
msgstr ""

#: ../../pep-0646.rst:63
msgid ""
"**Preventing subtle shape bugs**. In the worst case, use of the wrong "
"shape will result in the program appearing to run fine, but with a subtle"
" bug that can take days to track down. (See `this exercise`_ in a popular"
" machine learning tutorial for a particularly pernicious example.)"
msgstr ""

#: ../../pep-0646.rst:68
msgid ""
"Ideally, we should have some way of making shape requirements explicit in"
" type signatures. Multiple proposals [#numeric-stack]_ [#typing-ideas]_ "
"[#syntax-proposal]_ have suggested the use of the standard generics "
"syntax for this purpose. We would write:"
msgstr ""

#: ../../pep-0646.rst:77
msgid ""
"However, note that arrays can be of arbitrary rank - ``Array`` as used "
"above is generic in an arbitrary number of axes. One way around this "
"would be to use a different ``Array`` class for each rank..."
msgstr ""

#: ../../pep-0646.rst:90
msgid ""
"...but this would be cumbersome, both for users (who would have to "
"sprinkle 1s and 2s and so on throughout their code) and for the authors "
"of array libraries (who would have to duplicate implementations "
"throughout multiple classes)."
msgstr ""

#: ../../pep-0646.rst:93
msgid ""
"Variadic generics are necessary for an ``Array`` that is generic in an "
"arbitrary number of axes to be cleanly defined as a single class."
msgstr ""

#: ../../pep-0646.rst:97
msgid "Summary Examples"
msgstr ""

#: ../../pep-0646.rst:99
msgid ""
"Cutting right to the chase, this PEP allows an ``Array`` class that is "
"generic in its shape (and datatype) to be defined using a newly-"
"introduced arbitrary-length type variable, ``TypeVarTuple``, as follows:"
msgstr ""

#: ../../pep-0646.rst:116
msgid ""
"Such an ``Array`` can be used to support a number of different kinds of "
"shape annotations. For example, we can add labels describing the semantic"
" meaning of each axis:"
msgstr ""

#: ../../pep-0646.rst:129
msgid "We could also add annotations describing the actual size of each axis:"
msgstr ""

#: ../../pep-0646.rst:138
msgid ""
"For consistency, we use semantic axis annotations as the basis of the "
"examples in this PEP, but this PEP is agnostic about which of these two "
"(or possibly other) ways of using ``Array`` is preferable; that decision "
"is left to library authors."
msgstr ""

#: ../../pep-0646.rst:142
msgid ""
"(Note also that for the rest of this PEP, for conciseness of example, we "
"use a simpler version of ``Array`` which is generic only in the shape - "
"*not* the data type.)"
msgstr ""

#: ../../pep-0646.rst:147
msgid "Specification"
msgstr ""

#: ../../pep-0646.rst:149
msgid ""
"In order to support the above use cases, we introduce ``TypeVarTuple``. "
"This serves as a placeholder not for a single type but for an *arbitrary*"
" number of types, and behaving like a number of ``TypeVar`` instances "
"packed in a ``Tuple``."
msgstr ""

#: ../../pep-0646.rst:151
msgid ""
"In addition, we introduce a new use for the star operator: to 'unpack' "
"``TypeVarTuple`` instances, in order to access the type variables "
"contained in the tuple."
msgstr ""

#: ../../pep-0646.rst:156
msgid "Type Variable Tuples"
msgstr ""

#: ../../pep-0646.rst:158
msgid ""
"In the same way that a normal type variable is a stand-in for a single "
"type, a type variable *tuple* is a stand-in for an arbitrary number of "
"types (zero or more) in a flat ordered list."
msgstr ""

#: ../../pep-0646.rst:162
msgid "Type variable tuples are created with:"
msgstr ""

#: ../../pep-0646.rst:170
msgid ""
"Type variable tuples behave like a number of individual type variables "
"packed in a ``Tuple``. To understand this, consider the following "
"example:"
msgstr ""

#: ../../pep-0646.rst:183
msgid ""
"The ``Shape`` type variable tuple here behaves like ``Tuple[T1, T2]``, "
"where ``T1`` and ``T2`` are type variables. To use these type variables "
"as type parameters of ``Array``, we must *unpack* the type variable tuple"
" using the star operator: ``*Shape``. The signature of ``Array`` then "
"behaves as if we had simply written ``class Array(Generic[T1, T2]): "
"...``."
msgstr ""

#: ../../pep-0646.rst:189
msgid ""
"In contrast to ``Generic[T1, T2]``, however, ``Generic[*Shape]`` allows "
"us to parameterise the class with an *arbitrary* number of type "
"parameters. That is, in addition to being able to define rank-2 arrays "
"such as ``Array[Height, Width]``, we could also define rank-3 arrays, "
"rank-4 arrays, and so on:"
msgstr ""

#: ../../pep-0646.rst:202
msgid ""
"Type variable tuples can be used anywhere a normal ``TypeVar`` can. This "
"includes class definitions, as shown above, as well as function "
"signatures and variable annotations:"
msgstr ""

#: ../../pep-0646.rst:222
msgid "Type Variable Tuples Must Always be Unpacked"
msgstr ""

#: ../../pep-0646.rst:224
msgid ""
"Note that in the previous example, the ``shape`` argument to ``__init__``"
" was annotated as ``Tuple[*Shape]``. Why is this necessary - if ``Shape``"
" behaves like ``Tuple[T1, T2, ...]``, couldn't we have annotated the "
"``shape`` argument as ``Shape`` directly?"
msgstr ""

#: ../../pep-0646.rst:229
msgid ""
"This is, in fact, deliberately not possible: type variable tuples must "
"*always* be used unpacked (that is, prefixed by the star operator). This "
"is for two reasons:"
msgstr ""

#: ../../pep-0646.rst:233
msgid ""
"To avoid potential confusion about whether to use a type variable tuple "
"in a packed or unpacked form (\"Hmm, should I write '``-> Shape``', or "
"'``-> Tuple[Shape]``', or '``-> Tuple[*Shape]``'...?\")"
msgstr ""

#: ../../pep-0646.rst:236
msgid ""
"To improve readability: the star also functions as an explicit visual "
"indicator that the type variable tuple is not a normal type variable."
msgstr ""

#: ../../pep-0646.rst:240
msgid "``Unpack`` for Backwards Compatibility"
msgstr ""

#: ../../pep-0646.rst:242
msgid ""
"Note that the use of the star operator in this context requires a grammar"
" change, and is therefore available only in new versions of Python. To "
"enable use of type variable tuples in older versions of Python, we "
"introduce the ``Unpack`` type operator that can be used in place of the "
"star operator:"
msgstr ""

#: ../../pep-0646.rst:256
msgid "Variance, Type Constraints and Type Bounds: Not (Yet) Supported"
msgstr ""

#: ../../pep-0646.rst:258
msgid ""
"To keep this PEP minimal, ``TypeVarTuple`` does not yet support "
"specification of:"
msgstr ""

#: ../../pep-0646.rst:260
msgid "Variance (e.g. ``TypeVar('T', covariant=True)``)"
msgstr ""

#: ../../pep-0646.rst:261
msgid "Type constraints (``TypeVar('T', int, float)``)"
msgstr ""

#: ../../pep-0646.rst:262
msgid "Type bounds (``TypeVar('T', bound=ParentClass)``)"
msgstr ""

#: ../../pep-0646.rst:264
msgid ""
"We leave the decision of how these arguments should behave to a future "
"PEP, when variadic generics have been tested in the field. As of this "
"PEP, type variable tuples are invariant."
msgstr ""

#: ../../pep-0646.rst:268 ../../pep-0646.rst:658
msgid "Behaviour when Type Parameters are not Specified"
msgstr ""

#: ../../pep-0646.rst:270
msgid ""
"When a generic class parameterised by a type variable tuple is used "
"without any type parameters, it behaves as if its type parameters are "
"'``Any, ...``' (an arbitrary number of ``Any``):"
msgstr ""

#: ../../pep-0646.rst:283
msgid ""
"This enables gradual typing: existing functions accepting, for example, a"
" plain TensorFlow ``Tensor`` will still be valid even if ``Tensor`` is "
"made generic and calling code passes a ``Tensor[Height, Width]``."
msgstr ""

#: ../../pep-0646.rst:287
msgid "This also works in the opposite direction:"
msgstr ""

#: ../../pep-0646.rst:296
msgid ""
"This way, even if libraries are updated to use types like ``Array[Height,"
" Width]``, users of those libraries won't be forced to also apply type "
"annotations to all of their code; users still have a choice about what "
"parts of their code to type and which parts to not."
msgstr ""

#: ../../pep-0646.rst:302
msgid "Type Variable Tuples Must Have Known Length"
msgstr ""

#: ../../pep-0646.rst:304
msgid ""
"Type variables tuples may not be bound to a type with unknown length. "
"That is:"
msgstr ""

#: ../../pep-0646.rst:314
msgid ""
"If this is confusing - didn't we say that type variable tuples are a "
"stand-in for an *arbitrary* number of types? - note the difference "
"between the length of the type variable tuple *itself*, and the length of"
" the type it is *bound* to. Type variable tuples themselves can be of "
"arbitrary length - that is, they can be bound to ``Tuple[int]``, "
"``Tuple[int, int]``, and so on - but the types they are bound to must be "
"of known length - that is, ``Tuple[int, int]``, but not ``Tuple[int, "
"...]``."
msgstr ""

#: ../../pep-0646.rst:322
msgid ""
"Note that, as a result of this rule, omitting the type parameter list is "
"the *only* way of instantiating a generic type with an arbitrary number "
"of type parameters. (We plan to introduce a more deliberate syntax for "
"this case in a future PEP.) For example, an unparameterised ``Array`` may"
" *behave* like ``Array[Any, ...]``, but it cannot be instantiated using "
"``Array[Any, ...]``, because this would bind its type variable tuple to "
"``Tuple[Any, ...]``:"
msgstr ""

#: ../../pep-0646.rst:336
msgid "Type Variable Tuple Equality"
msgstr ""

#: ../../pep-0646.rst:338
msgid ""
"If the same ``TypeVarTuple`` instance is used in multiple places in a "
"signature or class, a valid type inference might be to bind the "
"``TypeVarTuple`` to a ``Tuple`` of a ``Union`` of types:"
msgstr ""

#: ../../pep-0646.rst:350
msgid ""
"We do *not* allow this; type unions may *not* appear within the "
"``Tuple``. If a type variable tuple appears in multiple places in a "
"signature, the types must match exactly (the list of type parameters must"
" be the same length, and the type parameters themselves must be "
"identical):"
msgstr ""

#: ../../pep-0646.rst:370
msgid "Multiple Type Variable Tuples: Not Allowed"
msgstr ""

#: ../../pep-0646.rst:372
msgid ""
"As of this PEP, only a single type variable tuple may appear in a type "
"parameter list:"
msgstr ""

#: ../../pep-0646.rst:379
msgid "Type Concatenation"
msgstr ""

#: ../../pep-0646.rst:381
msgid ""
"Type variable tuples don't have to be alone; normal types can be prefixed"
" and/or suffixed:"
msgstr ""

#: ../../pep-0646.rst:402
msgid "Normal ``TypeVar`` instances can also be prefixed and/or suffixed:"
msgstr ""

#: ../../pep-0646.rst:418
msgid "``*args`` as a Type Variable Tuple"
msgstr ""

#: ../../pep-0646.rst:420
msgid ""
"PEP 484 states that when a type annotation is provided for ``*args``, "
"every argument must be of the type annotated. That is, if we specify "
"``*args`` to be type ``int``, then *all* arguments must be of type "
"``int``. This limits our ability to specify the type signatures of "
"functions that take heterogeneous argument types."
msgstr ""

#: ../../pep-0646.rst:425
msgid ""
"If ``*args`` is annotated as a type variable tuple, however, the types of"
" the individual arguments become the types in the type variable tuple:"
msgstr ""

#: ../../pep-0646.rst:436
msgid ""
"If no arguments are passed, the type variable tuple behaves like an empty"
" tuple, ``Tuple[()]``."
msgstr ""

#: ../../pep-0646.rst:439
msgid ""
"Note that, in keeping with the rule that type variable tuples must always"
" be used unpacked, annotating ``*args`` as being a plain type variable "
"tuple instance is *not* allowed:"
msgstr ""

#: ../../pep-0646.rst:447
msgid ""
"``*args`` is the only case where an argument can be annotated as ``*Ts`` "
"directly; other arguments should use ``*Ts`` to parameterise something "
"else, e.g. ``Tuple[*Ts]``. If ``*args`` itself is annotated as "
"``Tuple[*Ts]``, the old behaviour still applies: all arguments must be a "
"``Tuple`` parameterised with the same types."
msgstr ""

#: ../../pep-0646.rst:460
msgid ""
"Following `Type Variable Tuples Must Have Known Length`_, note that the "
"following should *not* type-check as valid (even though it is, of course,"
" valid at runtime):"
msgstr ""

#: ../../pep-0646.rst:471
msgid ""
"Finally, note that a type variable tuple may *not* be used as the type of"
" ``**kwargs``. (We do not yet know of a use case for this feature, so we "
"prefer to leave the ground fresh for a potential future PEP.)"
msgstr ""

#: ../../pep-0646.rst:481
msgid "Type Variable Tuples with ``Callable``"
msgstr ""

#: ../../pep-0646.rst:483
msgid ""
"Type variable tuples can also be used in the arguments section of a "
"``Callable``:"
msgstr ""

#: ../../pep-0646.rst:500
msgid ""
"Other types and normal type variables can also be prefixed/suffixed to "
"the type variable tuple:"
msgstr ""

#: ../../pep-0646.rst:510
msgid "Aliases"
msgstr ""

#: ../../pep-0646.rst:512
msgid ""
"Generic aliases can be created using a type variable tuple in a similar "
"way to regular type variables:"
msgstr ""

#: ../../pep-0646.rst:523
msgid ""
"As this example shows, all type parameters passed to the alias are bound "
"to the type variable tuple."
msgstr ""

#: ../../pep-0646.rst:526
msgid ""
"Importantly for our original ``Array`` example (see `Summary Examples`_),"
" this allows us to define convenience aliases for arrays of a fixed shape"
" or datatype:"
msgstr ""

#: ../../pep-0646.rst:542
msgid ""
"If an explicitly empty type parameter list is given, the type variable "
"tuple in the alias is set empty:"
msgstr ""

#: ../../pep-0646.rst:550
msgid ""
"If the type parameter list is omitted entirely, the alias is compatible "
"with arbitrary type parameters:"
msgstr ""

#: ../../pep-0646.rst:565
msgid "Normal ``TypeVar`` instances can also be used in such aliases:"
msgstr ""

#: ../../pep-0646.rst:580
msgid "Overloads for Accessing Individual Types"
msgstr ""

#: ../../pep-0646.rst:582
msgid ""
"For situations where we require access to each individual type in the "
"type variable tuple, overloads can be used with individual ``TypeVar`` "
"instances in place of the type variable tuple:"
msgstr ""

#: ../../pep-0646.rst:604
msgid ""
"(For array shape operations in particular, having to specify overloads "
"for each possible rank is, of course, a rather cumbersome solution. "
"However, it's the best we can do without additional type manipulation "
"mechanisms. We plan to introduce these in a future PEP.)"
msgstr ""

#: ../../pep-0646.rst:611
msgid "Rationale and Rejected Ideas"
msgstr ""

#: ../../pep-0646.rst:614
msgid "Shape Arithmetic"
msgstr ""

#: ../../pep-0646.rst:616
msgid ""
"Considering the use case of array shapes in particular, note that as of "
"this PEP, it is not yet possible to describe arithmetic transformations "
"of array dimensions - for example, ``def repeat_each_element(x: Array[N])"
" -> Array[2*N]``. We consider this out-of-scope for the current PEP, but "
"plan to propose additional mechanisms that *will* enable this in a future"
" PEP."
msgstr ""

#: ../../pep-0646.rst:624
msgid "Supporting Variadicity Through Aliases"
msgstr ""

#: ../../pep-0646.rst:626
msgid ""
"As noted in the introduction, it *is* possible to avoid variadic generics"
" by simply defining aliases for each possible number of type parameters:"
msgstr ""

#: ../../pep-0646.rst:634
msgid ""
"However, this seems somewhat clumsy - it requires users to unnecessarily "
"pepper their code with 1s, 2s, and so on for each rank necessary."
msgstr ""

#: ../../pep-0646.rst:638
msgid "Construction of ``TypeVarTuple``"
msgstr ""

#: ../../pep-0646.rst:640
msgid ""
"``TypeVarTuple`` began as ``ListVariadic``, based on its naming in an "
"early implementation in Pyre."
msgstr ""

#: ../../pep-0646.rst:643
msgid ""
"We then changed this to ``TypeVar(list=True)``, on the basis that a) it "
"better emphasises the similarity to ``TypeVar``, and b) the meaning of "
"'list' is more easily understood than the jargon of 'variadic'."
msgstr ""

#: ../../pep-0646.rst:647
msgid ""
"Once we'd decided that a variadic type variable should behave like a "
"``Tuple``, we also considered ``TypeVar(bound=Tuple)``, which is "
"similarly intuitive and accomplishes most what we wanted without "
"requiring any new arguments to ``TypeVar``. However, we realised this may"
" constrain us in the future, if for example we want type bounds or "
"variance to function slightly differently for variadic type variables "
"than what the semantics of ``TypeVar`` might otherwise imply. Also, we "
"may later wish to support arguments that should not be supported by "
"regular type variables (such as ``arbitrary_len`` [#arbitrary_len]_)."
msgstr ""

#: ../../pep-0646.rst:655
msgid "We therefore settled on ``TypeVarTuple``."
msgstr ""

#: ../../pep-0646.rst:660
msgid ""
"In order to support gradual typing, this PEP states that *both* of the "
"following examples should type-check correctly:"
msgstr ""

#: ../../pep-0646.rst:673
msgid ""
"Note that this is in contrast to the behaviour of the only currently-"
"existing variadic type in Python, ``Tuple``:"
msgstr ""

#: ../../pep-0646.rst:686
msgid ""
"The rules for ``Tuple`` were deliberately chosen such that the latter "
"case is an error: it was thought to be more likely that the programmer "
"has made a mistake than that the function expects a specific kind of "
"``Tuple`` but the specific kind of ``Tuple`` passed is unknown to the "
"type checker. Additionally, ``Tuple`` is something of a special case, in "
"that it is used to represent immutable sequences. That is, if an object's"
" type is inferred to be an unparameterised ``Tuple``, it is not "
"necessarily because of incomplete typing."
msgstr ""

#: ../../pep-0646.rst:694
msgid ""
"In contrast, if an object's type is inferred to be an unparameterised "
"``Array``, it is much more likely that the user has simply not yet fully "
"annotated their code, or that the signature of a shape-manipulating "
"library function cannot yet be expressed using the typing system and "
"therefore returning a plain ``Array`` is the only option. We rarely deal "
"with arrays of truly arbitrary shape; in certain cases, *some* parts of "
"the shape will be arbitrary - for example, when dealing with sequences, "
"the first two parts of the shape are often 'batch' and 'time' - but we "
"plan to support these cases explicitly in a future PEP with a syntax such"
" as ``Array[Batch, Time, ...]``."
msgstr ""

#: ../../pep-0646.rst:704
msgid ""
"We therefore made the decision to have variadic generics *other* than "
"``Tuple`` behave differently, in order to give the user more flexibility "
"in how much of their code they wish to annotate, and to enable "
"compatibility between old unannotated code and new versions of libraries "
"which do use these type annotations."
msgstr ""

#: ../../pep-0646.rst:712
msgid "Alternatives"
msgstr ""

#: ../../pep-0646.rst:714
msgid ""
"It should be noted that the approach outlined in this PEP to solve the "
"issue of shape checking in numerical libraries is *not* the only approach"
" possible. Examples of lighter-weight alternatives based on *runtime* "
"checking include ShapeGuard [#shapeguard]_, tsanley [#tsanley]_, and "
"PyContracts [#pycontracts]_."
msgstr ""

#: ../../pep-0646.rst:719
msgid ""
"While these existing approaches improve significantly on the default "
"situation of shape checking only being possible through lengthy and "
"verbose assert statements, none of them enable *static* analysis of shape"
" correctness. As mentioned in `Motivation`_, this is particularly "
"desirable for machine learning applications where, due to library and "
"infrastructure complexity, even relatively simple programs must suffer "
"long startup times; iterating by running the program until it crashes, as"
" is necessary with these existing runtime-based approaches, can be a "
"tedious and frustrating experience."
msgstr ""

#: ../../pep-0646.rst:729
msgid ""
"Our hope with this PEP is to begin to codify generic type annotations as "
"an official, language-supported way of dealing with shape correctness. "
"With something of a standard in place, in the long run, this will "
"hopefully enable a thriving ecosystem of tools for analysing and "
"verifying shape properties of numerical computing programs."
msgstr ""

#: ../../pep-0646.rst:737
msgid "Grammar Changes"
msgstr ""

#: ../../pep-0646.rst:739
msgid ""
"This PEP requires two grammar changes. Full diffs of ``python.gram`` and "
"simple tests to confirm correct behaviour are available at "
"https://github.com/mrahtz/cpython/commits/pep646-grammar."
msgstr ""

#: ../../pep-0646.rst:744
msgid "Change 1: Star Expressions in Indexes"
msgstr ""

#: ../../pep-0646.rst:746
msgid ""
"The first grammar change enables use of star expressions in index "
"operations (that is, within square brackets), necessary to support star-"
"unpacking of TypeVarTuples:"
msgstr ""

#: ../../pep-0646.rst:756 ../../pep-0646.rst:852
msgid "Before:"
msgstr ""

#: ../../pep-0646.rst:764 ../../pep-0646.rst:861
msgid "After:"
msgstr ""

#: ../../pep-0646.rst:772
msgid ""
"As with star-unpacking in other contexts, the star operator calls "
"``__iter__`` on the callee, and adds the contents of the resulting "
"iterator to the argument passed to ``__getitem__``. For example, if we do"
" ``foo[a, *b, c]``, and ``b.__iter__`` produces an iterator yielding "
"``d`` and ``e``, ``foo.__getitem__`` would receive ``(a, d, e, c)``."
msgstr ""

#: ../../pep-0646.rst:778
msgid ""
"To put it another way, note that ``x[..., *a, ...]`` produces the same "
"result as ``x[(..., a*, ...)]``` (with any slices ``i:j`` in ``...`` "
"replaced with ``slice(i, j)``, with the one edge case that ``x[*a]`` "
"becomes ``x[(*a,)]``)."
msgstr ""

#: ../../pep-0646.rst:783
msgid "TypeVarTuple Implementation"
msgstr ""

#: ../../pep-0646.rst:785
msgid ""
"With this grammar change, ``TypeVarTuple`` is implemented as follows. "
"Note that this implementation is useful only for the benefit of a) "
"correct ``repr()`` and b) runtime analysers; static analysers would not "
"use the implementation."
msgstr ""

#: ../../pep-0646.rst:808 ../../pep-0646.rst:908
msgid "Implications"
msgstr ""

#: ../../pep-0646.rst:810
msgid ""
"This grammar change implies a number of additional changes in behaviour "
"not required by this PEP. We choose to allow these additional changes "
"rather than disallowing them at a syntax level in order to keep the "
"syntax change as small as possible."
msgstr ""

#: ../../pep-0646.rst:815
msgid ""
"First, the grammar change enables star-unpacking of other structures, "
"such as lists, within indexing operations:"
msgstr ""

#: ../../pep-0646.rst:823
msgid "Second, more than one instance of a star-unpack can occur within an index:"
msgstr ""

#: ../../pep-0646.rst:829
msgid ""
"Note that this PEP disallows multiple unpacked TypeVarTuples within a "
"single type parameter list. This requirement would therefore need to be "
"implemented in type checking tools themselves rather than at the syntax "
"level."
msgstr ""

#: ../../pep-0646.rst:833
msgid "Third, slices may co-occur with starred expressions:"
msgstr ""

#: ../../pep-0646.rst:839
msgid "However, note that slices involving starred expressions are still invalid:"
msgstr ""

#: ../../pep-0646.rst:848
msgid "Change 2: ``*args`` as a TypeVarTuple"
msgstr ""

#: ../../pep-0646.rst:850
msgid "The second change enables use of ``*args: *Ts`` in function definitions."
msgstr ""

#: ../../pep-0646.rst:871
msgid "Where:"
msgstr ""

#: ../../pep-0646.rst:883
msgid ""
"This accomplishes the desired outcome (making ``*args: *Ts`` not be a "
"syntax error) while matching the behaviour of star-unpacking in other "
"contexts: at runtime, ``__iter__`` is called on the starred object, and a"
" tuple containing the items of the resulting iterator is set as the type "
"annotion for ``args``. In other words, at runtime ``*args: *foo`` is "
"equivalent to ``*args: tuple(foo)``."
msgstr ""

#: ../../pep-0646.rst:898
msgid ""
"Note that the only scenario in which this grammar change allows ``*Ts`` "
"to be used as a direct annotation (rather than being wrapped in e.g. "
"``Tuple[*Ts]``) is ``*args``. Other uses are still invalid:"
msgstr ""

#: ../../pep-0646.rst:910
msgid ""
"As with the first grammar change, this change also has a number of side "
"effects. In particular, the annotation of ``*args`` could be set to a "
"starred object other than a ``TypeVarTuple`` - for example, the following"
" nonsensical annotation is possible:"
msgstr ""

#: ../../pep-0646.rst:922
msgid ""
"Again, prevention of such annotations will need to be done by, say, "
"static checkers, rather than at the level of syntax."
msgstr ""

#: ../../pep-0646.rst:926
msgid "Alternatives (Why Not Just Use ``Unpack``?)"
msgstr ""

#: ../../pep-0646.rst:928
msgid ""
"If these grammar changes are considered too burdensome, there are two "
"alternatives."
msgstr ""

#: ../../pep-0646.rst:931
msgid ""
"The first would be to **support change 1 but not change 2**. Variadic "
"generics are more important to us than the ability to annotate ``*args``."
msgstr ""

#: ../../pep-0646.rst:934
msgid ""
"The second alternative would be to **use ``Unpack`` instead**, requiring "
"no grammar changes. However, we regard this as a suboptimal solution for "
"two reasons:"
msgstr ""

#: ../../pep-0646.rst:938
msgid ""
"**Readability**. ``class Array(Generic[DType, Unpack[Shape]])`` is a bit "
"of a mouthful; the flow of reading is interrupted by length of ``Unpack``"
" and the extra set of square brackets. ``class Array(Generic[DType, "
"*Shape])`` is much easier to skim, while still marking ``Shape`` as "
"special."
msgstr ""

#: ../../pep-0646.rst:942
msgid ""
"**Intuitiveness**. We think a user is more likely to intuitively "
"understand the meaning of ``*Ts`` - especially when they see that ``Ts`` "
"is a TypeVar**Tuple** - than the meaning of ``Unpack[Ts]``. (This assumes"
" the user is familiar with star-unpacking in other contexts; if the user "
"is reading or writing code that uses variadic generics, this seems "
"reasonable.)"
msgstr ""

#: ../../pep-0646.rst:949
msgid ""
"If even change 1 is thought too significant a change, therefore, it might"
" be better for us to reconsider our options before going ahead with this "
"second alternative."
msgstr ""

#: ../../pep-0646.rst:954
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0646.rst:956
msgid ""
"The ``Unpack`` version of the PEP should be back-portable to previous "
"versions of Python."
msgstr ""

#: ../../pep-0646.rst:959
msgid ""
"Gradual typing is enabled by the fact that unparameterised variadic "
"classes are compatible with an arbitrary number of type parameters. This "
"means that if existing classes are made generic, a) all existing "
"(unparameterised) uses of the class will still work, and b) parameterised"
" and unparameterised versions of the class can be used together (relevant"
" if, for example, library code is updated to use parameters while user "
"code is not, or vice-versa)."
msgstr ""

#: ../../pep-0646.rst:967
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0646.rst:969
msgid ""
"Two reference implementations of type-checking functionality exist: one "
"in Pyre, as of v0.9.0, and one in Pyright, as of v1.1.108."
msgstr ""

#: ../../pep-0646.rst:972
msgid ""
"A preliminary implementation of the ``Unpack`` version of the PEP in "
"CPython is available in `cpython/23527`_. A preliminary version of the "
"version using the star operator, based on an early implementation of PEP "
"637, is also available at `mrahtz/cpython/pep637+646`_."
msgstr ""

#: ../../pep-0646.rst:978
msgid "Appendix A: Shape Typing Use Cases"
msgstr ""

#: ../../pep-0646.rst:980
msgid ""
"To give this PEP additional context for those particularly interested in "
"the array typing use case, in this appendix we expand on the different "
"ways this PEP can be used for specifying shape-based subtypes."
msgstr ""

#: ../../pep-0646.rst:985
msgid "Use Case 1: Specifying Shape Values"
msgstr ""

#: ../../pep-0646.rst:987
msgid ""
"The simplest way to parameterise array types is using ``Literal`` type "
"parameters - e.g. ``Array[Literal[64], Literal[64]]``."
msgstr ""

#: ../../pep-0646.rst:990
msgid "We can attach names to each parameter using normal type variables:"
msgstr ""

#: ../../pep-0646.rst:1004
msgid ""
"Note that such names have a purely local scope. That is, the name ``K`` "
"is bound to ``Literal[64]`` only within ``matrix_vector_multiply``. To "
"put it another way, there's no relationship between the value of ``K`` in"
" different signatures. This is important: it would be inconvenient if "
"every axis named ``K`` were constrained to have the same value throughout"
" the entire program."
msgstr ""

#: ../../pep-0646.rst:1010
msgid ""
"The disadvantage of this approach is that we have no ability to enforce "
"shape semantics across different calls. For example, we can't address the"
" problem mentioned in `Motivation`_: if one function returns an array "
"with leading dimensions 'Time × Batch', and another function takes the "
"same array assuming leading dimensions 'Batch × Time', we have no way of "
"detecting this."
msgstr ""

#: ../../pep-0646.rst:1015
msgid ""
"The main advantage is that in some cases, axis sizes really are what we "
"care about. This is true for both simple linear algebra operations such "
"as the matrix manipulations above, but also in more complicated "
"transformations such as convolutional layers in neural networks, where it"
" would be of great utility to the programmer to be able to inspect the "
"array size after each layer using static analysis. To aid this, in the "
"future we would like to explore possibilities for additional type "
"operators that enable arithmetic on array shapes - for example:"
msgstr ""

#: ../../pep-0646.rst:1026
msgid ""
"Such arithmetic type operators would only make sense if names such as "
"``N`` refer to axis size."
msgstr ""

#: ../../pep-0646.rst:1029
msgid "Use Case 2: Specifying Shape Semantics"
msgstr ""

#: ../../pep-0646.rst:1031
msgid ""
"A second approach (the one that most of the examples in this PEP are "
"based around) is to forgo annotation with actual axis size, and instead "
"annotate axis *type*."
msgstr ""

#: ../../pep-0646.rst:1034
msgid ""
"This would enable us to solve the problem of enforcing shape properties "
"across calls. For example:"
msgstr ""

#: ../../pep-0646.rst:1054
msgid ""
"Note that in this case, names are *global* (to the extent that we use the"
" same ``Batch`` type in different place). However, because names refer "
"only to axis *types*, this doesn't constrain the *value* of certain axes "
"to be the same through (that is, this doesn't constrain all axes named "
"``Height`` to have a value of, say, 480 throughout)."
msgstr ""

#: ../../pep-0646.rst:1060
msgid ""
"The argument *for* this approach is that in many cases, axis *type* is "
"the more important thing to verify; we care more about which axis is "
"which than what the specific size of each axis is."
msgstr ""

#: ../../pep-0646.rst:1064
msgid ""
"It also does not preclude cases where we wish to describe shape "
"transformations without knowing the type ahead of time. For example, we "
"can still write:"
msgstr ""

#: ../../pep-0646.rst:1074
msgid "We can then use this with:"
msgstr ""

#: ../../pep-0646.rst:1076
msgid "class Batch: pass class Values: pass"
msgstr ""

#: ../../pep-0646.rst:1079
msgid ""
"batch_of_values: Array[Batch, Values] value_weights: Array[Values] "
"matrix_vector_multiply(batch_of_values, value_weights) # Result is "
"Array[Batch]"
msgstr ""

#: ../../pep-0646.rst:1084
msgid ""
"The disadvantages are the inverse of the advantages from use case 1. In "
"particular, this approach does not lend itself well to arithmetic on axis"
" types: ``Mul[2, Batch]`` would be as meaningless as ``2 * int``."
msgstr ""

#: ../../pep-0646.rst:1089
msgid "Discussion"
msgstr ""

#: ../../pep-0646.rst:1091
msgid ""
"Note that use cases 1 and 2 are mutually exclusive in user code. Users "
"can verify size or semantic type but not both."
msgstr ""

#: ../../pep-0646.rst:1094
msgid ""
"As of this PEP, we are agnostic about which approach will provide most "
"benefit. Since the features introduced in this PEP are compatible with "
"both approaches, however, we leave the door open."
msgstr ""

#: ../../pep-0646.rst:1099
msgid "Why Not Both?"
msgstr ""

#: ../../pep-0646.rst:1101
msgid "Consider the following 'normal' code:"
msgstr ""

#: ../../pep-0646.rst:1107
msgid ""
"Note that we have symbols for both the value of the thing (``x``) and the"
" type of the thing (``int``). Why can't we do the same with axes? For "
"example, with an imaginary syntax, we could write:"
msgstr ""

#: ../../pep-0646.rst:1115
msgid ""
"This would allow us to access the axis size (say, 32) through the symbol "
"``TimeValue`` *and* the type through the symbol ``TypeType``."
msgstr ""

#: ../../pep-0646.rst:1118
msgid ""
"This might even be possible using existing syntax, through a second level"
" of parameterisation:"
msgstr ""

#: ../../pep-0646.rst:1124
msgid "However, we leave exploration of this approach to the future."
msgstr ""

#: ../../pep-0646.rst:1127
msgid "Appendix B: Shaped Types vs Named Axes"
msgstr ""

#: ../../pep-0646.rst:1129
msgid ""
"An issue related to those addressed by this PEP concerns axis "
"*selection*. For example, if we have an image stored in an array of shape"
" 64×64x3, we might wish to convert to black-and-white by computing the "
"mean over the third axis, ``mean(image, axis=2)``. Unfortunately, the "
"simple typo ``axis=1`` is difficult to spot and will produce a result "
"that means something completely different (all while likely allowing the "
"program to keep on running, resulting in a bug that is serious but "
"silent)."
msgstr ""

#: ../../pep-0646.rst:1137
msgid ""
"In response, some libraries have implemented so-called 'named tensors' "
"(in this context, 'tensor' is synonymous with 'array'), in which axes are"
" selected not by index but by label - e.g. ``mean(image, "
"axis='channels')``."
msgstr ""

#: ../../pep-0646.rst:1141
msgid ""
"A question we are often asked about this PEP is: why not just use named "
"tensors? The answer is that we consider the named tensors approach "
"insufficient, for two main reasons:"
msgstr ""

#: ../../pep-0646.rst:1144
msgid ""
"**Static checking** of shape correctness is not possible. As mentioned in"
" `Motivation`_, this is a highly desirable feature in machine learning "
"code where iteration times are slow by default."
msgstr ""

#: ../../pep-0646.rst:1147
msgid ""
"**Interface documentation** is still not possible with this approach. If "
"a function should *only* be willing to take array arguments that have "
"image-like shapes, this cannot be stipulated with named tensors."
msgstr ""

#: ../../pep-0646.rst:1151
msgid ""
"Additionally, there's the issue of **poor uptake**. At the time of "
"writing, named tensors have only been implemented in a small number of "
"numerical computing libraries. Possible explanations for this include "
"difficulty of implementation (the whole API must be modified to allow "
"selection by axis name instead of index), and lack of usefulness due to "
"the fact that axis ordering conventions are often strong enough that axis"
" names provide little benefit (e.g. when working with images, 3D tensors "
"are basically *always* height × width × channels). However, ultimately we"
" are still uncertain why this is the case."
msgstr ""

#: ../../pep-0646.rst:1159
msgid ""
"Can the named tensors approach be combined with the approach we advocate "
"for in this PEP? We're not sure. One area of overlap is that in some "
"contexts, we could do, say:"
msgstr ""

#: ../../pep-0646.rst:1168
msgid ""
"Ideally, we might write something like ``im: Array[Height=64, Width=64, "
"Channels=3]`` - but this won't be possible in the short term, due to the "
"rejection of PEP 637. In any case, our attitude towards this is mostly "
"\"Wait and see what happens before taking any further steps\"."
msgstr ""

#: ../../pep-0646.rst:1174
msgid "Footnotes"
msgstr ""

#: ../../pep-0646.rst:1176
msgid "'Batch' is machine learning parlance for 'a number of'."
msgstr ""

#: ../../pep-0646.rst:1178
msgid ""
"We use the term 'array' to refer to a matrix with an arbitrary number of "
"dimensions. In NumPy, the corresponding class is the ``ndarray``; in "
"TensorFlow, the ``Tensor``; and so on."
msgstr ""

#: ../../pep-0646.rst:1182
msgid ""
"If the shape begins with 'batch × time', then ``videos_batch[0][1]`` "
"would select the second frame of the first video. If the shape begins "
"with 'time × batch', then ``videos_batch[1][0]`` would select the same "
"frame."
msgstr ""

#: ../../pep-0646.rst:1188
msgid "Endorsements"
msgstr ""

#: ../../pep-0646.rst:1190
msgid ""
"Variadic generics have a wide range of uses. For the fraction of that "
"range involving numerical computing, how likely is it that relevant "
"libraries will actually make use of the features proposed in this PEP?"
msgstr ""

#: ../../pep-0646.rst:1194
msgid ""
"We reached out to a number of people with this question, and received the"
" following endorsements."
msgstr ""

#: ../../pep-0646.rst:1197
msgid ""
"From **Stephan Hoyer**, member of the NumPy Steering Council: [#stephan-"
"endorsement]_"
msgstr ""

#: ../../pep-0646.rst:1200
msgid ""
"I just wanted to thank Matthew & Pradeep for writing this PEP and for "
"clarifications to the broader context of PEP 646 for array typing in "
"https://github.com/python/peps/pull/1904."
msgstr ""

#: ../../pep-0646.rst:1204
msgid ""
"As someone who is heavily involved in the Python numerical computing "
"community (e.g., NumPy, JAX, Xarray), but who is not so familiar with the"
" details of Python's type system, it is reassuring to see that a broad "
"range of use-cases related to type checking of named axes & shapes have "
"been considered, and could build upon the infrastructure in this PEP."
msgstr ""

#: ../../pep-0646.rst:1210
msgid ""
"Type checking for shapes is something the NumPy community is very "
"interested in -- there are more thumbs up on the relevant issue on "
"NumPy's GitHub than any others "
"(https://github.com/numpy/numpy/issues/7370) and we recently added a "
"\"typing\" module that is under active development."
msgstr ""

#: ../../pep-0646.rst:1215
msgid ""
"It will certainly require experimentation to figure out the best ways to "
"use type checking for ndarrays, but this PEP looks like an excellent "
"foundation for such work."
msgstr ""

#: ../../pep-0646.rst:1219
msgid ""
"From **Bas van Beek**, who has worked on preliminary support for shape-"
"generics in NumPy:"
msgstr ""

#: ../../pep-0646.rst:1222
msgid ""
"I very much share Stephan's opinion here and look forward to integrating "
"the new PEP 646 variadics into numpy."
msgstr ""

#: ../../pep-0646.rst:1225
msgid ""
"In the context of numpy (and tensor typing general): the typing of array "
"shapes is a fairly complicated subject and the introduction of variadics "
"will likely play in big role in laying its foundation, as it allows for "
"the expression of both dimensioability as well as basic shape "
"manipulation."
msgstr ""

#: ../../pep-0646.rst:1230
msgid ""
"All in all, I'm very interested in where both PEP 646 and future PEPs "
"will take us and look forward to further developments."
msgstr ""

#: ../../pep-0646.rst:1233
msgid ""
"From **Dan Moldovan**, a Senior Software Engineer on the TensorFlow Dev "
"Team and author of the TensorFlow RFC, `TensorFlow Canonical Type "
"System`_: [#dan-endorsement]_"
msgstr ""

#: ../../pep-0646.rst:1236
msgid ""
"I'd be interested in using this the mechanisms defined in this PEP to "
"define rank-generic Tensor types in TensorFlow, which are important in "
"specifying ``tf.function`` signatures in a Pythonic way, using type "
"annotations (rather than the custom ``input_signature`` mechanism we have"
" today - see this issue: "
"https://github.com/tensorflow/tensorflow/issues/31579). Variadic generics"
" are among the last few missing pieces to create an elegant set of type "
"definitions for tensors and shapes."
msgstr ""

#: ../../pep-0646.rst:1244
msgid ""
"(For the sake of transparency - we also reached out to folks from a third"
" popular numerical computing library, PyTorch, but did *not* receive a "
"statement of endorsement from them. Our understanding is that although "
"they are interested in some of the same issues - e.g. static shape "
"inference - they are currently focusing on enabling this through a DSL "
"rather than the Python type system.)"
msgstr ""

#: ../../pep-0646.rst:1251
msgid "Acknowledgements"
msgstr ""

#: ../../pep-0646.rst:1253
msgid ""
"Thank you to **Alfonso Castaño**, **Antoine Pitrou**, **Bas v.B.**, "
"**David Foster**, **Dimitris Vardoulakis**, **Eric Traut**, **Guido van "
"Rossum**, **Jia Chen**, **Lucio Fernandez-Arjona**, **Nikita Sobolev**, "
"**Peilonrayz**, **Rebecca Chen**, **Sergei Lebedev**, and **Vladimir "
"Mikulik** for helpful feedback and suggestions on drafts of this PEP."
msgstr ""

#: ../../pep-0646.rst:1258
msgid ""
"Thank you especially to **Lucio** for suggesting the star syntax (which "
"has made multiple aspects of this proposal much more concise and "
"intuitive), and to **Stephan Hoyer** and **Dan Moldovan** for their "
"endorsements."
msgstr ""

#: ../../pep-0646.rst:1261
msgid "Resources"
msgstr ""

#: ../../pep-0646.rst:1263
msgid ""
"Discussions on variadic generics in Python started in 2016 with Issue 193"
" on the python/typing GitHub repository [#typing193]_."
msgstr ""

#: ../../pep-0646.rst:1266
msgid ""
"Inspired by this discussion, **Ivan Levkivskyi** made a concrete proposal"
" at PyCon 2019, summarised in notes on 'Type system improvements' [#type-"
"improvements]_ and 'Static typing of Python numeric stack' [#numeric-"
"stack]_."
msgstr ""

#: ../../pep-0646.rst:1270
msgid ""
"Expanding on these ideas, **Mark Mendoza** and **Vincent Siles** gave a "
"presentation on 'Variadic Type Variables for Decorators and Tensors' "
"[#variadic-type-variables]_ at the 2019 Python Typing Summit."
msgstr ""

#: ../../pep-0646.rst:1276
msgid "References"
msgstr ""

#: ../../pep-0646.rst:1278
msgid "Python typing issue #193: https://github.com/python/typing/issues/193"
msgstr ""

#: ../../pep-0646.rst:1281
msgid ""
"Ivan Levkivskyi, 'Type system improvements', PyCon 2019: "
"https://paper.dropbox.com/doc/Type-system-improvements-"
"HHOkniMG9WcCgS0LzXZAe"
msgstr ""

#: ../../pep-0646.rst:1284
msgid ""
"Ivan Levkivskyi, 'Static typing of Python numeric stack', PyCon 2019: "
"https://paper.dropbox.com/doc/Static-typing-of-Python-numeric-stack-"
"summary-6ZQzTkgN6e0oXko8fEWwN"
msgstr ""

#: ../../pep-0646.rst:1287
msgid ""
"Stephan Hoyer, 'Ideas for array shape typing in Python': "
"https://docs.google.com/document/d/1vpMse4c6DrWH5rq2tQSx3qwP_m_0lyn-"
"Ij4WHqQqRHY/edit"
msgstr ""

#: ../../pep-0646.rst:1290
msgid ""
"Mark Mendoza, 'Variadic Type Variables for Decorators and Tensors', "
"Python Typing Summit 2019: https://github.com/facebook/pyre-"
"check/blob/ae85c0c6e99e3bbfc92ec55104bfdc5b9b3097b2/docs/Variadic_Type_Variables_for_Decorators_and_Tensors.pdf"
msgstr ""

#: ../../pep-0646.rst:1293
msgid ""
"Matthew Rahtz et al., 'Shape annotation syntax proposal': "
"https://docs.google.com/document/d/1But-"
"hjet8-djv519HEKvBN6Ik2lW3yu0ojZo6pG9osY/edit"
msgstr ""

#: ../../pep-0646.rst:1296
msgid ""
"Discussion on Python typing-sig mailing list: "
"https://mail.python.org/archives/list/typing-"
"sig@python.org/thread/SQVTQYWIOI4TIO7NNBTFFWFMSMS2TA4J/"
msgstr ""

#: ../../pep-0646.rst:1299
msgid "tsanley: https://github.com/ofnote/tsanley"
msgstr ""

#: ../../pep-0646.rst:1301
msgid "PyContracts: https://github.com/AndreaCensi/contracts"
msgstr ""

#: ../../pep-0646.rst:1303
msgid "ShapeGuard: https://github.com/Qwlouse/shapeguard"
msgstr ""

#: ../../pep-0646.rst:1313
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/UDM7Y6HLHQBKXQEBIBD5ZLB5XNPDZDXV/"
msgstr ""

#: ../../pep-0646.rst:1315
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/HTCARTYYCHETAMHB6OVRNR5EW5T2CP4J/"
msgstr ""

#: ../../pep-0646.rst:1318
msgid "Copyright"
msgstr ""

#: ../../pep-0646.rst:1320
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

