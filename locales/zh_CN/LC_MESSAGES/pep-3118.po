# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-3118.txt
msgid "PEP"
msgstr ""

#: ../../pep-3118.txt:1
msgid "3118"
msgstr ""

#: ../../pep-3118.txt
msgid "Title"
msgstr ""

#: ../../pep-3118.txt:2
msgid "Revising the buffer protocol"
msgstr ""

#: ../../pep-3118.txt
msgid "Author"
msgstr ""

#: ../../pep-3118.txt:5
msgid ""
"Travis Oliphant <oliphant@ee.byu.edu>, Carl Banks "
"<pythondev@aerojockey.com>"
msgstr ""

#: ../../pep-3118.txt
msgid "Status"
msgstr ""

#: ../../pep-3118.txt:6
msgid "Final"
msgstr ""

#: ../../pep-3118.txt
msgid "Type"
msgstr ""

#: ../../pep-3118.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-3118.txt
msgid "Created"
msgstr ""

#: ../../pep-3118.txt:9
msgid "28-Aug-2006"
msgstr ""

#: ../../pep-3118.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-3118.txt:10
msgid "3.0"
msgstr ""

#: ../../pep-3118.txt
msgid "Post-History"
msgstr ""

#: ../../pep-3118.txt:14
msgid "Abstract"
msgstr ""

#: ../../pep-3118.txt:16
msgid ""
"This PEP proposes re-designing the buffer interface (``PyBufferProcs`` "
"function pointers) to improve the way Python allows memory sharing in "
"Python 3.0"
msgstr ""

#: ../../pep-3118.txt:20
msgid ""
"In particular, it is proposed that the character buffer portion of the "
"API be eliminated and the multiple-segment portion be re-designed in "
"conjunction with allowing for strided memory to be shared.   In addition,"
" the new buffer interface will allow the sharing of any multi-dimensional"
" nature of the memory and what data-format the memory contains."
msgstr ""

#: ../../pep-3118.txt:27
msgid ""
"This interface will allow any extension module to either create objects "
"that share memory or create algorithms that use and manipulate raw memory"
" from arbitrary objects that export the interface."
msgstr ""

#: ../../pep-3118.txt:34
msgid "Rationale"
msgstr ""

#: ../../pep-3118.txt:36
msgid ""
"The Python 2.X buffer protocol allows different Python types to exchange "
"a pointer to a sequence of internal buffers.  This functionality is "
"*extremely* useful for sharing large segments of memory between different"
" high-level objects, but it is too limited and has issues:"
msgstr ""

#: ../../pep-3118.txt:42
msgid ""
"There is the little used \"sequence-of-segments\" option (bf_getsegcount)"
" that is not well motivated."
msgstr ""

#: ../../pep-3118.txt:45
msgid ""
"There is the apparently redundant character-buffer option "
"(bf_getcharbuffer)"
msgstr ""

#: ../../pep-3118.txt:48
msgid ""
"There is no way for a consumer to tell the buffer-API-exporting object it"
" is \"finished\" with its view of the memory and therefore no way for the"
" exporting object to be sure that it is safe to reallocate the pointer to"
" the memory that it owns (for example, the array object reallocating its "
"memory after sharing it with the buffer object which held the original "
"pointer led to the infamous buffer-object problem)."
msgstr ""

#: ../../pep-3118.txt:56
msgid ""
"Memory is just a pointer with a length. There is no way to describe what "
"is \"in\" the memory (float, int, C-structure, etc.)"
msgstr ""

#: ../../pep-3118.txt:59
msgid ""
"There is no shape information provided for the memory.  But, several "
"array-like Python types could make use of a standard way to describe the "
"shape-interpretation of the memory (wxPython, GTK, pyQT, CVXOPT, PyVox, "
"Audio and Video Libraries, ctypes, NumPy, data-base interfaces, etc.)"
msgstr ""

#: ../../pep-3118.txt:65
msgid ""
"There is no way to share discontiguous memory (except through the "
"sequence of segments notion)."
msgstr ""

#: ../../pep-3118.txt:68
msgid ""
"There are two widely used libraries that use the concept of discontiguous"
" memory: PIL and NumPy.  Their view of discontiguous arrays is different,"
" though.  The proposed buffer interface allows sharing of either memory "
"model.  Exporters will typically use only one approach and consumers may "
"choose to support discontiguous arrays of each type however they choose."
msgstr ""

#: ../../pep-3118.txt:75
msgid ""
"NumPy uses the notion of constant striding in each dimension as its basic"
" concept of an array. With this concept, a simple sub-region of a larger "
"array can be described without copying the data. Thus, stride information"
" is the additional information that must be shared."
msgstr ""

#: ../../pep-3118.txt:81
msgid ""
"The PIL uses a more opaque memory representation. Sometimes an image is "
"contained in a contiguous segment of memory, but sometimes it is "
"contained in an array of pointers to the contiguous segments (usually "
"lines) of the image.  The PIL is where the idea of multiple buffer "
"segments in the original buffer interface came from."
msgstr ""

#: ../../pep-3118.txt:87
msgid ""
"NumPy's strided memory model is used more often in computational "
"libraries and because it is so simple it makes sense to support memory "
"sharing using this model.  The PIL memory model is sometimes used in "
"C-code where a 2-d array can then be accessed using double pointer "
"indirection:  e.g. ``image[i][j]``."
msgstr ""

#: ../../pep-3118.txt:93
msgid ""
"The buffer interface should allow the object to export either of these "
"memory models.  Consumers are free to either require contiguous memory or"
" write code to handle one or both of these memory models."
msgstr ""

#: ../../pep-3118.txt:98
msgid "Proposal Overview"
msgstr ""

#: ../../pep-3118.txt:100
msgid ""
"Eliminate the char-buffer and multiple-segment sections of the buffer-"
"protocol."
msgstr ""

#: ../../pep-3118.txt:103
msgid "Unify the read/write versions of getting the buffer."
msgstr ""

#: ../../pep-3118.txt:105
msgid ""
"Add a new function to the interface that should be called when the "
"consumer object is \"done\" with the memory area."
msgstr ""

#: ../../pep-3118.txt:108
msgid ""
"Add a new variable to allow the interface to describe what is in memory "
"(unifying what is currently done now in struct and array)"
msgstr ""

#: ../../pep-3118.txt:112
msgid "Add a new variable to allow the protocol to share shape information"
msgstr ""

#: ../../pep-3118.txt:114
msgid "Add a new variable for sharing stride information"
msgstr ""

#: ../../pep-3118.txt:116
msgid ""
"Add a new mechanism for sharing arrays that must be accessed using "
"pointer indirection."
msgstr ""

#: ../../pep-3118.txt:119
msgid ""
"Fix all objects in the core and the standard library to conform to the "
"new interface"
msgstr ""

#: ../../pep-3118.txt:122
msgid "Extend the struct module to handle more format specifiers"
msgstr ""

#: ../../pep-3118.txt:124
msgid ""
"Extend the buffer object into a new memory object which places a Python "
"veneer around the buffer interface."
msgstr ""

#: ../../pep-3118.txt:127
msgid ""
"Add a few functions to make it easy to copy contiguous data in and out of"
" object supporting the buffer interface."
msgstr ""

#: ../../pep-3118.txt:131
msgid "Specification"
msgstr ""

#: ../../pep-3118.txt:133
msgid ""
"While the new specification allows for complicated memory sharing, simple"
" contiguous buffers of bytes can still be obtained from an object.  In "
"fact, the new protocol allows a standard mechanism for doing this even if"
" the original object is not represented as a contiguous chunk of memory."
msgstr ""

#: ../../pep-3118.txt:139
msgid ""
"The easiest way to obtain a simple contiguous chunk of memory is to use "
"the provided C-API to obtain a chunk of memory."
msgstr ""

#: ../../pep-3118.txt:143
msgid "Change the ``PyBufferProcs`` structure to ::"
msgstr ""

#: ../../pep-3118.txt:150
msgid "Both of these routines are optional for a type object"
msgstr ""

#: ../../pep-3118.txt:156
msgid ""
"This function returns ``0`` on success and ``-1`` on failure (and raises "
"an error). The first variable is the \"exporting\" object.  The second "
"argument is the address to a bufferinfo structure.  Both arguments must "
"never be NULL."
msgstr ""

#: ../../pep-3118.txt:161
msgid ""
"The third argument indicates what kind of buffer the consumer is prepared"
" to deal with and therefore what kind of buffer the exporter is allowed "
"to return.  The new buffer interface allows for much more complicated "
"memory sharing possibilities.  Some consumers may not be able to handle "
"all the complexity but may want to see if the exporter will let them take"
" a simpler view to its memory."
msgstr ""

#: ../../pep-3118.txt:168
msgid ""
"In addition, some exporters may not be able to share memory in every "
"possible way and may need to raise errors to signal to some consumers "
"that something is just not possible.  These errors should be "
"``PyErr_BufferError`` unless there is another error that is actually "
"causing the problem. The exporter can use flags information to simplify "
"how much of the PyBuffer structure is filled in with non-default values "
"and/or raise an error if the object can't support a simpler view of its "
"memory."
msgstr ""

#: ../../pep-3118.txt:177
msgid ""
"The exporter should always fill in all elements of the buffer structure "
"(with defaults or NULLs if nothing else is requested). The "
"PyBuffer_FillInfo function can be used for simple cases."
msgstr ""

#: ../../pep-3118.txt:183
msgid "Access flags"
msgstr ""

#: ../../pep-3118.txt:185
msgid ""
"Some flags are useful for requesting a specific kind of memory segment, "
"while others indicate to the exporter what kind of information the "
"consumer can deal with.  If certain information is not asked for by the "
"consumer, but the exporter cannot share its memory without that "
"information, then a ``PyErr_BufferError`` should be raised."
msgstr ""

#: ../../pep-3118.txt:191
msgid "``PyBUF_SIMPLE``"
msgstr ""

#: ../../pep-3118.txt:193
msgid ""
"This is the default flag state (0). The returned buffer may or may not "
"have writable memory.  The format will be assumed to be unsigned bytes.  "
"This is a \"stand-alone\" flag constant.  It never needs to be \\|'d to "
"the others.  The exporter will raise an error if it cannot provide such a"
" contiguous buffer of bytes."
msgstr ""

#: ../../pep-3118.txt:199
msgid "``PyBUF_WRITABLE``"
msgstr ""

#: ../../pep-3118.txt:201
msgid ""
"The returned buffer must be writable.  If it is not writable, then raise "
"an error."
msgstr ""

#: ../../pep-3118.txt:204
msgid "``PyBUF_FORMAT``"
msgstr ""

#: ../../pep-3118.txt:206
msgid ""
"The returned buffer must have true format information if this flag is "
"provided.  This would be used when the consumer is going to be checking "
"for what 'kind' of data is actually stored.  An exporter should always be"
" able to provide this information if requested.  If format is not "
"explicitly requested then the format must be returned as ``NULL`` (which "
"means \"B\", or unsigned bytes)"
msgstr ""

#: ../../pep-3118.txt:213
msgid "``PyBUF_ND``"
msgstr ""

#: ../../pep-3118.txt:215
msgid ""
"The returned buffer must provide shape information. The memory will be "
"assumed C-style contiguous (last dimension varies the fastest). The "
"exporter may raise an error if it cannot provide this kind of contiguous "
"buffer.  If this is not given then shape will be NULL."
msgstr ""

#: ../../pep-3118.txt:220
msgid "``PyBUF_STRIDES`` (implies ``PyBUF_ND``)"
msgstr ""

#: ../../pep-3118.txt:222
msgid ""
"The returned buffer must provide strides information (i.e. the strides "
"cannot be NULL).  This would be used when the consumer can handle "
"strided, discontiguous arrays. Handling strides automatically assumes you"
" can handle shape. The exporter may raise an error if cannot provide a "
"strided-only representation of the data (i.e. without the suboffsets)."
msgstr ""

#: ../../pep-3118.txt:229
msgid "``PyBUF_C_CONTIGUOUS``"
msgstr ""

#: ../../pep-3118.txt:230
msgid "``PyBUF_F_CONTIGUOUS``"
msgstr ""

#: ../../pep-3118.txt:231
msgid "``PyBUF_ANY_CONTIGUOUS``"
msgstr ""

#: ../../pep-3118.txt:233
msgid ""
"These flags indicate that the returned buffer must be respectively, "
"C-contiguous (last dimension varies the fastest), Fortran contiguous "
"(first dimension varies the fastest) or either one. All of these flags "
"imply PyBUF_STRIDES and guarantee that the strides buffer info structure "
"will be filled in correctly."
msgstr ""

#: ../../pep-3118.txt:239
msgid "``PyBUF_INDIRECT`` (implies ``PyBUF_STRIDES``)"
msgstr ""

#: ../../pep-3118.txt:241
msgid ""
"The returned buffer must have suboffsets information (which can be NULL "
"if no suboffsets are needed).  This would be used when the consumer can "
"handle indirect array referencing implied by these suboffsets."
msgstr ""

#: ../../pep-3118.txt:247
msgid "Specialized combinations of flags for specific kinds of memory_sharing."
msgstr ""

#: ../../pep-3118.txt:249
msgid "Multi-dimensional (but contiguous)"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_CONTIG`` (``PyBUF_ND | PyBUF_WRITABLE``)"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_CONTIG_RO`` (``PyBUF_ND``)"
msgstr ""

#: ../../pep-3118.txt:254
msgid "Multi-dimensional using strides but aligned"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_STRIDED`` (``PyBUF_STRIDES | PyBUF_WRITABLE``)"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_STRIDED_RO`` (``PyBUF_STRIDES``)"
msgstr ""

#: ../../pep-3118.txt:259
msgid "Multi-dimensional using strides and not necessarily aligned"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_RECORDS`` (``PyBUF_STRIDES | PyBUF_WRITABLE | PyBUF_FORMAT``)"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_RECORDS_RO`` (``PyBUF_STRIDES | PyBUF_FORMAT``)"
msgstr ""

#: ../../pep-3118.txt:264
msgid "Multi-dimensional using sub-offsets"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_FULL`` (``PyBUF_INDIRECT | PyBUF_WRITABLE | PyBUF_FORMAT``)"
msgstr ""

#: ../../pep-3118.txt
msgid "``PyBUF_FULL_RO`` (``PyBUF_INDIRECT | PyBUF_FORMAT``)"
msgstr ""

#: ../../pep-3118.txt:269
msgid ""
"Thus, the consumer simply wanting a contiguous chunk of bytes from the "
"object would use ``PyBUF_SIMPLE``, while a consumer that understands how "
"to make use of the most complicated cases could use ``PyBUF_FULL``."
msgstr ""

#: ../../pep-3118.txt:273
msgid ""
"The format information is only guaranteed to be non-NULL if "
"``PyBUF_FORMAT`` is in the flag argument, otherwise it is expected the "
"consumer will assume unsigned bytes."
msgstr ""

#: ../../pep-3118.txt:277
msgid ""
"There is a C-API that simple exporting objects can use to fill-in the "
"buffer info structure correctly according to the provided flags if a "
"contiguous chunk of \"unsigned bytes\" is all that can be exported."
msgstr ""

#: ../../pep-3118.txt:283
msgid "The Py_buffer struct"
msgstr ""

#: ../../pep-3118.txt:285
msgid "The bufferinfo structure is::"
msgstr ""

#: ../../pep-3118.txt:300
msgid ""
"Before calling the bf_getbuffer function, the bufferinfo structure can be"
" filled with whatever, but the ``buf`` field must be NULL when requesting"
" a new buffer.  Upon return from bf_getbuffer, the bufferinfo structure "
"is filled in with relevant information about the buffer.  This same "
"bufferinfo structure must be passed to bf_releasebuffer (if available) "
"when the consumer is done with the memory. The caller is responsible for "
"keeping a reference to obj until releasebuffer is called (i.e. the call "
"to bf_getbuffer does not alter the reference count of obj)."
msgstr ""

#: ../../pep-3118.txt:310
msgid "The members of the bufferinfo structure are:"
msgstr ""

#: ../../pep-3118.txt:313
msgid "``buf``"
msgstr ""

#: ../../pep-3118.txt:313
msgid "a pointer to the start of the memory for the object"
msgstr ""

#: ../../pep-3118.txt:318
msgid "``len``"
msgstr ""

#: ../../pep-3118.txt:316
msgid ""
"the total bytes of memory the object uses.  This should be the same as "
"the product of the shape array multiplied by the number of bytes per item"
" of memory."
msgstr ""

#: ../../pep-3118.txt:322 ../../pep-3118.txt:528
msgid "``readonly``"
msgstr ""

#: ../../pep-3118.txt:321
msgid ""
"an integer variable to hold whether or not the memory is readonly. 1 "
"means the memory is readonly, zero means the memory is writable."
msgstr ""

#: ../../pep-3118.txt:329 ../../pep-3118.txt:523
msgid "``format``"
msgstr ""

#: ../../pep-3118.txt:325
msgid ""
"a NULL-terminated format-string (following the struct-style syntax "
"including extensions) indicating what is in each element of memory.  The "
"number of elements is len / itemsize, where itemsize is the number of "
"bytes implied by the format.  This can be NULL which implies standard "
"unsigned bytes (\"B\")."
msgstr ""

#: ../../pep-3118.txt:334 ../../pep-3118.txt:529
msgid "``ndim``"
msgstr ""

#: ../../pep-3118.txt:332
msgid ""
"a variable storing the number of dimensions the memory represents. Must "
"be >=0.  A value of 0 means that shape and strides and suboffsets must be"
" ``NULL`` (i.e. the memory represents a scalar)."
msgstr ""

#: ../../pep-3118.txt:340 ../../pep-3118.txt:525
msgid "``shape``"
msgstr ""

#: ../../pep-3118.txt:337
msgid ""
"an array of ``Py_ssize_t`` of length ``ndims`` indicating the shape of "
"the memory as an N-D array.  Note that ``((*shape)[0] * ... * "
"(*shape)[ndims-1])*itemsize = len``.  If ndims is 0 (indicating a "
"scalar), then this must be ``NULL``."
msgstr ""

#: ../../pep-3118.txt:349 ../../pep-3118.txt:526
msgid "``strides``"
msgstr ""

#: ../../pep-3118.txt:343
msgid ""
"address of a ``Py_ssize_t*`` variable that will be filled with a pointer "
"to an array of ``Py_ssize_t`` of length ``ndims`` (or ``NULL`` if "
"``ndims`` is 0).  indicating the number of bytes to skip to get to the "
"next element in each dimension.  If this is not requested by the caller "
"(``PyBUF_STRIDES`` is not set), then this should be set to NULL which "
"indicates a C-style contiguous array or a PyExc_BufferError raised if "
"this is not possible."
msgstr ""

#: ../../pep-3118.txt:385 ../../pep-3118.txt:527
msgid "``suboffsets``"
msgstr ""

#: ../../pep-3118.txt:352
msgid ""
"address of a ``Py_ssize_t *`` variable that will be filled with a pointer"
" to an array of ``Py_ssize_t`` of length ``*ndims``.  If these suboffset "
"numbers are >=0, then the value stored along the indicated dimension is a"
" pointer and the suboffset value dictates how many bytes to add to the "
"pointer after de-referencing.  A suboffset value that it negative "
"indicates that no de-referencing should occur (striding in a contiguous "
"memory block).  If all suboffsets are negative (i.e. no de-referencing is"
" needed, then this must be NULL (the default value).  If this is not "
"requested by the caller (PyBUF_INDIRECT is not set), then this should be "
"set to NULL or an PyExc_BufferError raised if this is not possible."
msgstr ""

#: ../../pep-3118.txt:364
msgid ""
"For clarity, here is a function that returns a pointer to the element in "
"an N-D array pointed to by an N-dimensional index when there are both "
"non-NULL strides and suboffsets::"
msgstr ""

#: ../../pep-3118.txt:381
msgid ""
"Notice the suboffset is added \"after\" the dereferencing occurs. Thus "
"slicing in the ith dimension would add to the suboffsets in the (i-1)st "
"dimension.  Slicing in the first dimension would change the location of "
"the starting pointer directly (i.e. buf would be modified)."
msgstr ""

#: ../../pep-3118.txt:393 ../../pep-3118.txt:524
msgid "``itemsize``"
msgstr ""

#: ../../pep-3118.txt:388
msgid ""
"This is a storage for the itemsize (in bytes) of each element of the "
"shared memory.  It is technically un-necessary as it can be obtained "
"using ``PyBuffer_SizeFromFormat``, however an exporter may know this "
"information without parsing the format string and it is necessary to know"
" the itemsize for proper interpretation of striding. Therefore, storing "
"it is more convenient and faster."
msgstr ""

#: ../../pep-3118.txt:401
msgid "``internal``"
msgstr ""

#: ../../pep-3118.txt:396
msgid ""
"This is for use internally by the exporting object.  For example, this "
"might be re-cast as an integer by the exporter and used to store flags "
"about whether or not the shape, strides, and suboffsets arrays must be "
"freed when the buffer is released.   The consumer should never alter this"
" value."
msgstr ""

#: ../../pep-3118.txt:403
msgid ""
"The exporter is responsible for making sure that any memory pointed to by"
" buf, format, shape, strides, and suboffsets is valid until releasebuffer"
" is called.  If the exporter wants to be able to change an object's "
"shape, strides, and/or suboffsets before releasebuffer is called then it "
"should allocate those arrays when getbuffer is called (pointing to them "
"in the buffer-info structure provided) and free them when releasebuffer "
"is called."
msgstr ""

#: ../../pep-3118.txt:413
msgid "Releasing the buffer"
msgstr ""

#: ../../pep-3118.txt:415
msgid ""
"The same bufferinfo struct should be used in the release-buffer interface"
" call.  The caller is responsible for the memory of the Py_buffer "
"structure itself."
msgstr ""

#: ../../pep-3118.txt:423
msgid ""
"Callers of getbufferproc must make sure that this function is called when"
" memory previously acquired from the object is no longer needed. The "
"exporter of the interface must make sure that any memory pointed to in "
"the bufferinfo structure remains valid until releasebuffer is called."
msgstr ""

#: ../../pep-3118.txt:429
msgid ""
"If the bf_releasebuffer function is not provided (i.e. it is NULL), then "
"it does not ever need to be called."
msgstr ""

#: ../../pep-3118.txt:432
msgid ""
"Exporters will need to define a bf_releasebuffer function if they can re-"
"allocate their memory, strides, shape, suboffsets, or format variables "
"which they might share through the struct bufferinfo. Several mechanisms "
"could be used to keep track of how many getbuffer calls have been made "
"and shared.  Either a single variable could be used to keep track of how "
"many \"views\" have been exported, or a linked-list of bufferinfo "
"structures filled in could be maintained in each object."
msgstr ""

#: ../../pep-3118.txt:441
msgid ""
"All that is specifically required by the exporter, however, is to ensure "
"that any memory shared through the bufferinfo structure remains valid "
"until releasebuffer is called on the bufferinfo structure exporting that "
"memory."
msgstr ""

#: ../../pep-3118.txt:448
msgid "New C-API calls are proposed"
msgstr ""

#: ../../pep-3118.txt:454
msgid "Return 1 if the getbuffer function is available otherwise 0."
msgstr ""

#: ../../pep-3118.txt:461
msgid ""
"This is a C-API version of the getbuffer function call.  It checks to "
"make sure object has the required function pointer and issues the call.  "
"Returns -1 and raises an error on failure and returns 0 on success."
msgstr ""

#: ../../pep-3118.txt:470
msgid ""
"This is a C-API version of the releasebuffer function call.  It checks to"
" make sure the object has the required function pointer and issues the "
"call.  This function always succeeds even if there is no releasebuffer "
"function for the object."
msgstr ""

#: ../../pep-3118.txt:479
msgid ""
"Return a memory-view object from an object that defines the buffer "
"interface."
msgstr ""

#: ../../pep-3118.txt:481
msgid ""
"A memory-view object is an extended buffer object that could replace the "
"buffer object (but doesn't have to as that could be kept as a simple 1-d "
"memory-view object).  Its C-structure is ::"
msgstr ""

#: ../../pep-3118.txt:491
msgid ""
"This is functionally similar to the current buffer object except a "
"reference to base is kept and the memory view is not re-grabbed. Thus, "
"this memory view object holds on to the memory of base until it is "
"deleted."
msgstr ""

#: ../../pep-3118.txt:496
msgid ""
"This memory-view object will support multi-dimensional slicing and be the"
" first object provided with Python to do so.  Slices of the memory-view "
"object are other memory-view objects with the same base but with a "
"different view of the base object."
msgstr ""

#: ../../pep-3118.txt:501
msgid ""
"When an \"element\" from the memory-view is returned it is always a bytes"
" object whose format should be interpreted by the format attribute of the"
" memoryview object.  The struct module can be used to \"decode\" the "
"bytes in Python if desired.  Or the contents can be passed to a NumPy "
"array or other object consuming the buffer protocol."
msgstr ""

#: ../../pep-3118.txt:507
msgid "The Python name will be"
msgstr ""

#: ../../pep-3118.txt:509
msgid "``__builtin__.memoryview``"
msgstr ""

#: ../../pep-3118.txt:511
msgid "Methods:"
msgstr ""

#: ../../pep-3118.txt:513
msgid "``__getitem__``  (will support multi-dimensional slicing)"
msgstr ""

#: ../../pep-3118.txt:514
msgid "``__setitem__``  (will support multi-dimensional slicing)"
msgstr ""

#: ../../pep-3118.txt:515
msgid "``tobytes``      (obtain a new bytes-object of a copy of the memory)."
msgstr ""

#: ../../pep-3118.txt:519
msgid ""
"``tolist``       (obtain a \"nested\" list of the memory.  Everything is "
"interpreted into standard Python objects as the struct module unpack "
"would do -- in fact it uses struct.unpack to accomplish it)."
msgstr ""

#: ../../pep-3118.txt:521
msgid "Attributes (taken from the memory of the base object):"
msgstr ""

#: ../../pep-3118.txt:536
msgid ""
"Return the implied itemsize of the data-format area from a struct-style "
"description."
msgstr ""

#: ../../pep-3118.txt:544
msgid ""
"Return a memoryview object to a contiguous chunk of memory represented by"
" obj. If a copy must be made (because the memory pointed to by obj is not"
" contiguous), then a new bytes object will be created and become the base"
" object for the returned memory view object."
msgstr ""

#: ../../pep-3118.txt:549
msgid ""
"The buffertype argument can be PyBUF_READ, PyBUF_WRITE, "
"PyBUF_UPDATEIFCOPY to determine whether the returned buffer should be "
"readable, writable, or set to update the original buffer if a copy must "
"be made.  If buffertype is PyBUF_WRITE and the buffer is not contiguous "
"an error will be raised.  In this circumstance, the user can use "
"PyBUF_UPDATEIFCOPY to ensure that a writable temporary contiguous buffer "
"is returned.  The contents of this contiguous buffer will be copied back "
"into the original object after the memoryview object is deleted as long "
"as the original object is writable.  If this is not allowed by the "
"original object, then a BufferError is raised."
msgstr ""

#: ../../pep-3118.txt:560
msgid ""
"If the object is multi-dimensional, then if fortran is 'F', the first "
"dimension of the underlying array will vary the fastest in the buffer. If"
" fortran is 'C', then the last dimension will vary the fastest (C-style "
"contiguous). If fortran is 'A', then it does not matter and you will get "
"whatever the object decides is more efficient.  If a copy is made, then "
"the memory must be freed by calling ``PyMem_Free``."
msgstr ""

#: ../../pep-3118.txt:567
msgid "You receive a new reference to the memoryview object."
msgstr ""

#: ../../pep-3118.txt:574
msgid ""
"Copy ``len`` bytes of data pointed to by the contiguous chunk of memory "
"pointed to by ``buf`` into the buffer exported by obj.  Return 0 on "
"success and return -1 and raise an error on failure.  If the object does "
"not have a writable buffer, then an error is raised.  If fortran is 'F', "
"then if the object is multi-dimensional, then the data will be copied "
"into the array in Fortran-style (first dimension varies the fastest).  If"
" fortran is 'C', then the data will be copied into the array in C-style "
"(last dimension varies the fastest).  If fortran is 'A', then it does not"
" matter and the copy will be made in whatever way is more efficient."
msgstr ""

#: ../../pep-3118.txt:589
msgid ""
"These last three C-API calls allow a standard way of getting data in and "
"out of Python objects into contiguous memory areas no matter how it is "
"actually stored.  These calls use the extended buffer interface to "
"perform their work."
msgstr ""

#: ../../pep-3118.txt:598
msgid ""
"Return 1 if the memory defined by the view object is C-style (fortran = "
"'C') or Fortran-style (fortran = 'F') contiguous or either one (fortran ="
" 'A').  Return 0 otherwise."
msgstr ""

#: ../../pep-3118.txt:608
msgid ""
"Fill the strides array with byte-strides of a contiguous (C-style if "
"fortran is 'C' or Fortran-style if fortran is 'F' array of the given "
"shape with the given number of bytes per element."
msgstr ""

#: ../../pep-3118.txt:617
msgid ""
"Fills in a buffer-info structure correctly for an exporter that can only "
"share a contiguous chunk of memory of \"unsigned bytes\" of the given "
"length.  Returns 0 on success and -1 (with raising an error) on error."
msgstr ""

#: ../../pep-3118.txt:626
msgid ""
"A new error object for returning buffer errors which arise because an "
"exporter cannot provide the kind of buffer that a consumer expects. This "
"will also be raised when a consumer requests a buffer from an object that"
" does not provide the protocol."
msgstr ""

#: ../../pep-3118.txt:633
msgid "Additions to the struct string-syntax"
msgstr ""

#: ../../pep-3118.txt:635
msgid ""
"The struct string-syntax is missing some characters to fully implement "
"data-format descriptions already available elsewhere (in ctypes and NumPy"
" for example).  The Python 2.5 specification is at "
"http://docs.python.org/library/struct.html."
msgstr ""

#: ../../pep-3118.txt:640
msgid "Here are the proposed additions:"
msgstr ""

#: ../../pep-3118.txt:644
msgid "Character"
msgstr ""

#: ../../pep-3118.txt:644
msgid "Description"
msgstr ""

#: ../../pep-3118.txt:646
msgid "'t'"
msgstr ""

#: ../../pep-3118.txt:646
msgid "bit (number before states how many bits)"
msgstr ""

#: ../../pep-3118.txt:647
msgid "'?'"
msgstr ""

#: ../../pep-3118.txt:647
msgid "platform _Bool type"
msgstr ""

#: ../../pep-3118.txt:648
msgid "'g'"
msgstr ""

#: ../../pep-3118.txt:648
msgid "long double"
msgstr ""

#: ../../pep-3118.txt:649
msgid "'c'"
msgstr ""

#: ../../pep-3118.txt:649
msgid "ucs-1 (latin-1) encoding"
msgstr ""

#: ../../pep-3118.txt:650
msgid "'u'"
msgstr ""

#: ../../pep-3118.txt:650
msgid "ucs-2"
msgstr ""

#: ../../pep-3118.txt:651
msgid "'w'"
msgstr ""

#: ../../pep-3118.txt:651
msgid "ucs-4"
msgstr ""

#: ../../pep-3118.txt:652
msgid "'O'"
msgstr ""

#: ../../pep-3118.txt:652
msgid "pointer to Python Object"
msgstr ""

#: ../../pep-3118.txt:653
msgid "'Z'"
msgstr ""

#: ../../pep-3118.txt:653
msgid "complex (whatever the next specifier is)"
msgstr ""

#: ../../pep-3118.txt:654
msgid "'&'"
msgstr ""

#: ../../pep-3118.txt:654
msgid "specific pointer (prefix before another character)"
msgstr ""

#: ../../pep-3118.txt:655
msgid "'T{}'"
msgstr ""

#: ../../pep-3118.txt:655
msgid "structure (detailed layout inside {})"
msgstr ""

#: ../../pep-3118.txt:656
msgid "'(k1,k2,...,kn)'"
msgstr ""

#: ../../pep-3118.txt:656
msgid "multi-dimensional array of whatever follows"
msgstr ""

#: ../../pep-3118.txt:657
msgid "':name:'"
msgstr ""

#: ../../pep-3118.txt:657
msgid "optional name of the preceding element"
msgstr ""

#: ../../pep-3118.txt:658
msgid "'X{}'"
msgstr ""

#: ../../pep-3118.txt:659
msgid "pointer to a function (optional function"
msgstr ""

#: ../../pep-3118.txt:659
msgid ""
"signature inside {} with any return value preceded by -> and placed at "
"the end)"
msgstr ""

#: ../../pep-3118.txt:663
msgid ""
"The struct module will be changed to understand these as well and return "
"appropriate Python objects on unpacking.  Unpacking a long-double will "
"return a decimal object or a ctypes long-double. Unpacking 'u' or 'w' "
"will return Python unicode.  Unpacking a multi-dimensional array will "
"return a list (of lists if >1d). Unpacking a pointer will return a ctypes"
" pointer object. Unpacking a function pointer will return a ctypes call-"
"object (perhaps). Unpacking a bit will return a Python Bool.  White-space"
" in the struct-string syntax will be ignored if it isn't already.  "
"Unpacking a named-object will return some kind of named-tuple-like object"
" that acts like a tuple but whose entries can also be accessed by name. "
"Unpacking a nested structure will return a nested tuple."
msgstr ""

#: ../../pep-3118.txt:676
msgid ""
"Endian-specification ('!', '@','=','>','<', '^') is also allowed inside "
"the string so that it can change if needed.  The previously-specified "
"endian string is in force until changed.  The default endian is '@' which"
" means native data-types and alignment.  If un-aligned, native data-types"
" are requested, then the endian specification is '^'."
msgstr ""

#: ../../pep-3118.txt:683
msgid ""
"According to the struct-module, a number can precede a character code to "
"specify how many of that type there are.  The ``(k1,k2,...,kn)`` "
"extension also allows specifying if the data is supposed to be viewed as "
"a (C-style contiguous, last-dimension varies the fastest) multi-"
"dimensional array of a particular format."
msgstr ""

#: ../../pep-3118.txt:689
msgid ""
"Functions should be added to ctypes to create a ctypes object from a "
"struct description, and add long-double, and ucs-2 to ctypes."
msgstr ""

#: ../../pep-3118.txt:693
msgid "Examples of Data-Format Descriptions"
msgstr ""

#: ../../pep-3118.txt:695
msgid ""
"Here are some examples of C-structures and how they would be represented "
"using the struct-style syntax."
msgstr ""

#: ../../pep-3118.txt:698
msgid "<named> is the constructor for a named-tuple (not-specified yet)."
msgstr ""

#: ../../pep-3118.txt:700
msgid "float"
msgstr ""

#: ../../pep-3118.txt:701
msgid "``'d'`` <--> Python float"
msgstr ""

#: ../../pep-3118.txt:702
msgid "complex double"
msgstr ""

#: ../../pep-3118.txt:703
msgid "``'Zd'`` <--> Python complex"
msgstr ""

#: ../../pep-3118.txt:706
msgid "RGB Pixel data"
msgstr ""

#: ../../pep-3118.txt:705
msgid ""
"``'BBB'`` <--> (int, int, int) ``'B:r: B:g: B:b:'`` <--> <named>((int, "
"int, int), ('r','g','b'))"
msgstr ""

#: ../../pep-3118.txt:709
msgid "Mixed endian (weird but possible)"
msgstr ""

#: ../../pep-3118.txt:709
msgid "``'>i:big: <i:little:'`` <--> <named>((int, int), ('big', 'little'))"
msgstr ""

#: ../../pep-3118.txt:727
msgid "Nested structure"
msgstr ""

#: ../../pep-3118.txt:738
msgid "Nested array"
msgstr ""

#: ../../pep-3118.txt:740
msgid ""
"Note, that in the last example, the C-structure compared against is "
"intentionally a 1-d array and not a 2-d array data[16][4].  The reason "
"for this is to avoid the confusions between static multi-dimensional "
"arrays in C (which are laid out contiguously) and dynamic multi-"
"dimensional arrays which use the same syntax to access elements, "
"data[0][1], but whose memory is not necessarily contiguous.  The struct-"
"syntax *always* uses contiguous memory and the multi-dimensional "
"character is information about the memory to be communicated by the "
"exporter."
msgstr ""

#: ../../pep-3118.txt:750
msgid ""
"In other words, the struct-syntax description does not have to match the "
"C-syntax exactly as long as it describes the same memory layout. The fact"
" that a C-compiler would think of the memory as a 1-d array of doubles is"
" irrelevant to the fact that the exporter wanted to communicate to the "
"consumer that this field of the memory should be thought of as a 2-d "
"array where a new dimension is considered after every 4 elements."
msgstr ""

#: ../../pep-3118.txt:760
msgid "Code to be affected"
msgstr ""

#: ../../pep-3118.txt:762
msgid ""
"All objects and modules in Python that export or consume the old buffer "
"interface will be modified.  Here is a partial list."
msgstr ""

#: ../../pep-3118.txt:765
msgid "buffer object"
msgstr ""

#: ../../pep-3118.txt:766
msgid "bytes object"
msgstr ""

#: ../../pep-3118.txt:767
msgid "string object"
msgstr ""

#: ../../pep-3118.txt:768
msgid "unicode object"
msgstr ""

#: ../../pep-3118.txt:769
msgid "array module"
msgstr ""

#: ../../pep-3118.txt:770
msgid "struct module"
msgstr ""

#: ../../pep-3118.txt:771
msgid "mmap module"
msgstr ""

#: ../../pep-3118.txt:772
msgid "ctypes module"
msgstr ""

#: ../../pep-3118.txt:774
msgid "Anything else using the buffer API."
msgstr ""

#: ../../pep-3118.txt:778
msgid "Issues and Details"
msgstr ""

#: ../../pep-3118.txt:780
msgid ""
"It is intended that this PEP will be back-ported to Python 2.6 by adding "
"the C-API and the two functions to the existing buffer protocol."
msgstr ""

#: ../../pep-3118.txt:784
msgid ""
"Previous versions of this PEP proposed a read/write locking scheme, but "
"it was later perceived as a) too complicated for common simple use cases "
"that do not require any locking and b) too simple for use cases that "
"required concurrent read/write access to a buffer with changing, short-"
"living locks.  It is therefore left to users to implement their own "
"specific locking scheme around buffer objects if they require consistent "
"views across concurrent read/write access.  A future PEP may be proposed "
"which includes a separate locking API after some experience with these "
"user-schemes is obtained"
msgstr ""

#: ../../pep-3118.txt:794
msgid ""
"The sharing of strided memory and suboffsets is new and can be seen as a "
"modification of the multiple-segment interface.  It is motivated by NumPy"
" and the PIL.  NumPy objects should be able to share their strided memory"
" with code that understands how to manage strided memory because strided "
"memory is very common when interfacing with compute libraries."
msgstr ""

#: ../../pep-3118.txt:801
msgid ""
"Also, with this approach it should be possible to write generic code that"
" works with both kinds of memory without copying."
msgstr ""

#: ../../pep-3118.txt:804
msgid ""
"Memory management of the format string, the shape array, the strides "
"array, and the suboffsets array in the bufferinfo structure is always the"
" responsibility of the exporting object.  The consumer should not set "
"these pointers to any other memory or try to free them."
msgstr ""

#: ../../pep-3118.txt:809
msgid "Several ideas were discussed and rejected:"
msgstr ""

#: ../../pep-3118.txt:811
msgid ""
"Having a \"releaser\" object whose release-buffer was called.  This was "
"deemed unacceptable because it caused the protocol to be asymmetric (you "
"called release on something different than you \"got\" the buffer from)."
"  It also complicated the protocol without providing a real benefit."
msgstr ""

#: ../../pep-3118.txt:817
msgid ""
"Passing all the struct variables separately into the function. This had "
"the advantage that it allowed one to set NULL to variables that were not "
"of interest, but it also made the function call more difficult.  The "
"flags variable allows the same ability of consumers to be \"simple\" in "
"how they call the protocol."
msgstr ""

#: ../../pep-3118.txt:825
msgid "Code"
msgstr ""

#: ../../pep-3118.txt:827
msgid ""
"The authors of the PEP promise to contribute and maintain the code for "
"this proposal but will welcome any help."
msgstr ""

#: ../../pep-3118.txt:832
msgid "Examples"
msgstr ""

#: ../../pep-3118.txt:835
msgid "Ex. 1"
msgstr ""

#: ../../pep-3118.txt:837
msgid ""
"This example shows how an image object that uses contiguous lines might "
"expose its buffer::"
msgstr ""

#: ../../pep-3118.txt:854
msgid ""
"\"lines\" points to malloced 1-D array of ``(struct rgba*)``.  Each "
"pointer in THAT block points to a separately malloced array of ``(struct "
"rgba)``."
msgstr ""

#: ../../pep-3118.txt:857
msgid ""
"In order to access, say, the red value of the pixel at x=30, y=50, you'd "
"use \"lines[50][30].r\"."
msgstr ""

#: ../../pep-3118.txt:859
msgid "So what does ImageObject's getbuffer do?  Leaving error checking out::"
msgstr ""

#: ../../pep-3118.txt:890
msgid "Ex. 2"
msgstr ""

#: ../../pep-3118.txt:892
msgid ""
"This example shows how an object that wants to expose a contiguous chunk "
"of memory (which will never be re-allocated while the object is alive) "
"would do that."
msgstr ""

#: ../../pep-3118.txt:916
msgid "Ex.  3"
msgstr ""

#: ../../pep-3118.txt:918
msgid ""
"A consumer that wants to only get a simple contiguous chunk of bytes from"
" a Python object, obj would do the following:"
msgstr ""

#: ../../pep-3118.txt:944
msgid "Ex. 4"
msgstr ""

#: ../../pep-3118.txt:946
msgid ""
"A consumer that wants to be able to use any object's memory but is "
"writing an algorithm that only handle contiguous memory could do the "
"following:"
msgstr ""

#: ../../pep-3118.txt:980
msgid "Copyright"
msgstr ""

#: ../../pep-3118.txt:982
msgid "This PEP is placed in the public domain."
msgstr ""

