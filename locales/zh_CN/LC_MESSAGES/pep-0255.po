# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0255.txt
msgid "PEP"
msgstr ""

#: ../../pep-0255.txt:1
msgid "255"
msgstr ""

#: ../../pep-0255.txt
msgid "Title"
msgstr ""

#: ../../pep-0255.txt:2
msgid "Simple Generators"
msgstr ""

#: ../../pep-0255.txt
msgid "Author"
msgstr ""

#: ../../pep-0255.txt:5
msgid ""
"nas@arctrix.com (Neil Schemenauer), tim.peters@gmail.com (Tim Peters), "
"magnus@hetland.org (Magnus Lie Hetland)"
msgstr ""

#: ../../pep-0255.txt
msgid "Discussions-To"
msgstr ""

#: ../../pep-0255.txt:8
msgid "python-iterators@lists.sourceforge.net"
msgstr ""

#: ../../pep-0255.txt
msgid "Status"
msgstr ""

#: ../../pep-0255.txt:9
msgid "Final"
msgstr ""

#: ../../pep-0255.txt
msgid "Type"
msgstr ""

#: ../../pep-0255.txt:10
msgid "Standards Track"
msgstr ""

#: ../../pep-0255.txt
msgid "Requires"
msgstr ""

#: ../../pep-0255.txt:12
msgid "234"
msgstr ""

#: ../../pep-0255.txt
msgid "Created"
msgstr ""

#: ../../pep-0255.txt:13
msgid "18-May-2001"
msgstr ""

#: ../../pep-0255.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0255.txt:14
msgid "2.2"
msgstr ""

#: ../../pep-0255.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0255.txt:15
msgid "14-Jun-2001, 23-Jun-2001"
msgstr ""

#: ../../pep-0255.txt:19
msgid "Abstract"
msgstr ""

#: ../../pep-0255.txt:21
msgid ""
"This PEP introduces the concept of generators to Python, as well as a new"
" statement used in conjunction with them, the ``yield`` statement."
msgstr ""

#: ../../pep-0255.txt:26
msgid "Motivation"
msgstr ""

#: ../../pep-0255.txt:28
msgid ""
"When a producer function has a hard enough job that it requires "
"maintaining state between values produced, most programming languages "
"offer no pleasant and efficient solution beyond adding a callback "
"function to the producer's argument list, to be called with each value "
"produced."
msgstr ""

#: ../../pep-0255.txt:33
msgid ""
"For example, ``tokenize.py`` in the standard library takes this approach:"
" the caller must pass a *tokeneater* function to ``tokenize()``, called "
"whenever ``tokenize()`` finds the next token.  This allows tokenize to be"
" coded in a natural way, but programs calling tokenize are typically "
"convoluted by the need to remember between callbacks which token(s) were "
"seen last.  The *tokeneater* function in ``tabnanny.py`` is a good "
"example of that, maintaining a state machine in global variables, to "
"remember across callbacks what it has already seen and what it hopes to "
"see next.  This was difficult to get working correctly, and is still "
"difficult for people to understand.  Unfortunately, that's typical of "
"this approach."
msgstr ""

#: ../../pep-0255.txt:44
msgid ""
"An alternative would have been for tokenize to produce an entire parse of"
" the Python program at once, in a large list.  Then tokenize clients "
"could be written in a natural way, using local variables and local "
"control flow (such as loops and nested if statements) to keep track of "
"their state.  But this isn't practical:  programs can be very large, so "
"no a priori bound can be placed on the memory needed to materialize the "
"whole parse; and some tokenize clients only want to see whether something"
" specific appears early in the program (e.g., a future statement, or, as "
"is done in IDLE, just the first indented statement), and then parsing the"
" whole program first is a severe waste of time."
msgstr ""

#: ../../pep-0255.txt:54
msgid ""
"Another alternative would be to make tokenize an iterator [1], delivering"
" the next token whenever its ``.next()`` method is invoked.  This is "
"pleasant for the caller in the same way a large list of results would be,"
" but without the memory and \"what if I want to get out early?\" "
"drawbacks.  However, this shifts the burden on tokenize to remember *its*"
" state between ``.next()`` invocations, and the reader need only glance "
"at ``tokenize.tokenize_loop()`` to realize what a horrid chore that would"
" be.  Or picture a recursive algorithm for producing the nodes of a "
"general tree structure:  to cast that into an iterator framework requires"
" removing the recursion manually and maintaining the state of the "
"traversal by hand."
msgstr ""

#: ../../pep-0255.txt:65
msgid ""
"A fourth option is to run the producer and consumer in separate threads."
"  This allows both to maintain their states in natural ways, and so is "
"pleasant for both.  Indeed, Demo/threads/Generator.py in the Python "
"source distribution provides a usable synchronized-communication class "
"for doing that in a general way.  This doesn't work on platforms without "
"threads, though, and is very slow on platforms that do (compared to what "
"is achievable without threads)."
msgstr ""

#: ../../pep-0255.txt:72
msgid ""
"A final option is to use the Stackless [2] [3] variant implementation of "
"Python instead, which supports lightweight coroutines.  This has much the"
" same programmatic benefits as the thread option, but is much more "
"efficient. However, Stackless is a controversial rethinking of the Python"
" core, and it may not be possible for Jython to implement the same "
"semantics.  This PEP isn't the place to debate that, so suffice it to say"
" here that generators provide a useful subset of Stackless functionality "
"in a way that fits easily into the current CPython implementation, and is"
" believed to be relatively straightforward for other Python "
"implementations."
msgstr ""

#: ../../pep-0255.txt:82
msgid ""
"That exhausts the current alternatives.  Some other high-level languages "
"provide pleasant solutions, notably iterators in Sather [4], which were "
"inspired by iterators in CLU; and generators in Icon [5], a novel "
"language where every expression *is a generator*.  There are differences "
"among these, but the basic idea is the same:  provide a kind of function "
"that can return an intermediate result (\"the next value\") to its "
"caller, but maintaining the function's local state so that the function "
"can be resumed again right where it left off.  A very simple example::"
msgstr ""

#: ../../pep-0255.txt:97
msgid ""
"When ``fib()`` is first invoked, it sets *a* to 0 and *b* to 1, then "
"yields *b* back to its caller.  The caller sees 1.  When ``fib`` is "
"resumed, from its point of view the ``yield`` statement is really the "
"same as, say, a ``print`` statement:  ``fib`` continues after the yield "
"with all local state intact. *a* and *b* then become 1 and 1, and ``fib``"
" loops back to the ``yield``, yielding 1 to its invoker.  And so on.  "
"From ``fib``'s point of view it's just delivering a sequence of results, "
"as if via callback.  But from its caller's point of view, the ``fib`` "
"invocation is an iterable object that can be resumed at will.  As in the "
"thread approach, this allows both sides to be coded in the most natural "
"ways; but unlike the thread approach, this can be done efficiently and on"
" all platforms.  Indeed, resuming a generator should be no more expensive"
" than a function call."
msgstr ""

#: ../../pep-0255.txt:110
msgid ""
"The same kind of approach applies to many producer/consumer functions. "
"For example, ``tokenize.py`` could yield the next token instead of "
"invoking a callback function with it as argument, and tokenize clients "
"could iterate over the tokens in a natural way:  a Python generator is a "
"kind of Python iterator [1]_, but of an especially powerful kind."
msgstr ""

#: ../../pep-0255.txt:118
msgid "Specification:  Yield"
msgstr ""

#: ../../pep-0255.txt:120
msgid "A new statement is introduced::"
msgstr ""

#: ../../pep-0255.txt:124
msgid ""
"``yield`` is a new keyword, so a ``future`` statement [8]_ is needed to "
"phase this in: in the initial release, a module desiring to use "
"generators must include the line::"
msgstr ""

#: ../../pep-0255.txt:130
msgid ""
"near the top (see PEP 236 [8]_) for details).  Modules using the "
"identifier ``yield`` without a ``future`` statement will trigger "
"warnings. In the following release, ``yield`` will be a language keyword "
"and the ``future`` statement will no longer be needed."
msgstr ""

#: ../../pep-0255.txt:135
msgid ""
"The ``yield`` statement may only be used inside functions.  A function "
"that contains a ``yield`` statement is called a generator function.  A "
"generator function is an ordinary function object in all respects, but "
"has the new ``CO_GENERATOR`` flag set in the code object's co_flags "
"member."
msgstr ""

#: ../../pep-0255.txt:140
msgid ""
"When a generator function is called, the actual arguments are bound to "
"function-local formal argument names in the usual way, but no code in the"
" body of the function is executed.  Instead a generator-iterator object "
"is returned; this conforms to the iterator protocol [6]_, so in "
"particular can be used in for-loops in a natural way.  Note that when the"
" intent is clear from context, the unqualified name \"generator\" may be "
"used to refer either to a generator-function or a generator-iterator."
msgstr ""

#: ../../pep-0255.txt:148
msgid ""
"Each time the ``.next()`` method of a generator-iterator is invoked, the "
"code in the body of the generator-function is executed until a ``yield`` "
"or ``return`` statement (see below) is encountered, or until the end of "
"the body is reached."
msgstr ""

#: ../../pep-0255.txt:153
msgid ""
"If a ``yield`` statement is encountered, the state of the function is "
"frozen, and the value of *expression_list* is returned to ``.next()``'s "
"caller.  By \"frozen\" we mean that all local state is retained, "
"including the current bindings of local variables, the instruction "
"pointer, and the internal evaluation stack:  enough information is saved "
"so that the next time ``.next()`` is invoked, the function can proceed "
"exactly as if the ``yield`` statement were just another external call."
msgstr ""

#: ../../pep-0255.txt:161
msgid ""
"Restriction:  A ``yield`` statement is not allowed in the ``try`` clause "
"of a ``try/finally`` construct.  The difficulty is that there's no "
"guarantee the generator will ever be resumed, hence no guarantee that the"
" finally block will ever get executed; that's too much a violation of "
"finally's purpose to bear."
msgstr ""

#: ../../pep-0255.txt:166
msgid "Restriction:  A generator cannot be resumed while it is actively running::"
msgstr ""

#: ../../pep-0255.txt:180
msgid "Specification:  Return"
msgstr ""

#: ../../pep-0255.txt:182
msgid "A generator function can also contain return statements of the form::"
msgstr ""

#: ../../pep-0255.txt:186
msgid ""
"Note that an *expression_list* is not allowed on return statements in the"
" body of a generator (although, of course, they may appear in the bodies "
"of non-generator functions nested within the generator)."
msgstr ""

#: ../../pep-0255.txt:190
msgid ""
"When a return statement is encountered, control proceeds as in any "
"function return, executing the appropriate ``finally`` clauses (if any "
"exist).  Then a ``StopIteration`` exception is raised, signalling that "
"the iterator is exhausted.  A ``StopIteration`` exception is also raised "
"if control flows off the end of the generator without an explicit return."
msgstr ""

#: ../../pep-0255.txt:196
msgid ""
"Note that return means \"I'm done, and have nothing interesting to "
"return\", for both generator functions and non-generator functions."
msgstr ""

#: ../../pep-0255.txt:199
msgid ""
"Note that return isn't always equivalent to raising ``StopIteration``:  "
"the difference lies in how enclosing ``try/except`` constructs are "
"treated. For example,::"
msgstr ""

#: ../../pep-0255.txt:211
msgid "because, as in any function, ``return`` simply exits, but::"
msgstr ""

#: ../../pep-0255.txt:221
msgid ""
"because ``StopIteration`` is captured by a bare ``except``, as is any "
"exception."
msgstr ""

#: ../../pep-0255.txt:226
msgid "Specification:  Generators and Exception Propagation"
msgstr ""

#: ../../pep-0255.txt:228
msgid ""
"If an unhandled exception-- including, but not limited to, "
"``StopIteration`` --is raised by, or passes through, a generator "
"function, then the exception is passed on to the caller in the usual way,"
" and subsequent attempts to resume the generator function raise "
"``StopIteration``.  In other words, an unhandled exception terminates a "
"generator's useful life."
msgstr ""

#: ../../pep-0255.txt:234
msgid "Example (not idiomatic but to illustrate the point)::"
msgstr ""

#: ../../pep-0255.txt:256
msgid "Specification:  Try/Except/Finally"
msgstr ""

#: ../../pep-0255.txt:258
msgid ""
"As noted earlier, ``yield`` is not allowed in the ``try`` clause of a "
"``try/finally`` construct.  A consequence is that generators should "
"allocate critical resources with great care.  There is no restriction on "
"``yield`` otherwise appearing in ``finally`` clauses, ``except`` clauses,"
" or in the ``try`` clause of a ``try/except`` construct::"
msgstr ""

#: ../../pep-0255.txt:292
msgid "Example"
msgstr ""

#: ../../pep-0255.txt:360
msgid "Both output blocks display::"
msgstr ""

#: ../../pep-0255.txt:366
msgid "Q & A"
msgstr ""

#: ../../pep-0255.txt:369
msgid "Why not a new keyword instead of reusing ``def``?"
msgstr ""

#: ../../pep-0255.txt:371
msgid "See BDFL Pronouncements section below."
msgstr ""

#: ../../pep-0255.txt:374
msgid "Why a new keyword for ``yield``?  Why not a builtin function instead?"
msgstr ""

#: ../../pep-0255.txt:376
msgid ""
"Control flow is much better expressed via keyword in Python, and yield is"
" a control construct.  It's also believed that efficient implementation "
"in Jython requires that the compiler be able to determine potential "
"suspension points at compile-time, and a new keyword makes that easy.  "
"The CPython reference implementation also exploits it heavily, to detect "
"which functions *are* generator-functions (although a new keyword in "
"place of ``def`` would solve that for CPython -- but people asking the "
"\"why a new keyword?\" question don't want any new keyword)."
msgstr ""

#: ../../pep-0255.txt:386
msgid "Then why not some other special syntax without a new keyword?"
msgstr ""

#: ../../pep-0255.txt:388
msgid "For example, one of these instead of ``yield 3``::"
msgstr ""

#: ../../pep-0255.txt:402
msgid ""
"Did I miss one <wink>?  Out of hundreds of messages, I counted three "
"suggesting such an alternative, and extracted the above from them. It "
"would be nice not to need a new keyword, but nicer to make ``yield`` very"
" clear -- I don't want to have to *deduce* that a yield is occurring from"
" making sense of a previously senseless sequence of keywords or "
"operators.  Still, if this attracts enough interest, proponents should "
"settle on a single consensus suggestion, and Guido will Pronounce on it."
msgstr ""

#: ../../pep-0255.txt:411
msgid ""
"Why allow ``return`` at all?  Why not force termination to be spelled "
"``raise StopIteration``?"
msgstr ""

#: ../../pep-0255.txt:413
msgid ""
"The mechanics of ``StopIteration`` are low-level details, much like the "
"mechanics of ``IndexError`` in Python 2.1:  the implementation needs to "
"do *something* well-defined under the covers, and Python exposes these "
"mechanisms for advanced users.  That's not an argument for forcing "
"everyone to work at that level, though.  ``return`` means \"I'm done\" in"
" any kind of function, and that's easy to explain and to use. Note that "
"``return`` isn't always equivalent to ``raise StopIteration`` in "
"try/except construct, either (see the \"Specification: Return\" section)."
msgstr ""

#: ../../pep-0255.txt:423
msgid "Then why not allow an expression on ``return`` too?"
msgstr ""

#: ../../pep-0255.txt:425
msgid ""
"Perhaps we will someday.  In Icon, ``return expr`` means both \"I'm "
"done\", and \"but I have one final useful value to return too, and this "
"is it\".  At the start, and in the absence of compelling uses for "
"``return expr``, it's simply cleaner to use ``yield`` exclusively for "
"delivering values."
msgstr ""

#: ../../pep-0255.txt:432
msgid "BDFL Pronouncements"
msgstr ""

#: ../../pep-0255.txt:435
msgid "Issue"
msgstr ""

#: ../../pep-0255.txt:437
msgid ""
"Introduce another new keyword (say, ``gen`` or ``generator``) in place of"
" ``def``, or otherwise alter the syntax, to distinguish generator-"
"functions from non-generator functions."
msgstr ""

#: ../../pep-0255.txt:442
msgid "Con"
msgstr ""

#: ../../pep-0255.txt:444
msgid ""
"In practice (how you think about them), generators *are* functions, but "
"with the twist that they're resumable.  The mechanics of how they're set "
"up is a comparatively minor technical issue, and introducing a new "
"keyword would unhelpfully overemphasize the mechanics of how generators "
"get started (a vital but tiny part of a generator's life)."
msgstr ""

#: ../../pep-0255.txt:451
msgid "Pro"
msgstr ""

#: ../../pep-0255.txt:453
msgid ""
"In reality (how you think about them), generator-functions are actually "
"factory functions that produce generator-iterators as if by magic.  In "
"this respect they're radically different from non-generator functions, "
"acting more like a constructor than a function, so reusing ``def`` is at "
"best confusing. A ``yield`` statement buried in the body is not enough "
"warning that the semantics are so different."
msgstr ""

#: ../../pep-0255.txt:461
msgid "BDFL"
msgstr ""

#: ../../pep-0255.txt:463
msgid ""
"``def`` it stays.  No argument on either side is totally convincing, so I"
" have consulted my language designer's intuition.  It tells me that the "
"syntax proposed in the PEP is exactly right - not too hot, not too cold."
"  But, like the Oracle at Delphi in Greek mythology, it doesn't tell me "
"why, so I don't have a rebuttal for the arguments against the PEP syntax."
"  The best I can come up with (apart from agreeing with the rebuttals ..."
" already made) is \"FUD\". If this had been part of the language from day"
" one, I very much doubt it would have made Andrew Kuchling's \"Python "
"Warts\" page."
msgstr ""

#: ../../pep-0255.txt:474
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0255.txt:476
msgid ""
"The current implementation, in a preliminary state (no docs, but well "
"tested and solid), is part of Python's CVS development tree [9]_.  Using "
"this requires that you build Python from source."
msgstr ""

#: ../../pep-0255.txt:480
msgid "This was derived from an earlier patch by Neil Schemenauer [7]_."
msgstr ""

#: ../../pep-0255.txt:484
msgid "Footnotes and References"
msgstr ""

#: ../../pep-0255.txt:486
msgid ""
"PEP 234, Iterators, Yee, Van Rossum "
"http://www.python.org/dev/peps/pep-0234/"
msgstr ""

#: ../../pep-0255.txt:489
msgid "http://www.stackless.com/"
msgstr ""

#: ../../pep-0255.txt:491
msgid ""
"PEP 219, Stackless Python, McMillan "
"http://www.python.org/dev/peps/pep-0219/"
msgstr ""

#: ../../pep-0255.txt:494
msgid ""
"\"Iteration Abstraction in Sather\" Murer, Omohundro, Stoutamire and "
"Szyperski http://www.icsi.berkeley.edu/~sather/Publications/toplas.html"
msgstr ""

#: ../../pep-0255.txt:498
msgid "http://www.cs.arizona.edu/icon/"
msgstr ""

#: ../../pep-0255.txt:500
msgid "The concept of iterators is described in PEP 234.  See [1] above."
msgstr ""

#: ../../pep-0255.txt:502
msgid "http://python.ca/nas/python/generator.diff"
msgstr ""

#: ../../pep-0255.txt:504
msgid ""
"PEP 236, Back to the __future__, Peters "
"http://www.python.org/dev/peps/pep-0236/"
msgstr ""

#: ../../pep-0255.txt:507
msgid ""
"To experiment with this implementation, check out Python from CVS "
"according to the instructions at http://sf.net/cvs/?group_id=5470 Note "
"that the std test ``Lib/test/test_generators.py`` contains many examples,"
" including all those in this PEP."
msgstr ""

#: ../../pep-0255.txt:514
msgid "Copyright"
msgstr ""

#: ../../pep-0255.txt:516
msgid "This document has been placed in the public domain."
msgstr ""

