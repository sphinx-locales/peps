# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-14 00:59+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0665.rst
msgid "PEP"
msgstr ""

#: ../../pep-0665.rst:1
msgid "665"
msgstr ""

#: ../../pep-0665.rst
msgid "Title"
msgstr ""

#: ../../pep-0665.rst:2
msgid ""
"A file format to list Python dependencies for reproducibility of an "
"application"
msgstr ""

#: ../../pep-0665.rst
msgid "Author"
msgstr ""

#: ../../pep-0665.rst:3
msgid ""
"Brett Cannon <brett@python.org>, Pradyun Gedam <pradyunsg@gmail.com>, "
"Tzu-ping Chung <uranusjr@gmail.com>"
msgstr ""

#: ../../pep-0665.rst
msgid "PEP-Delegate"
msgstr ""

#: ../../pep-0665.rst:6
msgid "Paul Moore <p.f.moore@gmail.com>"
msgstr ""

#: ../../pep-0665.rst
msgid "Discussions-To"
msgstr ""

#: ../../pep-0665.rst:7
msgid "https://discuss.python.org/t/9911"
msgstr ""

#: ../../pep-0665.rst
msgid "Status"
msgstr ""

#: ../../pep-0665.rst:8
msgid "Draft"
msgstr ""

#: ../../pep-0665.rst
msgid "Type"
msgstr ""

#: ../../pep-0665.rst:9
msgid "Standards Track"
msgstr ""

#: ../../pep-0665.rst
msgid "Created"
msgstr ""

#: ../../pep-0665.rst:11
msgid "29-Jul-2021"
msgstr ""

#: ../../pep-0665.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0665.rst:12
msgid "29-Jul-2021, 03-Nov-2021"
msgstr ""

#: ../../pep-0665.rst
msgid "Resolution"
msgstr ""

#: ../../pep-0665.rst:17
msgid "Abstract"
msgstr ""

#: ../../pep-0665.rst:19
msgid ""
"This PEP specifies a file format to specify the list of Python package "
"installation requirements for an application, and the relation between "
"the specified requirements. The list of requirements is considered "
"exhaustive for the installation target, and thus not requiring any "
"information beyond the platform being installed for, and the file itself."
" The file format is flexible enough to allow installing the requirements "
"across different platforms, which guarantees reproducibility on multiple "
"platforms from the same file."
msgstr ""

#: ../../pep-0665.rst:30
msgid "Terminology"
msgstr ""

#: ../../pep-0665.rst:32
msgid ""
"There are several terms whose definition must be agreed upon in order to "
"facilitate a discussion on the topic of this PEP."
msgstr ""

#: ../../pep-0665.rst:35
msgid ""
"A *package* is something you install as a dependency and use via the "
"import system. The packages on PyPI are an example of this."
msgstr ""

#: ../../pep-0665.rst:38
msgid ""
"An *application* or *app* is an end product that other external code does"
" not directly rely on via the import system (i.e. they are standalone). "
"Desktop applications, command-line tools, etc. are examples."
msgstr ""

#: ../../pep-0665.rst:43
msgid ""
"A *lock file* records the packages that are to be installed for an app. "
"Traditionally, the exact version of the package to be installed is "
"specified by a lock file, but all specified packages are not always "
"installed on a given platform (according a filtering logic described in a"
" later section), which enables the lock file to describe reproducibility "
"across multiple platforms. Examples of this are ``package-lock.json`` "
"from npm_, ``Poetry.lock`` from Poetry, etc."
msgstr ""

#: ../../pep-0665.rst:51
msgid ""
"*Locking* is the act of taking the input of the packages an app depends "
"on and producting a lock file from that."
msgstr ""

#: ../../pep-0665.rst:54
msgid "A *locker* is a tool which produces a lock file."
msgstr ""

#: ../../pep-0665.rst:56
msgid ""
"An *installer* consumes a lock file to install what the lock file "
"specifies."
msgstr ""

#: ../../pep-0665.rst:62
msgid "Motivation"
msgstr ""

#: ../../pep-0665.rst:64
msgid ""
"Applications want reproducible installs for a few reasons (we are not "
"worrying about package development, integration into larger systems that "
"would handle locking dependencies external to the Python application, or "
"other situations where *flexible* installation requirements are desired "
"over strict, reproducible installations)."
msgstr ""

#: ../../pep-0665.rst:70
msgid ""
"One, reproducibility eases development. When you and your fellow "
"developers all end up with the same files on a specific platform, you "
"make sure you are all developing towards the same experience for the "
"application. You also want your users to install the same files as you "
"expect to guarantee the experience is the same as you developed for them."
msgstr ""

#: ../../pep-0665.rst:77
msgid ""
"Two, you want to be able to reproduce what gets installed across multiple"
" platforms. Thanks to Python's portability across operating systems, "
"CPUs, etc., it is very easy and often desirable to create applications "
"that are not restricted to a single platform. Thus, you want to be "
"flexible enough to allow for differences in your package dependencies "
"between platforms, while still having consistency and reproducibility on "
"any one specific platform."
msgstr ""

#: ../../pep-0665.rst:85
msgid ""
"Three, reproducibility is more secure. When you control exactly what "
"files are installed, you can make sure no malicious actor is attempting "
"to slip nefarious code into your application (i.e. some supply chain "
"attacks). By making a lock file which always leads to reproducible "
"installs, we can avoid certain risks entirely."
msgstr ""

#: ../../pep-0665.rst:91
msgid ""
"This PEP proposes a standard for a lock file, as the current solutions "
"don't meet the outlined goals. Today, the closest we come to a lock file "
"standard is the `requirements file format`_ from pip. Unfortunately, that"
" format does not lead to inherently reproducible installs (it requires "
"optional features both in the requirements file and the installer itself,"
" to be discussed later)."
msgstr ""

#: ../../pep-0665.rst:98
msgid ""
"The community itself has also shown a need for lock files based on the "
"fact that multiple tools have independently created their own lock file "
"formats:"
msgstr ""

#: ../../pep-0665.rst:102
msgid "PDM_"
msgstr ""

#: ../../pep-0665.rst:103
msgid "`pip-tools`_"
msgstr ""

#: ../../pep-0665.rst:104
msgid "Pipenv_"
msgstr ""

#: ../../pep-0665.rst:105
msgid "Poetry_"
msgstr ""

#: ../../pep-0665.rst:106
msgid "Pyflow_"
msgstr ""

#: ../../pep-0665.rst:108
msgid ""
"Unfortunately, those tools all use differing lock file formats. This "
"means tooling around these tools much be unique. This impacts tooling "
"such as code editors and hosting providers, which want to be as flexible "
"as possible when it comes to accepting a user's application code, but "
"also have a limit as to how much development resource they can spend to "
"add support for yet another lock file format. A standardized format would"
" allow tools to focus their work on a single target, and make sure that "
"workflow decisions made by developers outside of the lock file format are"
" of no concern to e.g. hosting providers."
msgstr ""

#: ../../pep-0665.rst:119
msgid ""
"Other programming language communities have also shown the usefulness of "
"lock files by developing their own solution to this problem. Some of "
"those communities include:"
msgstr ""

#: ../../pep-0665.rst:123
msgid "Dart_"
msgstr ""

#: ../../pep-0665.rst:124
msgid "npm_/Node"
msgstr ""

#: ../../pep-0665.rst:125
msgid "Go"
msgstr ""

#: ../../pep-0665.rst:126
msgid "Rust_"
msgstr ""

#: ../../pep-0665.rst:128
msgid ""
"The trend in programming languages in the past decade seems to have been "
"toward providing a lock file solution."
msgstr ""

#: ../../pep-0665.rst:134
msgid "Rationale"
msgstr ""

#: ../../pep-0665.rst:138
msgid "File Format"
msgstr ""

#: ../../pep-0665.rst:140
msgid ""
"We wanted the file format to be easy to read as a diff when auditing a "
"change to the lock file. As such, and thanks to PEP 518 and "
"``pyproject.toml``, we decided to go with the TOML_ file format."
msgstr ""

#: ../../pep-0665.rst:147
msgid "Secure by Design"
msgstr ""

#: ../../pep-0665.rst:149
msgid ""
"Viewing the `requirements file format`_ as the closest we have to a lock "
"file standard, there are a few issues with the file format when it comes "
"to security. First is that the file format simply does not require you "
"specify the exact version of a package. This is why tools like `pip-"
"tools`_ exist to help manage that for the user."
msgstr ""

#: ../../pep-0665.rst:155
msgid ""
"Second, you must opt into specifying what files may be installed by using"
" the ``--hash`` argument for a specific dependency. This is also optional"
" with pip-tools as it requires specifying the ``--generate-hashes`` CLI "
"argument."
msgstr ""

#: ../../pep-0665.rst:160
msgid ""
"Third, even when you control what files may be installed, it does not "
"prevent other packages from being installed. If a dependency is not "
"listed in the requirements file, pip will happily go searching for a file"
" to meet that need, unless you specify ``--no-deps`` as an argument."
msgstr ""

#: ../../pep-0665.rst:166
msgid ""
"Fourth, the format allows for installing a `source distribution file`_ "
"(aka \"sdist\"). By its very nature, installing an sdist may imply "
"executing arbitrary Python code, meaning that there is no control over "
"what files may be installed. Only by specifying ``--only-binary :all:`` "
"can you guarantee pip to only use a `wheel file`_ for each package."
msgstr ""

#: ../../pep-0665.rst:173
msgid ""
"To recap, in order for a requirements file to be as secure as what is "
"being proposed, a user should always do the following steps:"
msgstr ""

#: ../../pep-0665.rst:176
msgid "Use pip-tools and its command ``pip-compile --generate-hashes``"
msgstr ""

#: ../../pep-0665.rst:177
msgid ""
"Install the requirements file using ``pip install --no-deps --only-binary"
" :all:``"
msgstr ""

#: ../../pep-0665.rst:180
msgid ""
"Critically, all of those flags, and both specificity and exhaustion of "
"what to install that pip-tools provides, are optional."
msgstr ""

#: ../../pep-0665.rst:183
msgid ""
"As such, the proposal raised in this PEP is secure by design to combat "
"some supply chain attacks. Hashes for files which would be used to "
"install from are **required**. You can **only** install from wheels to "
"unambiguously define what files will be placed in the file system. "
"Installers **must** have an unambiguous installation from a lock file for"
" a given platform."
msgstr ""

#: ../../pep-0665.rst:193
msgid "Cross-Platform"
msgstr ""

#: ../../pep-0665.rst:195
msgid ""
"Various projects which already have a lock file, like PDM_ and Poetry_, "
"provide a lock file which is *cross-platform*. This allows for a single "
"lock file to work on multiple platforms while still leading to exact same"
" top-level requirements to be installed everywhere while the installation"
" being consistent/unambiguous on each platform."
msgstr ""

#: ../../pep-0665.rst:202
msgid ""
"As to why this is useful, let's use an example involving PyWeek_ (a week-"
"long game development competition). We assume you are developing on "
"Linux, while someone you choose to partner with is using macOS. Now "
"assume the judges are using Windows. How do you make sure everyone is "
"using the same top-level dependencies, while allowing for any platform-"
"specific requirements (e.g. a package requires a helper package under "
"Windows)?"
msgstr ""

#: ../../pep-0665.rst:210
msgid ""
"With a cross-platform lock file, you can make sure that the key "
"requirements are met consistently across all platforms. You can then also"
" make sure that all users on the same platform get the same reproducible "
"installation."
msgstr ""

#: ../../pep-0665.rst:218
msgid "Simple Installer"
msgstr ""

#: ../../pep-0665.rst:220
msgid ""
"The separation of concerns between a locker and an installer allows for "
"an installer to have a much simpler operation to perform. As such, it not"
" only allows for installers to be easier to write, but facilitates in "
"making sure installers create unambiguous, reproducible installations."
msgstr ""

#: ../../pep-0665.rst:226
msgid ""
"The installer can also expend less computation/energy in creating the "
"installation. This is beneficial not only for faster installs, but also "
"from an energy consumption perspective, as installers are expected to be "
"run more often than lockers."
msgstr ""

#: ../../pep-0665.rst:231
msgid ""
"This has led to a design where the locker must do more work upfront to "
"benefit installers. It also means the complexity of package dependencies "
"is simpler and easier to comprehend to avoid ambiguity."
msgstr ""

#: ../../pep-0665.rst:238
msgid "Specification"
msgstr ""

#: ../../pep-0665.rst:242
msgid "Details"
msgstr ""

#: ../../pep-0665.rst:244
msgid ""
"Lock files MUST use the TOML_ file format. This not only prevents the "
"need to have another file format in the Python packaging ecosystem, "
"thanks to its adoption by PEP 518 for ``pyproject.toml``, but also "
"assists in making lock files more human-readable."
msgstr ""

#: ../../pep-0665.rst:249
msgid ""
"Lock files MUST end their file names with ``.pylock.toml``. The ``.toml``"
" part unambiguously distinguishes the format of the file, and helps tools"
" like code editors support the file appropriately. The ``.pylock`` part "
"distinguishes the file from other TOML files the user has, to make logic "
"easier for tools to create functionalities specific to Python lock files,"
" instead of TOML files in general."
msgstr ""

#: ../../pep-0665.rst:256
msgid ""
"The following sections are the top-level keys of the TOML file data "
"format. Any field not listed as required is considered optional."
msgstr ""

#: ../../pep-0665.rst:261
msgid "``version``"
msgstr ""

#: ../../pep-0665.rst:263 ../../pep-0665.rst:287 ../../pep-0665.rst:347
#: ../../pep-0665.rst:404
msgid "This field is **required**."
msgstr ""

#: ../../pep-0665.rst:265
msgid ""
"The version of the lock file being used. The key MUST be a string "
"consisting of a number that follows the same formatting as the "
"``Metadata-Version`` key in the `core metadata spec`_. The value MUST be "
"set to ``\"1.0\"`` until a future PEP allows for a different value. The "
"introduction of a new *optional* key SHOULD increase the minor version. "
"The introduction of a new required key or changing the format MUST "
"increase the major version. How to handle other scenarios is left as a "
"per-PEP decision."
msgstr ""

#: ../../pep-0665.rst:274
msgid ""
"Installers MUST warn the user if the lock file specifies a version whose "
"major version is support but whose minor version is "
"unsupported/unrecognized (e.g. the installer supports ``\"1.0\"``, but "
"the lock file specifies ``\"1.1\"``)."
msgstr ""

#: ../../pep-0665.rst:279
msgid ""
"Installers MUST raise an error if the lock file specifies a major version"
" which is unsupported (e.g. the installer supports ``\"1.9\"`` but the "
"lock file specifies ``\"2.0\"``)."
msgstr ""

#: ../../pep-0665.rst:285
msgid "``created-at``"
msgstr ""

#: ../../pep-0665.rst:289
msgid ""
"The timestamp for when the lock file was generated (using TOML's native "
"timestamp type). It MUST be recorded using the UTC time zone to avoid "
"ambiguity."
msgstr ""

#: ../../pep-0665.rst:293
msgid ""
"If the SOURCE_DATE_EPOCH_ environment variable is set, it MUST be used as"
" the timestamp by the locker. This faciliates reproducibility of the lock"
" file itself."
msgstr ""

#: ../../pep-0665.rst:300
msgid "``[tool]``"
msgstr ""

#: ../../pep-0665.rst:302
msgid ""
"Tools may create their own sub-tables under the ``tool`` table. The rules"
" for this table match those for ``pyproject.toml`` and its ``[tool]`` "
"table from the `build system declaration spec`_."
msgstr ""

#: ../../pep-0665.rst:308
msgid "``[metadata]``"
msgstr ""

#: ../../pep-0665.rst:310 ../../pep-0665.rst:427
msgid "This table is **required**."
msgstr ""

#: ../../pep-0665.rst:312
msgid "A table containing data applying to the overall lock file."
msgstr ""

#: ../../pep-0665.rst:316
msgid "``metadata.marker``"
msgstr ""

#: ../../pep-0665.rst:318
msgid ""
"A key storing a string containing an environment marker as specified in "
"the `dependency specifier spec`_."
msgstr ""

#: ../../pep-0665.rst:322
msgid ""
"The locker MAY specify an environment marker which specifies any "
"restrictions the lock file was generated under."
msgstr ""

#: ../../pep-0665.rst:325
msgid ""
"If the installer is installing for an environment which does not satisfy "
"the specified environment marker, the installer MUST raise an error as "
"the lock file does not support the environment."
msgstr ""

#: ../../pep-0665.rst:331
msgid "``metadata.tag``"
msgstr ""

#: ../../pep-0665.rst:333
msgid ""
"A key storing a string specifying `platform compatibility tags`_ (i.e. "
"wheel tags). The tag MAY be a compressed tag set."
msgstr ""

#: ../../pep-0665.rst:336
msgid ""
"The locker MAY specify a tag (set) which specify which platform(s) the "
"lock file supports."
msgstr ""

#: ../../pep-0665.rst:339
msgid ""
"If the installer is installing for an environment which does not satisfy "
"the specified tag (set), the installer MUST raise an error as the lock "
"file does not support the environment."
msgstr ""

#: ../../pep-0665.rst:345
msgid "``metadata.requires``"
msgstr ""

#: ../../pep-0665.rst:349
msgid ""
"An array of strings following the `dependency specifier spec`_. This "
"array represents the top-level package dependencies of the lock file and "
"thus the root of the dependency graph."
msgstr ""

#: ../../pep-0665.rst:355
msgid "``metadata.requires-python``"
msgstr ""

#: ../../pep-0665.rst:357
msgid ""
"A string specifying the support version(s) of Python for this lock file. "
"It follows the same format as that specified for the ``Requires-Python`` "
"field in the `core metadata spec`_."
msgstr ""

#: ../../pep-0665.rst:363
msgid "``[[package._name_._version_]]``"
msgstr ""

#: ../../pep-0665.rst:365
msgid "This array is **required**."
msgstr ""

#: ../../pep-0665.rst:367
msgid ""
"An array per package and version containing details for the potential "
"(wheel) files to install (as represented by ``_name_`` and ``_version_``,"
" respectively)."
msgstr ""

#: ../../pep-0665.rst:371
msgid ""
"Lockers must MUST normalize a project's name according to the `simple "
"repository API`_. If extras are specified as part of the project to "
"install, the extras are to be included in the key name and are to be "
"sorted in lexicographic order."
msgstr ""

#: ../../pep-0665.rst:376
msgid "Within the file, the tables for the projects SHOULD be sorted by:"
msgstr ""

#: ../../pep-0665.rst:378
msgid "Project/key name in lexicographic order"
msgstr ""

#: ../../pep-0665.rst:379
msgid ""
"Package version, newest/highest to older/lowest according to the `version"
" specifiers spec`_"
msgstr ""

#: ../../pep-0665.rst:381
msgid "Optional dependencies (extras) via lexicographic order"
msgstr ""

#: ../../pep-0665.rst:382
msgid "File name based on the ``filename`` or ``url`` field (discussed below)"
msgstr ""

#: ../../pep-0665.rst:385
msgid "All of this is to help minimize diff changes between tool executions."
msgstr ""

#: ../../pep-0665.rst:389
msgid "``package._name_._version_.url``"
msgstr ""

#: ../../pep-0665.rst:391
msgid "A string representing a URL where to get the file."
msgstr ""

#: ../../pep-0665.rst:393
msgid ""
"The installer MAY support any schemes it wants for URLs (e.g. ``file:`` "
"as well as ``https:``)."
msgstr ""

#: ../../pep-0665.rst:396
msgid ""
"An installer MAY choose to not use the URL to retrieve a file if a file "
"matching the specified hash can be found using some alternative means "
"(e.g. on the file system in a cache directory)."
msgstr ""

#: ../../pep-0665.rst:402
msgid "``package._name_._version_.filename``"
msgstr ""

#: ../../pep-0665.rst:406
msgid ""
"A string representing the name of the file as represented by an entry in "
"the array. This field is required to simplify installers as the file name"
" is required to resolve wheel tags derived from the file name. It also "
"guarantees that the association of the array entry to the file it is "
"meant for is always clear."
msgstr ""

#: ../../pep-0665.rst:413
msgid "``package._name_._version_.direct``"
msgstr ""

#: ../../pep-0665.rst:415
msgid ""
"A boolean representing whether an installer should consider the project "
"installed \"directly\" as specified by the `direct URL origin of "
"installed distributions spec`_."
msgstr ""

#: ../../pep-0665.rst:419
msgid ""
"If the key is true, then the installer MUST follow the `direct URL origin"
" of installed distributions spec`_ for recording the installation as "
"\"direct\"."
msgstr ""

#: ../../pep-0665.rst:425
msgid "``[package._name_._version_.hashes]``"
msgstr ""

#: ../../pep-0665.rst:429
msgid ""
"A table with keys specifying hash algorithms and values as the hash for "
"the file represented by this entry in the ``package._name_._version_`` "
"table."
msgstr ""

#: ../../pep-0665.rst:433
msgid ""
"Lockers SHOULD list hashes in lexicographic order. This is to help "
"minimize diff sizes and the potential to overlook hash value changes."
msgstr ""

#: ../../pep-0665.rst:436
msgid ""
"An installer MUST only install a file which matches one of the specified "
"hashes."
msgstr ""

#: ../../pep-0665.rst:441
msgid "``package._name_._version_.requires``"
msgstr ""

#: ../../pep-0665.rst:443
msgid ""
"An array of strings following the `dependency specifier spec`_ which "
"represent the dependencies of this file."
msgstr ""

#: ../../pep-0665.rst:448
msgid "``package._name_._version_.requires-python``"
msgstr ""

#: ../../pep-0665.rst:450
msgid ""
"A string specifying the support version(s) of Python for this file. It "
"follows the same format as that specified for the ``Requires-Python`` "
"field in the `core metadata spec`_."
msgstr ""

#: ../../pep-0665.rst:457
msgid "Example"
msgstr ""

#: ../../pep-0665.rst:498
msgid "Expectations for Lockers"
msgstr ""

#: ../../pep-0665.rst:500
msgid ""
"Lockers MUST create lock files for which a topological sort of the "
"packages which qualify for installation on the specified platform results"
" in a graph for which only a single version of any package is possible "
"and there is at least one compatible file to install for those packages. "
"This equates to a lock file that which is acceptable based on "
"``metadata.marker``, ``metadata.tag``, and ``metadata.requires-python`` "
"will have a list of package versions after evaluating environment markers"
" and eliminating unsupported files for which the only decision the "
"installer will need to make is which file to use for the package (which "
"is outlined below)."
msgstr ""

#: ../../pep-0665.rst:511
msgid ""
"This means that lockers are expected to utilize ``metadata.marker``, "
"``metadata.tag``, and ``metadata.requires-python`` as appropriate as well"
" as environment markers specified via ``requires`` and Python version "
"requirements via ``requires-python`` to enforce this result for "
"installers. Put another way, the information used in the lock file is not"
" expected to be pristine/raw from the locker's input and instead is to be"
" changed as necessary to the benefit of the locker's goals."
msgstr ""

#: ../../pep-0665.rst:523
msgid "Expectations for Installers"
msgstr ""

#: ../../pep-0665.rst:525
msgid "The expected algorithm for resolving what to install is:"
msgstr ""

#: ../../pep-0665.rst:527
msgid ""
"Construct a dependency graph based on the data in the lock file with "
"``metadata.requires`` as the starting/root point."
msgstr ""

#: ../../pep-0665.rst:529
msgid ""
"Eliminate all (wheel) files that are unsupported by the specified "
"platform."
msgstr ""

#: ../../pep-0665.rst:531
msgid ""
"Eliminate all irrelevant edges between packages based on marker "
"evaluation."
msgstr ""

#: ../../pep-0665.rst:533
msgid ""
"Raise an error if a package version is still reachable from the root of "
"the dependency graph but lacks any compatible (wheel) file."
msgstr ""

#: ../../pep-0665.rst:536
msgid ""
"Verify that all packages left only have one version to install, raising "
"an error otherwise."
msgstr ""

#: ../../pep-0665.rst:538
msgid "Install the best-fitting wheel file for each package which remains."
msgstr ""

#: ../../pep-0665.rst:541
msgid "What constitues the \"best-fitting wheel file\" is an open issue."
msgstr ""

#: ../../pep-0665.rst:543
msgid ""
"Installers MUST support installing into an empty environment. Installers "
"MAY support installing into an environment that already conatins "
"installed packages (and whatever that would entail)."
msgstr ""

#: ../../pep-0665.rst:550
msgid "(Potential) Tool Support"
msgstr ""

#: ../../pep-0665.rst:552
msgid ""
"The pip_ team has `said <https://github.com/pypa/pip/issues/10636>`__ "
"they are interested in supporting this PEP if accepted. The current "
"proposal for pip may even `supplant the need <https://github.com/jazzband"
"/pip-tools/issues/1526#issuecomment-961883367>`__ for `pip-tools`_."
msgstr ""

#: ../../pep-0665.rst:558
msgid ""
"PDM_ has also said they would `support the PEP <https://github.com/pdm-"
"project/pdm/issues/718>`__ if accepted."
msgstr ""

#: ../../pep-0665.rst:562
msgid ""
"Pyflow_ has said they `\"like the idea\" <https://github.com/David-"
"OConnor/pyflow/issues/153#issuecomment-962482058>`__ of the PEP."
msgstr ""

#: ../../pep-0665.rst:569
msgid "Backwards Compatibility"
msgstr ""

#: ../../pep-0665.rst:571
msgid ""
"As there is no pre-existing specification regarding lock files, there are"
" no explicit backwards compatibility concerns."
msgstr ""

#: ../../pep-0665.rst:574
msgid ""
"As for pre-existing tools that have their own lock file, some updating "
"will be required. Most document the lock file name, but not its contents."
" For projects which do not commit their lock file to version control, "
"they will need to update the equivalent of their ``.gitignore`` file. For"
" projects that do commit their lock file to version control, what file(s)"
" get committed will need an update."
msgstr ""

#: ../../pep-0665.rst:581
msgid ""
"For projects which do document their lock file format like pipenv_, they "
"will very likely need a major version release which changes the lock file"
" format."
msgstr ""

#: ../../pep-0665.rst:585
msgid ""
"Specifically for Poetry_, it has an `export command <https://python-"
"poetry.org/docs/cli/#export>`_ which should allow Poetry to support this "
"lock file format even if the project chooses not to adopt this PEP as "
"Poetry's primary lock file format."
msgstr ""

#: ../../pep-0665.rst:594
msgid "Security Implications"
msgstr ""

#: ../../pep-0665.rst:596
msgid ""
"A lock file should not introduce security issues but instead help solve "
"them. By requiring the recording of hashes for files, a lock file is able"
" to help prevent tampering with code since the hash details were "
"recorded. A lock file also helps prevent unexpected package updates being"
" installed which may be malicious."
msgstr ""

#: ../../pep-0665.rst:605
msgid "How to Teach This"
msgstr ""

#: ../../pep-0665.rst:607
msgid ""
"Teaching of this PEP will very much be dependent on the lockers and "
"installers being used for day-to-day use. Conceptually, though, users "
"could be taught that a lock file specifies what should be installed for a"
" project to work. The benefits of consistency and security should be "
"emphasized to help users realize why they should care about lock files."
msgstr ""

#: ../../pep-0665.rst:617
msgid "Reference Implementation"
msgstr ""

#: ../../pep-0665.rst:619
msgid ""
"No proof-of-concept or reference implementation currently exists. An "
"example locker and installer will be provided before this PEP is fully "
"accepted (although this is not a necessarily a requirement for "
"conditional acceptance)."
msgstr ""

#: ../../pep-0665.rst:627
msgid "Rejected Ideas"
msgstr ""

#: ../../pep-0665.rst:631
msgid "File Formats Other Than TOML"
msgstr ""

#: ../../pep-0665.rst:633
msgid "JSON_ was briefly considered, but due to:"
msgstr ""

#: ../../pep-0665.rst:635
msgid "TOML already being used for ``pyproject.toml``"
msgstr ""

#: ../../pep-0665.rst:636
msgid "TOML being more human-readable"
msgstr ""

#: ../../pep-0665.rst:637
msgid "TOML leading to better diffs"
msgstr ""

#: ../../pep-0665.rst:639
msgid ""
"the decision was made to go with TOML. There was some concern over "
"Python's standard library lacking a TOML parser, but most packaging tools"
" already use a TOML parser thanks to ``pyproject.toml`` so this issue did"
" not seem to be a showstopper. Some have also argued against this concern"
" in the past by the fact that if packaging tools abhor installing "
"dependencies and feel they can't vendor a package then the packaging "
"ecosystem has much bigger issues to rectify than needing to depend on a "
"third-party TOML parser."
msgstr ""

#: ../../pep-0665.rst:651
msgid "Alternative Naming Schemes"
msgstr ""

#: ../../pep-0665.rst:653
msgid ""
"Specifying a directory to install file to was considered, but ultimately "
"rejected due to people's distaste for the idea."
msgstr ""

#: ../../pep-0665.rst:656
msgid ""
"It was also suggested to not have a special file name suffix, but it was "
"decided that hurt discoverability by tools too much."
msgstr ""

#: ../../pep-0665.rst:662
msgid "Supporting a Single Lock File"
msgstr ""

#: ../../pep-0665.rst:664
msgid ""
"At one point the idea of only supporting single lock file which contained"
" all possible lock information was considered. But it quickly became "
"apparent that trying to devise a data format which could encompass both a"
" lock file format which could support multiple environments as well as "
"strict lock outcomes for reproducible builds would become quite complex "
"and cumbersome."
msgstr ""

#: ../../pep-0665.rst:671
msgid ""
"The idea of supporting a directory of lock files as well as a single lock"
" file named ``pyproject-lock.toml`` was also considered. But any possible"
" simplicity from skipping the directory in the case of a single lock file"
" seemed unnecessary. Trying to define appropriate logic for what should "
"be the ``pyproject-lock.toml`` file and what should go into ``pyproject-"
"lock.d`` seemed unnecessarily complicated."
msgstr ""

#: ../../pep-0665.rst:681
msgid "Using a Flat List Instead of a Dependency Graph"
msgstr ""

#: ../../pep-0665.rst:683
msgid ""
"The first version of this PEP proposed that the lock file have no concept"
" of a dependency graph. Instead, the lock file would list exactly what "
"should be installed for a specific platform such that installers did not "
"have to make any decisions about *what* to install, only validating that "
"the lock file would work for the target platform."
msgstr ""

#: ../../pep-0665.rst:689
msgid ""
"This idea was eventually rejected due to the number of combinations of "
"potential PEP 508 environment markers. The decision was made that trying "
"to have lockers generate all possible combinations as individual lock "
"files when a project wants to be cross-platform would be too much."
msgstr ""

#: ../../pep-0665.rst:698
msgid "Use Wheel Tags in the File Name"
msgstr ""

#: ../../pep-0665.rst:700
msgid ""
"Instead of having the ``metadata.tag`` field there was a suggestion of "
"encoding the tags into the file name. But due to the addition of the "
"``metadata.marker`` field and what to do when no tags were needed, the "
"idea was dropped."
msgstr ""

#: ../../pep-0665.rst:708
msgid "Alternative Names for ``requires``"
msgstr ""

#: ../../pep-0665.rst:710
msgid ""
"Some other names for what became ``requires`` were ``installs``, "
"``needs``, and ``dependencies``. Initially this PEP chose ``needs`` after"
" asking a Python beginner which term they preferred. But based on "
"feedback on an earlier draft of this PEP, ``requires`` was chosen as the "
"term."
msgstr ""

#: ../../pep-0665.rst:719
msgid "Accepting PEP 650"
msgstr ""

#: ../../pep-0665.rst:721
msgid ""
"PEP 650 was an earlier attempt at trying to tackle this problem by "
"specifying an API for installers instead of standardizing on a lock file "
"format (ala PEP 517). The `initial response "
"<https://discuss.python.org/t/pep-650-specifying-installer-requirements-"
"for-python-projects/6657/>`__ to PEP 650 could be considered "
"mild/lukewarm. People seemed to be consistently confused over which tools"
" should provide what functionality to implement the PEP. It also "
"potentially incurred more overhead as it would require executing Python "
"APIs to perform any actions involving packaging."
msgstr ""

#: ../../pep-0665.rst:731
msgid ""
"This PEP chooses to standardize around an artifact instead of an API (ala"
" PEP 621). This would allow for more tool integrations as it removes the "
"need to specifically use Python to do things such as create a lock file, "
"update it, or even install packages listed in a lock file. It also allows"
" for easier introspection by forcing dependency graph details to be "
"written in a human-readable format. It also allows for easier sharing of "
"knowledge by standardizing what people need to know more (e.g. tutorials "
"become more portable between tools when it comes to understanding the "
"artifact they produce). It's also simply the approach other language "
"communities have taken and seem to be happy with."
msgstr ""

#: ../../pep-0665.rst:746
msgid "Specifying Requirements per Package Instead of per File"
msgstr ""

#: ../../pep-0665.rst:748
msgid ""
"An earlier draft of this PEP specified dependencies at the package level "
"instead of per (wheel) file. While this has traditionally been how "
"packaging systems work, it actually did not reflect accurately how things"
" are specified. As such, this PEP was subsequently updated to reflect the"
" granularity that dependencies can truly be specified at."
msgstr ""

#: ../../pep-0665.rst:758
msgid "Open Issues"
msgstr ""

#: ../../pep-0665.rst:763
msgid ""
"Allowing Source Distributions and Source Trees to be an Opt-In, Supported"
" File Format"
msgstr ""

#: ../../pep-0665.rst:765
msgid ""
"For security reproducibility reasons this PEP only considers supporting "
"installation from wheel files. Installing from either an sdist or source "
"tree requires arbitrary code execution during installation, unknown files"
" to be installed, and an unknown set of dependencies. Those issues all "
"run counter to guaranteeing users get the same files for the same "
"platform as well as making sure they are receiving the expected files."
msgstr ""

#: ../../pep-0665.rst:773
msgid ""
"To deal with this issue, people would need to build their own wheels from"
" sdists and cache them. Then the lockers would record the hashes of those"
" wheels and the installers would then be expected to use those wheels."
msgstr ""

#: ../../pep-0665.rst:778
msgid ""
"Another option is to allow sdists (and potentially source trees) be "
"listed as support file formats, but have them marked as insecure in the "
"lock file and require the installer force the user to opt into using "
"insecure file formats. Unfortunately because sdists which don't "
"necessarily follow version 2.2 of the `core metadata spec`_ for their "
"``PKG-INFO`` file will have unknown dependencies, breaking the guarantee "
"that results will be reproducible thanks to potential arbitrary "
"calculations of those dependencies. And even if an sdist did follow the "
"latest spec, they could still list their requirements as dynamic, still "
"making it impossible to statically know what should be installed. As "
"such, installers would either have to have a full resolver to handle "
"these dynamic cases or only sdists which follow version 2.2 of the core "
"metadata spec **and** statically specify their dependencies could be "
"listed. But at that point the project is probably capable of providing "
"wheels, making support for sdists that much less important/useful."
msgstr ""

#: ../../pep-0665.rst:798
msgid "Specify Where Lockers Gather Input"
msgstr ""

#: ../../pep-0665.rst:800
msgid ""
"This PEP currently does not specify how a locker gets its input. It could"
" be possible to support a subset of PEP 621 such that ``project.requires-"
"python`` and ``project.dependencies`` are read from ``pyproject.toml`` "
"and automatically used as input if provided. But this or some other "
"practice could also be left as something to grow organically in the "
"community and making that the standard at a later date."
msgstr ""

#: ../../pep-0665.rst:811
msgid "What is a \"best-fitting wheel file\"?"
msgstr ""

#: ../../pep-0665.rst:813
msgid ""
"The expected steps of installing a package much include decided which "
"wheel file to install as a package may have a universal wheel on top of "
"very specific wheels. But as `platform compatibility tags`_ do not "
"specify how to determine priority and there is no way to use environment "
"markers to specify an exact wheel, there's no defined way for an "
"installer to deterministically determine what wheel file to select."
msgstr ""

#: ../../pep-0665.rst:821
msgid ""
"There are two possible solutions. One is for the locker to specify a "
"ranking/priority order to the wheel files. That way the installer simply "
"sorts to the supported wheel files by that order and installs the the top"
" rated/ranked wheel file. This puts the priority order under the control "
"of the locker."
msgstr ""

#: ../../pep-0665.rst:827
msgid ""
"The other option is to specify in this PEP how to calculate the "
"priority/ranking of wheel files. This is currently tool-based and seems "
"to have been acceptable overall by the community, but having a "
"specification for this would probably still be welcome. It may be "
"somewhat disruptive, though, as it could change what files get installed "
"by tools which implement the ordering outside of the context of this PEP."
" And if this PEP gains traction, it is reasonable to assume that users "
"will expect the ordering to be consistent across tools."
msgstr ""

#: ../../pep-0665.rst:840
msgid "Acknowledgments"
msgstr ""

#: ../../pep-0665.rst:842
msgid ""
"Thanks to Frost Ming of PDM_ and SÃ©bastien Eustace of Poetry_ for "
"providing input around dynamic install-time resolution of PEP 508 "
"requirements."
msgstr ""

#: ../../pep-0665.rst:846
msgid ""
"Thanks to Kushal Das for making sure reproducible builds stayed a concern"
" for this PEP."
msgstr ""

#: ../../pep-0665.rst:849
msgid ""
"Thanks to Andrea McInnes for initially settling the bikeshedding and "
"choosing the paint colour of ``needs`` (at which point that caused people"
" to rally around the ``requires`` colour)."
msgstr ""

#: ../../pep-0665.rst:856
msgid "Copyright"
msgstr ""

#: ../../pep-0665.rst:858
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

#~ msgid ""
#~ "A file format to list Python "
#~ "dependencies for reproducibility of an "
#~ "application"
#~ msgstr ""

#~ msgid "Paul Moore <p.f.moore@gmail.com>"
#~ msgstr ""

#~ msgid "https://discuss.python.org/t/9911"
#~ msgstr ""

#~ msgid "29-Jul-2021, 03-Nov-2021"
#~ msgstr ""

#~ msgid ""
#~ "This PEP specifies a file format "
#~ "to specify the list of Python "
#~ "package installation requirements for an "
#~ "application, and the relation between "
#~ "the specified requirements. The list of"
#~ " requirements is considered exhaustive for"
#~ " the installation target, and thus "
#~ "not requiring any information beyond the"
#~ " platform being installed for, and "
#~ "the file itself. The file format "
#~ "is flexible enough to allow installing"
#~ " the requirements across different "
#~ "platforms, which guarantees reproducibility on"
#~ " multiple platforms from the same "
#~ "file."
#~ msgstr ""

#~ msgid "Terminology"
#~ msgstr ""

#~ msgid ""
#~ "There are several terms whose definition"
#~ " must be agreed upon in order "
#~ "to facilitate a discussion on the "
#~ "topic of this PEP."
#~ msgstr ""

#~ msgid ""
#~ "A *package* is something you install "
#~ "as a dependency and use via the"
#~ " import system. The packages on PyPI"
#~ " are an example of this."
#~ msgstr ""

#~ msgid ""
#~ "An *application* or *app* is an "
#~ "end product that other external code "
#~ "does not directly rely on via the"
#~ " import system (i.e. they are "
#~ "standalone). Desktop applications, command-"
#~ "line tools, etc. are examples."
#~ msgstr ""

#~ msgid ""
#~ "A *lock file* records the packages "
#~ "that are to be installed for an"
#~ " app. Traditionally, the exact version "
#~ "of the package to be installed is"
#~ " specified by a lock file, but "
#~ "all specified packages are not always"
#~ " installed on a given platform "
#~ "(according a filtering logic described "
#~ "in a later section), which enables "
#~ "the lock file to describe "
#~ "reproducibility across multiple platforms. "
#~ "Examples of this are ``package-"
#~ "lock.json`` from npm_, ``Poetry.lock`` from"
#~ " Poetry, etc."
#~ msgstr ""

#~ msgid ""
#~ "*Locking* is the act of taking the"
#~ " input of the packages an app "
#~ "depends on and producting a lock "
#~ "file from that."
#~ msgstr ""

#~ msgid "A *locker* is a tool which produces a lock file."
#~ msgstr ""

#~ msgid ""
#~ "An *installer* consumes a lock file "
#~ "to install what the lock file "
#~ "specifies."
#~ msgstr ""

#~ msgid ""
#~ "Applications want reproducible installs for"
#~ " a few reasons (we are not "
#~ "worrying about package development, "
#~ "integration into larger systems that "
#~ "would handle locking dependencies external "
#~ "to the Python application, or other "
#~ "situations where *flexible* installation "
#~ "requirements are desired over strict, "
#~ "reproducible installations)."
#~ msgstr ""

#~ msgid ""
#~ "One, reproducibility eases development. When"
#~ " you and your fellow developers all"
#~ " end up with the same files on"
#~ " a specific platform, you make sure"
#~ " you are all developing towards the"
#~ " same experience for the application. "
#~ "You also want your users to "
#~ "install the same files as you "
#~ "expect to guarantee the experience is"
#~ " the same as you developed for "
#~ "them."
#~ msgstr ""

#~ msgid ""
#~ "Two, you want to be able to "
#~ "reproduce what gets installed across "
#~ "multiple platforms. Thanks to Python's "
#~ "portability across operating systems, CPUs,"
#~ " etc., it is very easy and "
#~ "often desirable to create applications "
#~ "that are not restricted to a "
#~ "single platform. Thus, you want to "
#~ "be flexible enough to allow for "
#~ "differences in your package dependencies "
#~ "between platforms, while still having "
#~ "consistency and reproducibility on any "
#~ "one specific platform."
#~ msgstr ""

#~ msgid ""
#~ "Three, reproducibility is more secure. "
#~ "When you control exactly what files "
#~ "are installed, you can make sure "
#~ "no malicious actor is attempting to "
#~ "slip nefarious code into your "
#~ "application (i.e. some supply chain "
#~ "attacks). By making a lock file "
#~ "which always leads to reproducible "
#~ "installs, we can avoid certain risks "
#~ "entirely."
#~ msgstr ""

#~ msgid ""
#~ "This PEP proposes a standard for a"
#~ " lock file, as the current solutions"
#~ " don't meet the outlined goals. "
#~ "Today, the closest we come to a"
#~ " lock file standard is the "
#~ "`requirements file format`_ from pip. "
#~ "Unfortunately, that format does not lead"
#~ " to inherently reproducible installs (it"
#~ " requires optional features both in "
#~ "the requirements file and the installer"
#~ " itself, to be discussed later)."
#~ msgstr ""

#~ msgid ""
#~ "Unfortunately, those tools all use "
#~ "differing lock file formats. This means"
#~ " tooling around these tools much be"
#~ " unique. This impacts tooling such as"
#~ " code editors and hosting providers, "
#~ "which want to be as flexible as"
#~ " possible when it comes to accepting"
#~ " a user's application code, but also"
#~ " have a limit as to how much"
#~ " development resource they can spend "
#~ "to add support for yet another "
#~ "lock file format. A standardized format"
#~ " would allow tools to focus their "
#~ "work on a single target, and make"
#~ " sure that workflow decisions made by"
#~ " developers outside of the lock file"
#~ " format are of no concern to "
#~ "e.g. hosting providers."
#~ msgstr ""

#~ msgid "Go"
#~ msgstr ""

#~ msgid ""
#~ "The trend in programming languages in"
#~ " the past decade seems to have "
#~ "been toward providing a lock file "
#~ "solution."
#~ msgstr ""

#~ msgid "File Format"
#~ msgstr ""

#~ msgid ""
#~ "We wanted the file format to be"
#~ " easy to read as a diff when"
#~ " auditing a change to the lock "
#~ "file. As such, and thanks to PEP"
#~ " 518 and ``pyproject.toml``, we decided "
#~ "to go with the TOML_ file format."
#~ msgstr ""

#~ msgid "Secure by Design"
#~ msgstr ""

#~ msgid ""
#~ "Viewing the `requirements file format`_ "
#~ "as the closest we have to a "
#~ "lock file standard, there are a "
#~ "few issues with the file format "
#~ "when it comes to security. First "
#~ "is that the file format simply "
#~ "does not require you specify the "
#~ "exact version of a package. This "
#~ "is why tools like `pip-tools`_ "
#~ "exist to help manage that for the"
#~ " user."
#~ msgstr ""

#~ msgid ""
#~ "Second, you must opt into specifying "
#~ "what files may be installed by "
#~ "using the ``--hash`` argument for a "
#~ "specific dependency. This is also "
#~ "optional with pip-tools as it "
#~ "requires specifying the ``--generate-hashes``"
#~ " CLI argument."
#~ msgstr ""

#~ msgid ""
#~ "Third, even when you control what "
#~ "files may be installed, it does "
#~ "not prevent other packages from being"
#~ " installed. If a dependency is not"
#~ " listed in the requirements file, pip"
#~ " will happily go searching for a "
#~ "file to meet that need, unless you"
#~ " specify ``--no-deps`` as an "
#~ "argument."
#~ msgstr ""

#~ msgid ""
#~ "Fourth, the format allows for installing"
#~ " a `source distribution file`_ (aka "
#~ "\"sdist\"). By its very nature, "
#~ "installing an sdist may imply executing"
#~ " arbitrary Python code, meaning that "
#~ "there is no control over what "
#~ "files may be installed. Only by "
#~ "specifying ``--only-binary :all:`` can "
#~ "you guarantee pip to only use a"
#~ " `wheel file`_ for each package."
#~ msgstr ""

#~ msgid ""
#~ "To recap, in order for a "
#~ "requirements file to be as secure "
#~ "as what is being proposed, a user"
#~ " should always do the following "
#~ "steps:"
#~ msgstr ""

#~ msgid "Use pip-tools and its command ``pip-compile --generate-hashes``"
#~ msgstr ""

#~ msgid ""
#~ "Install the requirements file using "
#~ "``pip install --no-deps --only-binary"
#~ " :all:``"
#~ msgstr ""

#~ msgid ""
#~ "Critically, all of those flags, and "
#~ "both specificity and exhaustion of what"
#~ " to install that pip-tools provides,"
#~ " are optional."
#~ msgstr ""

#~ msgid ""
#~ "As such, the proposal raised in "
#~ "this PEP is secure by design to"
#~ " combat some supply chain attacks. "
#~ "Hashes for files which would be "
#~ "used to install from are **required**."
#~ " You can **only** install from wheels"
#~ " to unambiguously define what files "
#~ "will be placed in the file system."
#~ " Installers **must** have an unambiguous"
#~ " installation from a lock file for"
#~ " a given platform."
#~ msgstr ""

#~ msgid "Cross-Platform"
#~ msgstr ""

#~ msgid ""
#~ "Various projects which already have a"
#~ " lock file, like PDM_ and Poetry_,"
#~ " provide a lock file which is "
#~ "*cross-platform*. This allows for a "
#~ "single lock file to work on "
#~ "multiple platforms while still leading "
#~ "to exact same top-level requirements "
#~ "to be installed everywhere while the "
#~ "installation being consistent/unambiguous on "
#~ "each platform."
#~ msgstr ""

#~ msgid ""
#~ "As to why this is useful, let's"
#~ " use an example involving PyWeek_ (a"
#~ " week-long game development competition)."
#~ " We assume you are developing on "
#~ "Linux, while someone you choose to "
#~ "partner with is using macOS. Now "
#~ "assume the judges are using Windows. "
#~ "How do you make sure everyone is"
#~ " using the same top-level "
#~ "dependencies, while allowing for any "
#~ "platform-specific requirements (e.g. a "
#~ "package requires a helper package under"
#~ " Windows)?"
#~ msgstr ""

#~ msgid ""
#~ "With a cross-platform lock file, "
#~ "you can make sure that the key "
#~ "requirements are met consistently across "
#~ "all platforms. You can then also "
#~ "make sure that all users on the"
#~ " same platform get the same "
#~ "reproducible installation."
#~ msgstr ""

#~ msgid "Simple Installer"
#~ msgstr ""

#~ msgid ""
#~ "The separation of concerns between a "
#~ "locker and an installer allows for "
#~ "an installer to have a much "
#~ "simpler operation to perform. As such,"
#~ " it not only allows for installers"
#~ " to be easier to write, but "
#~ "facilitates in making sure installers "
#~ "create unambiguous, reproducible installations."
#~ msgstr ""

#~ msgid ""
#~ "The installer can also expend less "
#~ "computation/energy in creating the "
#~ "installation. This is beneficial not "
#~ "only for faster installs, but also "
#~ "from an energy consumption perspective, "
#~ "as installers are expected to be "
#~ "run more often than lockers."
#~ msgstr ""

#~ msgid ""
#~ "This has led to a design where "
#~ "the locker must do more work "
#~ "upfront to benefit installers. It also"
#~ " means the complexity of package "
#~ "dependencies is simpler and easier to"
#~ " comprehend to avoid ambiguity."
#~ msgstr ""

#~ msgid ""
#~ "Lock files MUST use the TOML_ file"
#~ " format. This not only prevents the"
#~ " need to have another file format "
#~ "in the Python packaging ecosystem, "
#~ "thanks to its adoption by PEP 518"
#~ " for ``pyproject.toml``, but also assists"
#~ " in making lock files more human-"
#~ "readable."
#~ msgstr ""

#~ msgid ""
#~ "Lock files MUST end their file "
#~ "names with ``.pylock.toml``. The ``.toml`` "
#~ "part unambiguously distinguishes the format"
#~ " of the file, and helps tools "
#~ "like code editors support the file "
#~ "appropriately. The ``.pylock`` part "
#~ "distinguishes the file from other TOML"
#~ " files the user has, to make "
#~ "logic easier for tools to create "
#~ "functionalities specific to Python lock "
#~ "files, instead of TOML files in "
#~ "general."
#~ msgstr ""

#~ msgid ""
#~ "The following sections are the top-"
#~ "level keys of the TOML file data"
#~ " format. Any field not listed as "
#~ "required is considered optional."
#~ msgstr ""

#~ msgid "This field is **required**."
#~ msgstr ""

#~ msgid ""
#~ "The version of the lock file being"
#~ " used. The key MUST be a string"
#~ " consisting of a number that follows"
#~ " the same formatting as the "
#~ "``Metadata-Version`` key in the `core "
#~ "metadata spec`_. The value MUST be "
#~ "set to ``\"1.0\"`` until a future "
#~ "PEP allows for a different value. "
#~ "The introduction of a new *optional* "
#~ "key SHOULD increase the minor version."
#~ " The introduction of a new required"
#~ " key or changing the format MUST "
#~ "increase the major version. How to "
#~ "handle other scenarios is left as "
#~ "a per-PEP decision."
#~ msgstr ""

#~ msgid ""
#~ "Installers MUST warn the user if "
#~ "the lock file specifies a version "
#~ "whose major version is support but "
#~ "whose minor version is "
#~ "unsupported/unrecognized (e.g. the installer "
#~ "supports ``\"1.0\"``, but the lock file"
#~ " specifies ``\"1.1\"``)."
#~ msgstr ""

#~ msgid ""
#~ "Installers MUST raise an error if "
#~ "the lock file specifies a major "
#~ "version which is unsupported (e.g. the"
#~ " installer supports ``\"1.9\"`` but the "
#~ "lock file specifies ``\"2.0\"``)."
#~ msgstr ""

#~ msgid "``created-at``"
#~ msgstr ""

#~ msgid ""
#~ "The timestamp for when the lock "
#~ "file was generated (using TOML's native"
#~ " timestamp type). It MUST be recorded"
#~ " using the UTC time zone to "
#~ "avoid ambiguity."
#~ msgstr ""

#~ msgid ""
#~ "If the SOURCE_DATE_EPOCH_ environment variable"
#~ " is set, it MUST be used as "
#~ "the timestamp by the locker. This "
#~ "faciliates reproducibility of the lock "
#~ "file itself."
#~ msgstr ""

#~ msgid "This table is **required**."
#~ msgstr ""

#~ msgid ""
#~ "A key storing a string containing "
#~ "an environment marker as specified in"
#~ " the `dependency specifier spec`_."
#~ msgstr ""

#~ msgid ""
#~ "The locker MAY specify an environment"
#~ " marker which specifies any restrictions"
#~ " the lock file was generated under."
#~ msgstr ""

#~ msgid "``metadata.tag``"
#~ msgstr ""

#~ msgid ""
#~ "A key storing a string specifying "
#~ "`platform compatibility tags`_ (i.e. wheel "
#~ "tags). The tag MAY be a compressed"
#~ " tag set."
#~ msgstr ""

#~ msgid ""
#~ "The locker MAY specify a tag (set)"
#~ " which specify which platform(s) the "
#~ "lock file supports."
#~ msgstr ""

#~ msgid ""
#~ "If the installer is installing for "
#~ "an environment which does not satisfy"
#~ " the specified tag (set), the "
#~ "installer MUST raise an error as "
#~ "the lock file does not support the"
#~ " environment."
#~ msgstr ""

#~ msgid "``metadata.requires``"
#~ msgstr ""

#~ msgid ""
#~ "An array of strings following the "
#~ "`dependency specifier spec`_. This array "
#~ "represents the top-level package "
#~ "dependencies of the lock file and "
#~ "thus the root of the dependency "
#~ "graph."
#~ msgstr ""

#~ msgid "``metadata.requires-python``"
#~ msgstr ""

#~ msgid ""
#~ "A string specifying the support "
#~ "version(s) of Python for this lock "
#~ "file. It follows the same format "
#~ "as that specified for the ``Requires-"
#~ "Python`` field in the `core metadata "
#~ "spec`_."
#~ msgstr ""

#~ msgid "``[[package._name_._version_]]``"
#~ msgstr ""

#~ msgid "This array is **required**."
#~ msgstr ""

#~ msgid ""
#~ "An array per package and version "
#~ "containing details for the potential "
#~ "(wheel) files to install (as represented"
#~ " by ``_name_`` and ``_version_``, "
#~ "respectively)."
#~ msgstr ""

#~ msgid ""
#~ "Lockers must MUST normalize a project's"
#~ " name according to the `simple "
#~ "repository API`_. If extras are "
#~ "specified as part of the project "
#~ "to install, the extras are to be"
#~ " included in the key name and "
#~ "are to be sorted in lexicographic "
#~ "order."
#~ msgstr ""

#~ msgid "Within the file, the tables for the projects SHOULD be sorted by:"
#~ msgstr ""

#~ msgid "Optional dependencies (extras) via lexicographic order"
#~ msgstr ""

#~ msgid "File name based on the ``filename`` or ``url`` field (discussed below)"
#~ msgstr ""

#~ msgid "All of this is to help minimize diff changes between tool executions."
#~ msgstr ""

#~ msgid "``package._name_._version_.url``"
#~ msgstr ""

#~ msgid "A string representing a URL where to get the file."
#~ msgstr ""

#~ msgid ""
#~ "The installer MAY support any schemes"
#~ " it wants for URLs (e.g. ``file:``"
#~ " as well as ``https:``)."
#~ msgstr ""

#~ msgid ""
#~ "An installer MAY choose to not use"
#~ " the URL to retrieve a file if"
#~ " a file matching the specified hash"
#~ " can be found using some alternative"
#~ " means (e.g. on the file system "
#~ "in a cache directory)."
#~ msgstr ""

#~ msgid "``package._name_._version_.filename``"
#~ msgstr ""

#~ msgid ""
#~ "A string representing the name of "
#~ "the file as represented by an "
#~ "entry in the array. This field is"
#~ " required to simplify installers as "
#~ "the file name is required to "
#~ "resolve wheel tags derived from the "
#~ "file name. It also guarantees that "
#~ "the association of the array entry "
#~ "to the file it is meant for "
#~ "is always clear."
#~ msgstr ""

#~ msgid "``package._name_._version_.direct``"
#~ msgstr ""

#~ msgid ""
#~ "A boolean representing whether an "
#~ "installer should consider the project "
#~ "installed \"directly\" as specified by "
#~ "the `direct URL origin of installed "
#~ "distributions spec`_."
#~ msgstr ""

#~ msgid ""
#~ "If the key is true, then the "
#~ "installer MUST follow the `direct URL"
#~ " origin of installed distributions spec`_"
#~ " for recording the installation as "
#~ "\"direct\"."
#~ msgstr ""

#~ msgid "``[package._name_._version_.hashes]``"
#~ msgstr ""

#~ msgid ""
#~ "A table with keys specifying hash "
#~ "algorithms and values as the hash "
#~ "for the file represented by this "
#~ "entry in the ``package._name_._version_`` "
#~ "table."
#~ msgstr ""

#~ msgid ""
#~ "Lockers SHOULD list hashes in "
#~ "lexicographic order. This is to help "
#~ "minimize diff sizes and the potential"
#~ " to overlook hash value changes."
#~ msgstr ""

#~ msgid ""
#~ "An installer MUST only install a "
#~ "file which matches one of the "
#~ "specified hashes."
#~ msgstr ""

#~ msgid "``package._name_._version_.requires``"
#~ msgstr ""

#~ msgid ""
#~ "An array of strings following the "
#~ "`dependency specifier spec`_ which represent"
#~ " the dependencies of this file."
#~ msgstr ""

#~ msgid "``package._name_._version_.requires-python``"
#~ msgstr ""

#~ msgid ""
#~ "A string specifying the support "
#~ "version(s) of Python for this file. "
#~ "It follows the same format as that"
#~ " specified for the ``Requires-Python`` "
#~ "field in the `core metadata spec`_."
#~ msgstr ""

#~ msgid "Expectations for Lockers"
#~ msgstr ""

#~ msgid ""
#~ "Lockers MUST create lock files for "
#~ "which a topological sort of the "
#~ "packages which qualify for installation "
#~ "on the specified platform results in "
#~ "a graph for which only a single"
#~ " version of any package is possible"
#~ " and there is at least one "
#~ "compatible file to install for those "
#~ "packages. This equates to a lock "
#~ "file that which is acceptable based "
#~ "on ``metadata.marker``, ``metadata.tag``, and "
#~ "``metadata.requires-python`` will have a "
#~ "list of package versions after "
#~ "evaluating environment markers and eliminating"
#~ " unsupported files for which the only"
#~ " decision the installer will need to"
#~ " make is which file to use for"
#~ " the package (which is outlined "
#~ "below)."
#~ msgstr ""

#~ msgid ""
#~ "This means that lockers are expected "
#~ "to utilize ``metadata.marker``, ``metadata.tag``,"
#~ " and ``metadata.requires-python`` as "
#~ "appropriate as well as environment "
#~ "markers specified via ``requires`` and "
#~ "Python version requirements via ``requires-"
#~ "python`` to enforce this result for "
#~ "installers. Put another way, the "
#~ "information used in the lock file "
#~ "is not expected to be pristine/raw "
#~ "from the locker's input and instead "
#~ "is to be changed as necessary to"
#~ " the benefit of the locker's goals."
#~ msgstr ""

#~ msgid "Expectations for Installers"
#~ msgstr ""

#~ msgid "The expected algorithm for resolving what to install is:"
#~ msgstr ""

#~ msgid ""
#~ "Construct a dependency graph based on"
#~ " the data in the lock file with"
#~ " ``metadata.requires`` as the starting/root "
#~ "point."
#~ msgstr ""

#~ msgid ""
#~ "Eliminate all (wheel) files that are "
#~ "unsupported by the specified platform."
#~ msgstr ""

#~ msgid ""
#~ "Eliminate all irrelevant edges between "
#~ "packages based on marker evaluation."
#~ msgstr ""

#~ msgid ""
#~ "Raise an error if a package "
#~ "version is still reachable from the "
#~ "root of the dependency graph but "
#~ "lacks any compatible (wheel) file."
#~ msgstr ""

#~ msgid ""
#~ "Verify that all packages left only "
#~ "have one version to install, raising "
#~ "an error otherwise."
#~ msgstr ""

#~ msgid "Install the best-fitting wheel file for each package which remains."
#~ msgstr ""

#~ msgid "What constitues the \"best-fitting wheel file\" is an open issue."
#~ msgstr ""

#~ msgid ""
#~ "Installers MUST support installing into "
#~ "an empty environment. Installers MAY "
#~ "support installing into an environment "
#~ "that already conatins installed packages "
#~ "(and whatever that would entail)."
#~ msgstr ""

#~ msgid "(Potential) Tool Support"
#~ msgstr ""

#~ msgid ""
#~ "The pip_ team has `said "
#~ "<https://github.com/pypa/pip/issues/10636>`__ they are "
#~ "interested in supporting this PEP if "
#~ "accepted. The current proposal for pip"
#~ " may even `supplant the need "
#~ "<https://github.com/jazzband/pip-"
#~ "tools/issues/1526#issuecomment-961883367>`__ for `pip-"
#~ "tools`_."
#~ msgstr ""

#~ msgid ""
#~ "PDM_ has also said they would "
#~ "`support the PEP <https://github.com/pdm-"
#~ "project/pdm/issues/718>`__ if accepted."
#~ msgstr ""

#~ msgid ""
#~ "Pyflow_ has said they `\"like the "
#~ "idea\" <https://github.com/David-"
#~ "OConnor/pyflow/issues/153#issuecomment-962482058>`__ of "
#~ "the PEP."
#~ msgstr ""

#~ msgid ""
#~ "As for pre-existing tools that "
#~ "have their own lock file, some "
#~ "updating will be required. Most document"
#~ " the lock file name, but not "
#~ "its contents. For projects which do "
#~ "not commit their lock file to "
#~ "version control, they will need to "
#~ "update the equivalent of their "
#~ "``.gitignore`` file. For projects that "
#~ "do commit their lock file to "
#~ "version control, what file(s) get "
#~ "committed will need an update."
#~ msgstr ""

#~ msgid ""
#~ "For projects which do document their "
#~ "lock file format like pipenv_, they "
#~ "will very likely need a major "
#~ "version release which changes the lock"
#~ " file format."
#~ msgstr ""

#~ msgid ""
#~ "Specifically for Poetry_, it has an "
#~ "`export command <https://python-"
#~ "poetry.org/docs/cli/#export>`_ which should allow"
#~ " Poetry to support this lock file "
#~ "format even if the project chooses "
#~ "not to adopt this PEP as Poetry's"
#~ " primary lock file format."
#~ msgstr ""

#~ msgid ""
#~ "A lock file should not introduce "
#~ "security issues but instead help solve"
#~ " them. By requiring the recording of"
#~ " hashes for files, a lock file "
#~ "is able to help prevent tampering "
#~ "with code since the hash details "
#~ "were recorded. A lock file also "
#~ "helps prevent unexpected package updates "
#~ "being installed which may be malicious."
#~ msgstr ""

#~ msgid ""
#~ "Teaching of this PEP will very "
#~ "much be dependent on the lockers "
#~ "and installers being used for day-"
#~ "to-day use. Conceptually, though, users "
#~ "could be taught that a lock file"
#~ " specifies what should be installed "
#~ "for a project to work. The "
#~ "benefits of consistency and security "
#~ "should be emphasized to help users "
#~ "realize why they should care about "
#~ "lock files."
#~ msgstr ""

#~ msgid ""
#~ "No proof-of-concept or reference "
#~ "implementation currently exists. An example"
#~ " locker and installer will be "
#~ "provided before this PEP is fully "
#~ "accepted (although this is not a "
#~ "necessarily a requirement for conditional "
#~ "acceptance)."
#~ msgstr ""

#~ msgid "Alternative Naming Schemes"
#~ msgstr ""

#~ msgid ""
#~ "Specifying a directory to install file"
#~ " to was considered, but ultimately "
#~ "rejected due to people's distaste for"
#~ " the idea."
#~ msgstr ""

#~ msgid ""
#~ "It was also suggested to not have"
#~ " a special file name suffix, but "
#~ "it was decided that hurt discoverability"
#~ " by tools too much."
#~ msgstr ""

#~ msgid ""
#~ "At one point the idea of only "
#~ "supporting single lock file which "
#~ "contained all possible lock information "
#~ "was considered. But it quickly became"
#~ " apparent that trying to devise a "
#~ "data format which could encompass both"
#~ " a lock file format which could "
#~ "support multiple environments as well as"
#~ " strict lock outcomes for reproducible "
#~ "builds would become quite complex and"
#~ " cumbersome."
#~ msgstr ""

#~ msgid ""
#~ "This idea was eventually rejected due"
#~ " to the number of combinations of "
#~ "potential PEP 508 environment markers. "
#~ "The decision was made that trying "
#~ "to have lockers generate all possible"
#~ " combinations as individual lock files "
#~ "when a project wants to be "
#~ "cross-platform would be too much."
#~ msgstr ""

#~ msgid ""
#~ "Instead of having the ``metadata.tag`` "
#~ "field there was a suggestion of "
#~ "encoding the tags into the file "
#~ "name. But due to the addition of"
#~ " the ``metadata.marker`` field and what "
#~ "to do when no tags were needed,"
#~ " the idea was dropped."
#~ msgstr ""

#~ msgid "Alternative Names for ``requires``"
#~ msgstr ""

#~ msgid ""
#~ "Some other names for what became "
#~ "``requires`` were ``installs``, ``needs``, and"
#~ " ``dependencies``. Initially this PEP chose"
#~ " ``needs`` after asking a Python "
#~ "beginner which term they preferred. But"
#~ " based on feedback on an earlier "
#~ "draft of this PEP, ``requires`` was "
#~ "chosen as the term."
#~ msgstr ""

#~ msgid ""
#~ "This PEP chooses to standardize around"
#~ " an artifact instead of an API "
#~ "(ala PEP 621). This would allow "
#~ "for more tool integrations as it "
#~ "removes the need to specifically use "
#~ "Python to do things such as create"
#~ " a lock file, update it, or "
#~ "even install packages listed in a "
#~ "lock file. It also allows for "
#~ "easier introspection by forcing dependency "
#~ "graph details to be written in a"
#~ " human-readable format. It also "
#~ "allows for easier sharing of knowledge"
#~ " by standardizing what people need to"
#~ " know more (e.g. tutorials become "
#~ "more portable between tools when it "
#~ "comes to understanding the artifact they"
#~ " produce). It's also simply the "
#~ "approach other language communities have "
#~ "taken and seem to be happy with."
#~ msgstr ""

#~ msgid "Specifying Requirements per Package Instead of per File"
#~ msgstr ""

#~ msgid ""
#~ "An earlier draft of this PEP "
#~ "specified dependencies at the package "
#~ "level instead of per (wheel) file. "
#~ "While this has traditionally been how"
#~ " packaging systems work, it actually "
#~ "did not reflect accurately how things"
#~ " are specified. As such, this PEP "
#~ "was subsequently updated to reflect the"
#~ " granularity that dependencies can truly"
#~ " be specified at."
#~ msgstr ""

#~ msgid ""
#~ "Allowing Source Distributions and Source "
#~ "Trees to be an Opt-In, Supported"
#~ " File Format"
#~ msgstr ""

#~ msgid ""
#~ "For security reproducibility reasons this "
#~ "PEP only considers supporting installation "
#~ "from wheel files. Installing from either"
#~ " an sdist or source tree requires "
#~ "arbitrary code execution during installation,"
#~ " unknown files to be installed, and"
#~ " an unknown set of dependencies. "
#~ "Those issues all run counter to "
#~ "guaranteeing users get the same files"
#~ " for the same platform as well "
#~ "as making sure they are receiving "
#~ "the expected files."
#~ msgstr ""

#~ msgid ""
#~ "To deal with this issue, people "
#~ "would need to build their own "
#~ "wheels from sdists and cache them. "
#~ "Then the lockers would record the "
#~ "hashes of those wheels and the "
#~ "installers would then be expected to "
#~ "use those wheels."
#~ msgstr ""

#~ msgid ""
#~ "Another option is to allow sdists "
#~ "(and potentially source trees) be listed"
#~ " as support file formats, but have"
#~ " them marked as insecure in the "
#~ "lock file and require the installer "
#~ "force the user to opt into using"
#~ " insecure file formats. Unfortunately "
#~ "because sdists which don't necessarily "
#~ "follow version 2.2 of the `core "
#~ "metadata spec`_ for their ``PKG-INFO``"
#~ " file will have unknown dependencies, "
#~ "breaking the guarantee that results will"
#~ " be reproducible thanks to potential "
#~ "arbitrary calculations of those dependencies."
#~ " And even if an sdist did "
#~ "follow the latest spec, they could "
#~ "still list their requirements as "
#~ "dynamic, still making it impossible to"
#~ " statically know what should be "
#~ "installed. As such, installers would "
#~ "either have to have a full "
#~ "resolver to handle these dynamic cases"
#~ " or only sdists which follow version"
#~ " 2.2 of the core metadata spec "
#~ "**and** statically specify their dependencies"
#~ " could be listed. But at that "
#~ "point the project is probably capable"
#~ " of providing wheels, making support "
#~ "for sdists that much less "
#~ "important/useful."
#~ msgstr ""

#~ msgid "Specify Where Lockers Gather Input"
#~ msgstr ""

#~ msgid ""
#~ "This PEP currently does not specify "
#~ "how a locker gets its input. It"
#~ " could be possible to support a "
#~ "subset of PEP 621 such that "
#~ "``project.requires-python`` and "
#~ "``project.dependencies`` are read from "
#~ "``pyproject.toml`` and automatically used as"
#~ " input if provided. But this or "
#~ "some other practice could also be "
#~ "left as something to grow organically"
#~ " in the community and making that "
#~ "the standard at a later date."
#~ msgstr ""

#~ msgid "What is a \"best-fitting wheel file\"?"
#~ msgstr ""

#~ msgid ""
#~ "The expected steps of installing a "
#~ "package much include decided which wheel"
#~ " file to install as a package "
#~ "may have a universal wheel on top"
#~ " of very specific wheels. But as "
#~ "`platform compatibility tags`_ do not "
#~ "specify how to determine priority and"
#~ " there is no way to use "
#~ "environment markers to specify an exact"
#~ " wheel, there's no defined way for"
#~ " an installer to deterministically "
#~ "determine what wheel file to select."
#~ msgstr ""

#~ msgid ""
#~ "There are two possible solutions. One"
#~ " is for the locker to specify a"
#~ " ranking/priority order to the wheel "
#~ "files. That way the installer simply "
#~ "sorts to the supported wheel files "
#~ "by that order and installs the the"
#~ " top rated/ranked wheel file. This "
#~ "puts the priority order under the "
#~ "control of the locker."
#~ msgstr ""

#~ msgid ""
#~ "The other option is to specify in"
#~ " this PEP how to calculate the "
#~ "priority/ranking of wheel files. This is"
#~ " currently tool-based and seems to"
#~ " have been acceptable overall by the"
#~ " community, but having a specification "
#~ "for this would probably still be "
#~ "welcome. It may be somewhat disruptive,"
#~ " though, as it could change what "
#~ "files get installed by tools which "
#~ "implement the ordering outside of the"
#~ " context of this PEP. And if "
#~ "this PEP gains traction, it is "
#~ "reasonable to assume that users will "
#~ "expect the ordering to be consistent "
#~ "across tools."
#~ msgstr ""

#~ msgid ""
#~ "Thanks to Andrea McInnes for initially"
#~ " settling the bikeshedding and choosing "
#~ "the paint colour of ``needs`` (at "
#~ "which point that caused people to "
#~ "rally around the ``requires`` colour)."
#~ msgstr ""

#~ msgid "Specifying Installation Requirements for Python Projects"
#~ msgstr ""

#~ msgid ""
#~ "https://discuss.python.org/t/pep-665-specifying-installation-"
#~ "requirements-for-python-projects/9911"
#~ msgstr ""

#~ msgid ""
#~ "This PEP specifies a file format "
#~ "to list the Python package installation"
#~ " requirements for a project. The list"
#~ " of projects is considered exhaustive "
#~ "for the installation target and thus "
#~ "*locked down*, not requiring any "
#~ "information beyond the platform being "
#~ "installed for and the *lock file* "
#~ "listing the required dependencies to "
#~ "perform a successful installation of "
#~ "dependencies."
#~ msgstr ""

#~ msgid ""
#~ "Thanks to PEP 621, projects have a"
#~ " way to list their direct/top-level"
#~ " dependencies which they need to have"
#~ " installed. But PEP 621 also "
#~ "(purposefully) omits two key details "
#~ "that often become important for "
#~ "projects:"
#~ msgstr ""

#~ msgid "A listing of all indirect/transitive dependencies"
#~ msgstr ""

#~ msgid ""
#~ "Specifying (at least) specific versions "
#~ "of dependencies for reproducible installations"
#~ msgstr ""

#~ msgid ""
#~ "Both needs can be important for "
#~ "various reasons when creating a new "
#~ "environment. Consider a project which is"
#~ " an application that is deployed "
#~ "somewhere (either to users as a "
#~ "desktop app or to a server). "
#~ "Without a complete listing of all "
#~ "dependencies and the specific versions "
#~ "to use, there can be a skew "
#~ "between developers of the same project,"
#~ " or developer and user, based on "
#~ "what versions of a project's "
#~ "dependencies happen to be available at"
#~ " the time of installation in a "
#~ "new environment. For instance, a "
#~ "dependency may have v1 as the "
#~ "newest version on Monday when one "
#~ "developer installed the dependency, while "
#~ "v2 comes out on Wednesday when "
#~ "another developer installs the same "
#~ "dependency. Now the two developers are"
#~ " working against two different versions "
#~ "of the same dependency, which can "
#~ "lead to different outcomes. This is "
#~ "the use-case of developing a "
#~ "desktop or server application where one"
#~ " might have a ``requirements.txt`` file "
#~ "which specifies exact versions of "
#~ "various packages."
#~ msgstr ""

#~ msgid ""
#~ "Another important reason for reproducible "
#~ "installations is for security purposes. "
#~ "Guaranteeing that the same binary data"
#~ " is downloaded and installed for all"
#~ " installations of an app makes sure"
#~ " that no bad actor has somehow "
#~ "changed a dependency's binary data in"
#~ " a malicious way. A lock file "
#~ "can assist in this guarantee by "
#~ "recording the exact details of what "
#~ "should be installed and how to "
#~ "verify that those dependencies have not"
#~ " changed any bytes unexpectedly. This "
#~ "is the use-case of developing a"
#~ " secure application using a "
#~ "``requirements.txt`` file which specifies the"
#~ " hash of all the packages that "
#~ "should be installed."
#~ msgstr ""

#~ msgid ""
#~ "Tied into this concept of "
#~ "reproducibility is the speed at which"
#~ " an environment can be recreated. If"
#~ " you created a lock file as "
#~ "part of your local development, it "
#~ "can be used to speed up recreating"
#~ " that development environment by minimizing"
#~ " having to query the network or "
#~ "the scope of the possible resolution "
#~ "of dependencies. This makes recreating "
#~ "your local development environment faster "
#~ "as the amount of work required to"
#~ " calculate what dependencies to install "
#~ "has been minimized. This is the "
#~ "use-case of when you are working "
#~ "on a library or some such project"
#~ " where the lock file is not "
#~ "committed to version control and the "
#~ "lock file used as a local cache"
#~ " of installation resolution details, such"
#~ " as an uncommitted ``poetry.lock`` file."
#~ msgstr ""

#~ msgid ""
#~ "Below, we identify some use-cases "
#~ "applicable to stakeholders in the Python"
#~ " community and anyone who interacts "
#~ "with Python package installers who are"
#~ " the ultimate consumers of a lock "
#~ "file (this is not considered exhaustive"
#~ " and is borrowed from PEP 650)."
#~ msgstr ""

#~ msgid "Providers"
#~ msgstr ""

#~ msgid ""
#~ "Providers are the parties (organization, "
#~ "person, community, etc.) that supply a"
#~ " service or software tool which "
#~ "interacts with Python packaging. Two "
#~ "different types of providers are "
#~ "considered:"
#~ msgstr ""

#~ msgid "Platform/Infrastructure Providers"
#~ msgstr ""

#~ msgid ""
#~ "Platform providers (cloud environments, "
#~ "application hosting, etc.) and infrastructure"
#~ " service providers need to support "
#~ "package installers for their users to"
#~ " install Python dependencies. Most only "
#~ "support ``requirements.txt`` files and a "
#~ "smattering of other file formats for "
#~ "listing a project's dependencies. Most "
#~ "providers do not want to maintain "
#~ "support for more than one dependency "
#~ "specification format because of the "
#~ "complexity it adds to their software "
#~ "or service and the resources it "
#~ "takes to do so (e.g. not all "
#~ "platform providers have the staffing to"
#~ " support pip-tools, Poetry, Pipenv, "
#~ "etc.)."
#~ msgstr ""

#~ msgid ""
#~ "This PEP would allow platform providers"
#~ " to declare support for this PEP "
#~ "and thus only have to support one"
#~ " dependency specification format. What this"
#~ " would mean is developers could use"
#~ " whatever toolchain they preferred for "
#~ "development as long as they could "
#~ "emit a file that implemented this "
#~ "PEP. This then allows developers to "
#~ "not have to align with what their"
#~ " platform providers supports as long "
#~ "as everyone agrees to implementing this"
#~ " PEP."
#~ msgstr ""

#~ msgid "IDE Providers"
#~ msgstr ""

#~ msgid ""
#~ "Integrated development environments may "
#~ "interact with Python package installation "
#~ "and management. Most only support select"
#~ " few tools, and users are required"
#~ " to find work arounds to install "
#~ "their dependencies using other package "
#~ "installers. Similar to the situation "
#~ "with PaaS & IaaS providers, IDE "
#~ "providers do not want to maintain "
#~ "support for N different formats. "
#~ "Instead, tools would only need to "
#~ "be able to read files which "
#~ "implement this PEP to perform various"
#~ " actions (e.g. list all the "
#~ "dependencies of the open project, which"
#~ " ones are missing, install dependencies,"
#~ " generate the lock file, etc.)."
#~ msgstr ""

#~ msgid ""
#~ "As an example, the Python extension "
#~ "for VS Code has to have custom "
#~ "support for each installer tool people"
#~ " may use: pip, Poetry, Pipenv, etc."
#~ " This is not only tedious by "
#~ "having to track multiple projects and"
#~ " any changes they make, but it "
#~ "also locks out newer tools whose "
#~ "popularity isn't great enough to warrant"
#~ " inclusion in the extension."
#~ msgstr ""

#~ msgid "Developers"
#~ msgstr ""

#~ msgid ""
#~ "Developers are teams, people, or "
#~ "communities that code and use Python "
#~ "package installers and Python packages. "
#~ "Three different types of developers are"
#~ " considered:"
#~ msgstr ""

#~ msgid "Developers using PaaS & IaaS providers"
#~ msgstr ""

#~ msgid ""
#~ "Most PaaS and IaaS providers only "
#~ "support one Python package installer: "
#~ "``requirements.txt``. This dictates the "
#~ "installers that developers can use while"
#~ " working with these providers, which "
#~ "might not be optimal for their "
#~ "application or workflow."
#~ msgstr ""

#~ msgid ""
#~ "Developers adopting this PEP would be"
#~ " able to use third party "
#~ "platforms/infrastructure without having to "
#~ "worry about which Python package "
#~ "installer they are required to use "
#~ "as long as the provider also "
#~ "supports this PEP."
#~ msgstr ""

#~ msgid "Developers using IDEs"
#~ msgstr ""

#~ msgid ""
#~ "Most IDEs only support pip or a"
#~ " few Python package installers. "
#~ "Consequently, developers must use workarounds"
#~ " or hacky methods to install their"
#~ " dependencies if they use an "
#~ "unsupported package installer."
#~ msgstr ""

#~ msgid ""
#~ "If the IDE uses/supports this PEP "
#~ "it would allow for any developer "
#~ "to use whatever tooling they wanted "
#~ "to generate their lock file while "
#~ "the IDE can use whatever tooling "
#~ "it wants to performs actions with/on "
#~ "the lock file."
#~ msgstr ""

#~ msgid "Developers working with other developers"
#~ msgstr ""

#~ msgid ""
#~ "Developers want to be able to use"
#~ " the installer of their choice while"
#~ " working with other developers, but "
#~ "currently have to synchronize their "
#~ "installer choice for compatibility of "
#~ "dependency installation. If all preferred "
#~ "installers instead implemented the specified"
#~ " interface, it would allow for cross"
#~ " use of installers, allowing developers "
#~ "to choose an installer regardless of "
#~ "their collaboratorâs preference."
#~ msgstr ""

#~ msgid "Upgraders & Package Infrastructure Providers"
#~ msgstr ""

#~ msgid ""
#~ "Package upgraders and package infrastructure"
#~ " in CI/CD such as Dependabot_, PyUP_,"
#~ " etc. currently support a few "
#~ "formats. They work by parsing and "
#~ "editing the dependency files with "
#~ "relevant package information such as "
#~ "upgrades, downgrades, or new hashes. "
#~ "Similar to Platform and IDE providers,"
#~ " most of these providers do not "
#~ "want to support N different formats."
#~ msgstr ""

#~ msgid ""
#~ "Currently, these services/bots have to "
#~ "implement support for each format "
#~ "individually. Inevitably, the most popular "
#~ "formats are supported first, and less"
#~ " popular tools are often never "
#~ "supported. By implementing this specification,"
#~ " these services/bots can support one "
#~ "format, allowing users to select the "
#~ "tool of their choice to generate "
#~ "the file. This will allow for more"
#~ " innovation in the space, as "
#~ "platforms and IDEs are no longer "
#~ "forced to prematurely select a "
#~ "\"winner\" tool which generates a lock"
#~ " file."
#~ msgstr ""

#~ msgid "Open Source Community"
#~ msgstr ""

#~ msgid ""
#~ "Specifying installer requirements and adopting"
#~ " this PEP will reduce the friction"
#~ " between Python package installers and "
#~ "people's workflows. Consequently, it will "
#~ "reduce the friction between Python "
#~ "package installers and 3rd party "
#~ "infrastructure/technologies such as PaaS or"
#~ " IDEs. Overall, it will allow for "
#~ "easier development, deployment and maintenance"
#~ " of Python projects as Python package"
#~ " installation becomes simpler and more "
#~ "interoperable."
#~ msgstr ""

#~ msgid ""
#~ "Specifying a single file format can "
#~ "also increase the pace of innovation "
#~ "around installers and the generation of"
#~ " dependency graphs. By decoupling "
#~ "generating the dependency graph details "
#~ "from installation It allows for each "
#~ "area to grow and innovate independently."
#~ " It also allows more flexibility in"
#~ " tool selection on either end of "
#~ "the dependency graph and installation "
#~ "ends of this process."
#~ msgstr ""

#~ msgid ""
#~ "To begin, two key terms should be"
#~ " defined. A **locker** is a tool "
#~ "which *produces* a lock file. An "
#~ "**installer** is a tool which *consumes*"
#~ " a lock file to install the "
#~ "appropriate dependencies."
#~ msgstr ""

#~ msgid ""
#~ "The expected information flow to occur"
#~ " if this PEP were accepted, from "
#~ "the specification of top-level "
#~ "dependencies to all necessary dependencies "
#~ "being installed in a fresh environment,"
#~ " is:"
#~ msgstr ""

#~ msgid "Read top-level dependencies from ``pyproject.toml`` (PEP 621)."
#~ msgstr ""

#~ msgid "Generate a lock file via a locker in ``pyproject-lock.d/``."
#~ msgstr ""

#~ msgid ""
#~ "Install the appropriate dependencies based "
#~ "entirely on information contained in the"
#~ " lock file via an installer."
#~ msgstr ""

#~ msgid "Goals"
#~ msgstr ""

#~ msgid ""
#~ "The file format should be *machine-"
#~ "readable*, *machine-writable*, and *human-"
#~ "readable*. Since the assumption is the"
#~ " vast majority of lock file will "
#~ "be generated by a locker tool, the"
#~ " format should be easy to write "
#~ "by a locker. As install tools will"
#~ " be consuming the lock file, the "
#~ "format also needs to be easily "
#~ "read by an installer. But the "
#~ "format should also be readable by "
#~ "a person as people will inevitably "
#~ "be performing audits on lock files. "
#~ "Having a format that does not lend"
#~ " itself towards being read by people"
#~ " would hinder that. This includes "
#~ "changes to a lock file being "
#~ "readable in a diff format for "
#~ "auditing changes. It also means that "
#~ "understanding *why* something is in the"
#~ " lock file should be comprehensible "
#~ "in a diff to assist in auditing"
#~ " changes."
#~ msgstr ""

#~ msgid ""
#~ "The lock file format needs to be"
#~ " general enough to support *cross-"
#~ "platform and cross-environment* specifications"
#~ " of dependencies. This allows having "
#~ "a single lock file which can work"
#~ " on a myriad of platforms and "
#~ "environments when that makes sense. This"
#~ " has been shown as a necessary "
#~ "feature by the various tools in "
#~ "the Python packaging ecosystem which "
#~ "already have a lock file format "
#~ "(e.g. Pipenv_, Poetry_, PDM_). This can"
#~ " be accomplished by *allowing* (but "
#~ "**not** requiring) lockers to defer "
#~ "marker evaluation to the installer, and"
#~ " thus permitting the locker to "
#~ "include a wider range of *possible* "
#~ "dependencies that the installer has to"
#~ " work with."
#~ msgstr ""

#~ msgid ""
#~ "The lock file also needs to "
#~ "support *reproducible installations*. If one"
#~ " wants to restrict what the lock "
#~ "file covers to a single platform "
#~ "to guarantee the exact dependencies and"
#~ " files which will be installed, that"
#~ " should be doable. This can be "
#~ "critical in security contexts for "
#~ "projects like SecureDrop_."
#~ msgstr ""

#~ msgid ""
#~ "When a computation could be performed"
#~ " either in the locker or installer,"
#~ " the preference is to *perform the"
#~ " computation in the locker*. This is"
#~ " because the assumption is a locker"
#~ " will be executed less frequently "
#~ "than an installer."
#~ msgstr ""

#~ msgid ""
#~ "The installer should be able to "
#~ "resolve what to install based entirely"
#~ " on platform/environment information and "
#~ "what is contained within the lock "
#~ "file. There should be *no need to"
#~ " use network or other file system "
#~ "I/O* in order to resolve what to"
#~ " install."
#~ msgstr ""

#~ msgid ""
#~ "The lock file should provide enough "
#~ "flexibility to allow lockers and "
#~ "installers to innovate. While the lock"
#~ " file specification provides a *common "
#~ "denominator of functionality*, it should "
#~ "not act as a ceiling for "
#~ "functionality."
#~ msgstr ""

#~ msgid "Non-Goals"
#~ msgstr ""

#~ msgid ""
#~ "Because of the expected size of "
#~ "lock files, no effort was put into"
#~ " making lock files *human-writable*."
#~ msgstr ""

#~ msgid ""
#~ "This PEP makes no attempt to make"
#~ " this work in any special way "
#~ "for installers to use a lock file"
#~ " to install into a *preexisting* "
#~ "environment. The assumption is the "
#~ "installer is installing into a "
#~ "*new/fresh* environment."
#~ msgstr ""

#~ msgid ""
#~ "Lock files MUST use the TOML_ file"
#~ " format thanks to its adoption by "
#~ "PEP 518 for ``pyproject.toml``. This not"
#~ " only prevents the need to have "
#~ "another file format in the Python "
#~ "packaging ecosystem, but it also assists"
#~ " in making lock files human-readable."
#~ msgstr ""

#~ msgid ""
#~ "Lock files MUST be kept in a "
#~ "directory named ``pyproject-lock.d``. Lock "
#~ "files MUST end with a ``.toml`` "
#~ "file extension. Projects may have as "
#~ "many lock files as they want using"
#~ " whatever file name stems they "
#~ "choose. This PEP prescribes no specific"
#~ " way to automatically select between "
#~ "multiple lock files and installers "
#~ "SHOULD avoid guessing which lock file"
#~ " is \"best-fitting\" (this does not"
#~ " preclude situations where only a "
#~ "single lock file with a certain "
#~ "name is expected to exist and will"
#~ " be used by default, e.g. a "
#~ "documentation hosting site always using "
#~ "a lock file named ``pyproject-"
#~ "lock.d/rftd.toml`` when provided)."
#~ msgstr ""

#~ msgid "The following are the top-level keys of the TOML file data format."
#~ msgstr ""

#~ msgid ""
#~ "The version of the lock file being"
#~ " used. The key MUST be specified "
#~ "and it MUST be set to ``1``. "
#~ "The number MUST always be an "
#~ "integer and it MUST only increment "
#~ "in future updates to the specification."
#~ " What consistitutes a version number "
#~ "increase is left to future PEPs or"
#~ " standards changes."
#~ msgstr ""

#~ msgid ""
#~ "Tools reading a lock file whose "
#~ "version they don't support MUST raise"
#~ " an error."
#~ msgstr ""

#~ msgid ""
#~ "An optional key storing a string "
#~ "containing an environment marker as "
#~ "specified in the `dependency specifier "
#~ "spec`_."
#~ msgstr ""

#~ msgid ""
#~ "The locker MAY specify an environment"
#~ " marker which specifies any restrictions"
#~ " the lock file was generated under"
#~ " (e.g. specific Python versions supported)."
#~ msgstr ""

#~ msgid "``metadata.tags``"
#~ msgstr ""

#~ msgid ""
#~ "An optional array of inline tables "
#~ "representing `platform compatibility tags`_ "
#~ "that the lock file supports. The "
#~ "locker MAY specify tables in the "
#~ "array which represent the compatibility "
#~ "the lock file was generated for."
#~ msgstr ""

#~ msgid "The tables have the possible keys of:"
#~ msgstr ""

#~ msgid "``interpreter``"
#~ msgstr ""

#~ msgid "``abi``"
#~ msgstr ""

#~ msgid "``platform``"
#~ msgstr ""

#~ msgid ""
#~ "representing the parts of the platform"
#~ " compatibility tags. Each key is "
#~ "optional in a table. These keys "
#~ "MUST represent a single value, i.e. "
#~ "the values are exploded and not "
#~ "compressed in wheel tag parlance."
#~ msgstr ""

#~ msgid ""
#~ "If the environment an installer is "
#~ "installing for does not match **any**"
#~ " table in the array (missing keys "
#~ "in the table means implicit support "
#~ "for that part of the compatibility), "
#~ "the installer MUST raise an error "
#~ "as the lock file does not support"
#~ " the environment."
#~ msgstr ""

#~ msgid "``metadata.needs``"
#~ msgstr ""

#~ msgid ""
#~ "An array of strings representing the "
#~ "package specifiers for the top-"
#~ "level/direct dependencies of the lock "
#~ "file as defined by the `dependency "
#~ "specifier spec`_ (i.e. the root of "
#~ "the dependency graph for the lock "
#~ "file)."
#~ msgstr ""

#~ msgid ""
#~ "Lockers MUST only allow specifiers which"
#~ " may be satisfiable by the lock "
#~ "file and the dependency graph the "
#~ "lock file encodes. Lockers MUST "
#~ "normalize project names according to the"
#~ " `simple repository API`_."
#~ msgstr ""

#~ msgid "``[package]``"
#~ msgstr ""

#~ msgid ""
#~ "A table containing arrays of tables "
#~ "for each dependency recorded in the "
#~ "lock file."
#~ msgstr ""

#~ msgid ""
#~ "Each key of the table is the "
#~ "name of a package which MUST be"
#~ " normalized according to the `simple "
#~ "repository API`_. If extras are "
#~ "specified as part of the project "
#~ "to install, the extras are to be"
#~ " included in the key name and "
#~ "are to be sorted in lexicographic "
#~ "order."
#~ msgstr ""

#~ msgid "Within the file, the tables for the projects MUST be sorted by:"
#~ msgstr ""

#~ msgid "Extras via lexicographic order"
#~ msgstr ""

#~ msgid "``package.<name>.version``"
#~ msgstr ""

#~ msgid ""
#~ "A required string of the version "
#~ "of the package as specified by the"
#~ " `version specifiers spec`_."
#~ msgstr ""

#~ msgid "``package.<name>.needs``"
#~ msgstr ""

#~ msgid ""
#~ "An optional key containing an array "
#~ "of strings following the `dependency "
#~ "specifier spec`_ which specify what "
#~ "other packages this package depends on."
#~ " See ``metadata.needs`` for full details."
#~ msgstr ""

#~ msgid "``package.<name>.needed-by``"
#~ msgstr ""

#~ msgid ""
#~ "A key containing an array of "
#~ "package names which depend on this "
#~ "package. The package names MUST match"
#~ " the package name as used in "
#~ "the ``package`` table."
#~ msgstr ""

#~ msgid ""
#~ "The lack of a ``needed-by`` key"
#~ " infers that the package is a "
#~ "top-level package listed in "
#~ "``metadata.needs``."
#~ msgstr ""

#~ msgid "``package.<name>.code``"
#~ msgstr ""

#~ msgid ""
#~ "An array of tables listing files "
#~ "that are available to satisfy the "
#~ "installation of the package for the "
#~ "specified version in the ``version`` "
#~ "key."
#~ msgstr ""

#~ msgid ""
#~ "Each table has a ``type`` key "
#~ "which specifies how the code is "
#~ "stored. All other keys in the "
#~ "table are dependent on the value "
#~ "set for ``type``. The acceptable values"
#~ " for ``type`` are listed below; all"
#~ " other possible values are reserved "
#~ "for future use."
#~ msgstr ""

#~ msgid ""
#~ "Tables in the array MUST be sorted"
#~ " in lexicographic order of the value"
#~ " of ``type``, then lexicographic order "
#~ "for the value of ``url``."
#~ msgstr ""

#~ msgid ""
#~ "When recording a table, the fields "
#~ "SHOULD be listed in the order the"
#~ " fields are listed in this "
#~ "specification for consistency to make "
#~ "diffs of a lock file easier to "
#~ "read."
#~ msgstr ""

#~ msgid ""
#~ "For all types other than \"wheel\", "
#~ "an INSTALLER MAY refuse to install "
#~ "code to avoid arbitrary code execution"
#~ " during installation."
#~ msgstr ""

#~ msgid "An installer MUST verify the hash of any specified file."
#~ msgstr ""

#~ msgid "``type=\"wheel\"``"
#~ msgstr ""

#~ msgid "A `wheel file`_ for the package version."
#~ msgstr ""

#~ msgid "Supported keys in the table are:"
#~ msgstr ""

#~ msgid ""
#~ "``url``: a string of location of "
#~ "the wheel file (use the ``file:`` "
#~ "protocol for the local file system)"
#~ msgstr ""

#~ msgid ""
#~ "``hash-algorithm``: a string of the "
#~ "algorithm used to generate the hash "
#~ "value stored in ``hash-value``"
#~ msgstr ""

#~ msgid "``hash-value``: a string of the hash of the file contents"
#~ msgstr ""

#~ msgid ""
#~ "``interpreter-tag``: (optional) a string "
#~ "of the interpreter portion of the "
#~ "wheel tag as specified by the "
#~ "`platform compatibility tags`_ spec"
#~ msgstr ""

#~ msgid ""
#~ "``abi-tag``: (optional) a string of "
#~ "the ABI portion of the wheel tag"
#~ " as specified by the `platform "
#~ "compatibility tags`_ spec"
#~ msgstr ""

#~ msgid ""
#~ "``platform-tag``: (optional) a string of"
#~ " the platform portion of the wheel"
#~ " tag as specified by the `platform"
#~ " compatibility tags`_ spec"
#~ msgstr ""

#~ msgid ""
#~ "If the keys related to `platform "
#~ "compatibility tags`_ are absent then the"
#~ " installer MUST infer the tags from"
#~ " the URL's file name. If any of"
#~ " the `platform compatibility tags`_ are "
#~ "specified by a key in the table"
#~ " then a locker MUST provide all "
#~ "three related keys. The values of "
#~ "the keys may be compressed tags."
#~ msgstr ""

#~ msgid "``type=\"sdist\"``"
#~ msgstr ""

#~ msgid "A `source distribution file`_ (sdist) for the package version."
#~ msgstr ""

#~ msgid ""
#~ "``url``: a string of location of "
#~ "the sdist file (use the ``file:`` "
#~ "protocol for the local file system)"
#~ msgstr ""

#~ msgid "``type=\"git\"``"
#~ msgstr ""

#~ msgid "A Git_ version control repository for the package."
#~ msgstr ""

#~ msgid ""
#~ "``url``: a string of location of "
#~ "the repository (use the ``file:`` "
#~ "protocol for the local file system)"
#~ msgstr ""

#~ msgid ""
#~ "``commit``: a string of the commit "
#~ "of the repository which represents the"
#~ " version of the package"
#~ msgstr ""

#~ msgid ""
#~ "The repository MUST follow the `source"
#~ " distribution file`_ spec for source "
#~ "trees, otherwise an error is to be"
#~ " raised by the locker."
#~ msgstr ""

#~ msgid ""
#~ "As the commit ID for a Git "
#~ "repository is a hash of the "
#~ "repository's contents, there is no hash"
#~ " to verify."
#~ msgstr ""

#~ msgid "``type=\"source tree\"``"
#~ msgstr ""

#~ msgid "A source tree which can be used to build a wheel."
#~ msgstr ""

#~ msgid ""
#~ "``url``: a string of location of "
#~ "the source tree (use the ``file:`` "
#~ "protocol for the local file system)"
#~ msgstr ""

#~ msgid "``mime-type``: (optional) a string representing the MIME type of the"
#~ msgstr ""

#~ msgid "URL"
#~ msgstr ""

#~ msgid ""
#~ "``hash-algorithm``: (optional for a "
#~ "local directory) a string of the "
#~ "algorithm used to generate the hash "
#~ "value stored in ``hash-value``"
#~ msgstr ""

#~ msgid ""
#~ "``hash-value``: (optional for a local"
#~ " directory) a string of the hash "
#~ "of the file contents"
#~ msgstr ""

#~ msgid ""
#~ "The collection of files MUST follow "
#~ "the `source distribution file`_ spec for"
#~ " source trees, otherwise an error is"
#~ " to be raised by the locker."
#~ msgstr ""

#~ msgid ""
#~ "Installers MAY use the file extension,"
#~ " MIME type from HTTP headers, etc."
#~ " to infer whether they support the"
#~ " storage mechanism used for the "
#~ "source tree. If the MIME type "
#~ "cannot be inferred and it is not"
#~ " specified via ``mime-type`` then an"
#~ " error MUST be raised."
#~ msgstr ""

#~ msgid ""
#~ "If the source tree is NOT a "
#~ "local directory, then an installer MUST"
#~ " verify the hash value. Otherwise if"
#~ " the source tree is a local "
#~ "directory then the ``hash-algorithm`` "
#~ "and ``hash-value`` keys MUST be "
#~ "left out. The installer MAY warn "
#~ "the user of the use of a "
#~ "local directory due to the potential "
#~ "change in code since the lock file"
#~ " was created."
#~ msgstr ""

#~ msgid "Installer Expectations"
#~ msgstr ""

#~ msgid ""
#~ "Installers MUST implement the `direct "
#~ "URL origin of installed distributions "
#~ "spec`_ as all packages installed from"
#~ " a lock file inherently originate "
#~ "from a URL and not a search "
#~ "of an index by package name and"
#~ " version."
#~ msgstr ""

#~ msgid ""
#~ "Installers MUST error out if they "
#~ "encounter something they are unable to"
#~ " handle (e.g. lack of environment "
#~ "marker support)."
#~ msgstr ""

#~ msgid "Example Flow"
#~ msgstr ""

#~ msgid ""
#~ "Have the user specify which lock "
#~ "file they would like to use in "
#~ "``pyproject-lock.d`` (e.g. ``dev``, ``prod``)"
#~ msgstr ""

#~ msgid ""
#~ "Check if the environment supports what"
#~ " is specified in ``metadata.tags``; error"
#~ " out if it doesn't"
#~ msgstr ""

#~ msgid ""
#~ "Check if the environment supports what"
#~ " is specified in ``metadata.marker``; error"
#~ " out if it doesn't"
#~ msgstr ""

#~ msgid ""
#~ "Gather the list of package names "
#~ "from ``metadata.needs``, and for each "
#~ "listed package ..."
#~ msgstr ""

#~ msgid "Resolve any markers to find the appropriate package to install"
#~ msgstr ""

#~ msgid "Find the most appropriate code to install for the package"
#~ msgstr ""

#~ msgid ""
#~ "Repeat the above steps for packages "
#~ "listed in the ``needs`` key for "
#~ "each package found to install"
#~ msgstr ""

#~ msgid "For each project collected to install ..."
#~ msgstr ""

#~ msgid "Gather the specified code for the package"
#~ msgstr ""

#~ msgid "Verify hashes of code"
#~ msgstr ""

#~ msgid "Install the packages (if necessary)"
#~ msgstr ""

#~ msgid ""
#~ "As for pre-existing tools that "
#~ "have their own lock file, some "
#~ "updating will be required. Most document"
#~ " the lock file name, but not "
#~ "its contents, in which case the "
#~ "file name of the lock file(s) is"
#~ " the important part. For projects "
#~ "which do not commit their lock "
#~ "file to version control, they will "
#~ "need to update the equivalent of "
#~ "their ``.gitignore`` file. For projects "
#~ "that do commit their lock file to"
#~ " version control, what file(s) get "
#~ "committed will need an update."
#~ msgstr ""

#~ msgid ""
#~ "For projects which do document their "
#~ "lock file format like pipenv_, they "
#~ "will very likely need a new major"
#~ " version release."
#~ msgstr ""

#~ msgid ""
#~ "Specifically for Poetry_, it has an "
#~ "`export command <https://python-"
#~ "poetry.org/docs/cli/#export>`_ which should allow"
#~ " Poetry to support this lock file "
#~ "format even if the project chose "
#~ "not to adopt this PEP as Poetry's"
#~ " primary lock file format."
#~ msgstr ""

#~ msgid ""
#~ "A lock file should not introduce "
#~ "security issues but instead help solve"
#~ " them. By requiring the recording of"
#~ " hashes of code, a lock file is"
#~ " able to help prevent tampering with"
#~ " code since the hash details were "
#~ "recorded. A lock file also helps "
#~ "prevent unexpected package updates being "
#~ "installed which may be malicious."
#~ msgstr ""

#~ msgid ""
#~ "Teaching of this PEP will very "
#~ "much be dependent on the lockers "
#~ "and installers being used for day-"
#~ "to-day use. Conceptually, though, users "
#~ "could be taught that the ``pyproject-"
#~ "lock.d`` directory contains files which "
#~ "specify what should be installed for "
#~ "a project to work. The benefits of"
#~ " consistency and security should be "
#~ "emphasized to help users realize why "
#~ "they should care about lock files."
#~ msgstr ""

#~ msgid "No proof-of-concept or reference implementation currently exists."
#~ msgstr ""

#~ msgid "Alternative Name to ``pyproject-lock.d``"
#~ msgstr ""

#~ msgid ""
#~ "The name ``__lockfile__`` was briefly "
#~ "considered, but the directory would not"
#~ " sort next to ``pyproject.toml`` in "
#~ "instances where files and directories "
#~ "were sorted together in lexicographic "
#~ "order. The current naming is also "
#~ "more obvious in terms of its "
#~ "relationship to ``pyproject.toml``."
#~ msgstr ""

#~ msgid ""
#~ "At one point the idea of not "
#~ "using a directory of lock files "
#~ "but a single lock file which "
#~ "contained all possible lock information "
#~ "was considered. But it quickly became"
#~ " apparent that trying to devise a "
#~ "data format which could encompass both"
#~ " a lock file format which could "
#~ "support multiple environments as well as"
#~ " strict lock outcomes for reproducible "
#~ "builds would become quite complex and"
#~ " cumbersome."
#~ msgstr ""

#~ msgid ""
#~ "This idea was eventually rejected due"
#~ " to the number of combinations of "
#~ "potential PEP 508 environment markers. "
#~ "The decision was made that trying "
#~ "to have lockers generate all possible"
#~ " combinations when a project wants to"
#~ " be cross-platform would be too "
#~ "much."
#~ msgstr ""

#~ msgid ""
#~ "Being Concerned About Different Dependencies"
#~ " Per Wheel File For a Project"
#~ msgstr ""

#~ msgid ""
#~ "It is technically possible for a "
#~ "project to specify different dependencies "
#~ "between its various wheel files. Taking"
#~ " that into consideration would then "
#~ "require the lock file to operate "
#~ "not per-project but per-file. "
#~ "Luckily, specifying different dependencies in"
#~ " this way is very rare and "
#~ "frowned upon and so it was deemed"
#~ " not worth supporting."
#~ msgstr ""

#~ msgid ""
#~ "Instead of having the ``metadata.tags`` "
#~ "field there was a suggestion of "
#~ "encoding the tags into the file "
#~ "name. But due to the addition of"
#~ " the ``metadata.marker`` field and what "
#~ "to do when no tags were needed,"
#~ " the idea was dropped."
#~ msgstr ""

#~ msgid "Using Semantic Versioning for ``version``"
#~ msgstr ""

#~ msgid ""
#~ "Instead of a monotonically increasing "
#~ "integer, using a float was considered"
#~ " to attempt to convey semantic "
#~ "versioning. In the end, though, it "
#~ "was deemed more hassle than it was"
#~ " worth as adding a new key "
#~ "would likely constitute a \"major\" "
#~ "version change (only if the key "
#~ "was entirely optional would it be "
#~ "considered \"minor\"), and experience with "
#~ "the `core metadata spec`_ suggests "
#~ "there's a bigger chance parsing will "
#~ "be relaxed and made more strict "
#~ "which is also a \"major\" change. "
#~ "As such, the simplicity of using "
#~ "an integer made sense."
#~ msgstr ""

#~ msgid "Alternative Names for ``needs``"
#~ msgstr ""

#~ msgid ""
#~ "Some other names for what became "
#~ "``needs`` were ``installs`` and "
#~ "``dependencies``. In the end a Python"
#~ " beginner was asked which term they"
#~ " preferred and they found ``needs`` "
#~ "clearer. Since there wasn't any reason"
#~ " to disagree with that, the decision"
#~ " was to go with ``needs``."
#~ msgstr ""

#~ msgid "Alternative Names for ``needed-by``"
#~ msgstr ""

#~ msgid ""
#~ "Other names that were considered were"
#~ " ``dependents``, ``depended-by``, , "
#~ "``supports`` and ``required-by``. In the"
#~ " end, ``needed-by`` made sense and"
#~ " tied into ``needs``."
#~ msgstr ""

#~ msgid "Only Allowing a Single Code Location For a Project"
#~ msgstr ""

#~ msgid ""
#~ "While reproducibility is serviced better "
#~ "by only allowing a single code "
#~ "location, it limits usability for "
#~ "situations where one wants to support"
#~ " multiple platforms with a single "
#~ "lock file (which the community has "
#~ "shown is desired)."
#~ msgstr ""

#~ msgid "Support for Branches and Tags for Git"
#~ msgstr ""

#~ msgid ""
#~ "Due to the `direct URL origin of"
#~ " installed distributions spec`_ supporting "
#~ "the specification of branches and tags,"
#~ " it was suggested that lock files "
#~ "support the same thing. But because "
#~ "branches and tags can change what "
#~ "commit they point to between locking "
#~ "and installation, that was viewed as "
#~ "a security concern (Git commit IDs "
#~ "are hashes of metadata and thus "
#~ "are viewed as immutable)."
#~ msgstr ""

#~ msgid ""
#~ "This PEP chose to standardize around "
#~ "an artifact instead of an API (ala"
#~ " PEP 621). This would allow for "
#~ "more tool integrations as it removes "
#~ "the need to specifically use Python "
#~ "to do things such as create a "
#~ "lock file, update it, or even "
#~ "install packages listed in a lock "
#~ "file. It also allows for easier "
#~ "introspection by forcing dependency graph "
#~ "details to be written in a "
#~ "human-readable format. It also allows "
#~ "for easier sharing of knowledge by "
#~ "standardizing what people need to know"
#~ " more (e.g. tutorials become more "
#~ "portable between tools when it comes "
#~ "to understanding the artifact they "
#~ "produce). It's also simply the approach"
#~ " other language communities have taken "
#~ "and seem to be happy with."
#~ msgstr ""

#~ msgid "Allow for Tool-Specific ``type`` Values"
#~ msgstr ""

#~ msgid ""
#~ "It has been suggested to allow for"
#~ " custom ``type`` values in the "
#~ "``code`` table. They would be prefixed"
#~ " with ``x-`` and followed by the "
#~ "tool's name and then the type, "
#~ "i.e. ``x-<tool>-<type>``. This would provide"
#~ " enough flexibility for things such "
#~ "as other version control systems, "
#~ "innovative container formats, etc. to be"
#~ " officially usable in a lock file."
#~ msgstr ""

#~ msgid "Support Variable Expansion in the ``url`` field"
#~ msgstr ""

#~ msgid ""
#~ "This could include predefined variables "
#~ "like ``PROJECT_ROOT`` for the directory "
#~ "containing ``pyproject-lock.d`` so URLs "
#~ "to local directories and files could "
#~ "be relative to the project itself."
#~ msgstr ""

#~ msgid ""
#~ "Environment variables could be supported "
#~ "to avoid hardcoding things such as "
#~ "user credentials for Git."
#~ msgstr ""

#~ msgid "Don't Require Lock Files Be in a ``pyproject-lock.d`` directory"
#~ msgstr ""

#~ msgid ""
#~ "It has been suggested that since "
#~ "installers may very well allow users "
#~ "to specify the path to a lock "
#~ "file that having this PEP say that"
#~ " \"MUST be kept in a directory "
#~ "named ``pyproject-lock.d``\" is pointless "
#~ "as it is bound to be broken. "
#~ "As such, the suggestion is to "
#~ "change \"MUST\" to \"SHOULD\"."
#~ msgstr ""

#~ msgid "Record the Date of When the Lock File was Generated"
#~ msgstr ""

#~ msgid ""
#~ "Since the modification date is not "
#~ "guaranteed to match when the lock "
#~ "file was generated, it has been "
#~ "suggested to record the date as "
#~ "part of the file's metadata. The "
#~ "question, though, is how useful is "
#~ "this information and can lockers that"
#~ " care put it into their ``[tool]``"
#~ " table instead of mandating it be "
#~ "set?"
#~ msgstr ""

#~ msgid "Locking Build Dependencies"
#~ msgstr ""

#~ msgid ""
#~ "Thanks to PEP 518, source trees "
#~ "and sdists can specify what build "
#~ "tools must be installed in order "
#~ "to build a wheel (or sdist in "
#~ "the case of a source tree). It "
#~ "has been suggested that the lock "
#~ "file also record such packages so "
#~ "to increase how reproducible an "
#~ "installation can be."
#~ msgstr ""

#~ msgid ""
#~ "There is nothing currently in this "
#~ "PEP, though, that prohibits a locker "
#~ "from recording build tools thanks to "
#~ "``metadata.needs`` acting as the entry "
#~ "point for calculating what to install."
#~ " There is also a cost in "
#~ "downloading all potential sdists and "
#~ "source trees, reading their ``pyproject.toml``"
#~ " files, and then calculating their "
#~ "build dependencies for locking purposes "
#~ "for which not everyone will want "
#~ "to pay the cost for."
#~ msgstr ""

#~ msgid "Recording the ``Requires-Dist`` Input to the Locker's Resolver"
#~ msgstr ""

#~ msgid ""
#~ "While the ``needs`` key allows for "
#~ "recording dependency specifiers, this PEP "
#~ "does not currently require the ``needs``"
#~ " key to record the **exact** "
#~ "``Requires-Dist`` metadata that was used"
#~ " to calculate the lock file. It "
#~ "has been suggested that recording the"
#~ " inputs would help in auditing the"
#~ " outcome of the lock file."
#~ msgstr ""

#~ msgid ""
#~ "If this were to be done, it "
#~ "would be an key named ``requested`` "
#~ "which lived along side ``needs`` and "
#~ "would only be specified if it "
#~ "would differ from what is specified "
#~ "in ``needs``."
#~ msgstr ""

#~ msgid "Providing ``marker`` and ``tags`` per Package"
#~ msgstr ""

#~ msgid ""
#~ "It has been suggested to allow for"
#~ " the ``marker`` and ``tags`` keys as"
#~ " found in the ``[metadata]`` table in"
#~ " ``[package]`` tables as well. This "
#~ "would allow lockers to specify when "
#~ "a version of a package should be"
#~ " considered. This also has the "
#~ "potential for lowering computational costs "
#~ "for installers by assisting them in "
#~ "knowing when to remove a package "
#~ "version from consideration."
#~ msgstr ""

#~ msgid ""
#~ "This does, though, somewhat duplicate "
#~ "environment markers being kept in the"
#~ " ``needs`` array."
#~ msgstr ""

#~ msgid ""
#~ "Thanks to Andrea McInnes for settling"
#~ " the bikeshedding and choosing the "
#~ "paint colour of ``needs``."
#~ msgstr ""

