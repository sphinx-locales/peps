# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0335.txt
msgid "PEP"
msgstr ""

#: ../../pep-0335.txt:1
msgid "335"
msgstr ""

#: ../../pep-0335.txt
msgid "Title"
msgstr ""

#: ../../pep-0335.txt:2
msgid "Overloadable Boolean Operators"
msgstr ""

#: ../../pep-0335.txt
msgid "Author"
msgstr ""

#: ../../pep-0335.txt:5
msgid "Gregory Ewing <greg.ewing@canterbury.ac.nz>"
msgstr ""

#: ../../pep-0335.txt
msgid "Status"
msgstr ""

#: ../../pep-0335.txt:6
msgid "Rejected"
msgstr ""

#: ../../pep-0335.txt
msgid "Type"
msgstr ""

#: ../../pep-0335.txt:7
msgid "Standards Track"
msgstr ""

#: ../../pep-0335.txt
msgid "Created"
msgstr ""

#: ../../pep-0335.txt:9
msgid "29-Aug-2004"
msgstr ""

#: ../../pep-0335.txt
msgid "Python-Version"
msgstr ""

#: ../../pep-0335.txt:10
msgid "3.3"
msgstr ""

#: ../../pep-0335.txt
msgid "Post-History"
msgstr ""

#: ../../pep-0335.txt:11
msgid "05-Sep-2004, 30-Sep-2011, 25-Oct-2011"
msgstr ""

#: ../../pep-0335.txt:14
msgid "Rejection Notice"
msgstr ""

#: ../../pep-0335.txt:16
msgid ""
"This PEP was rejected. See https://mail.python.org/pipermail/python-"
"dev/2012-March/117510.html"
msgstr ""

#: ../../pep-0335.txt:20
msgid "Abstract"
msgstr ""

#: ../../pep-0335.txt:22
msgid ""
"This PEP proposes an extension to permit objects to define their own "
"meanings for the boolean operators 'and', 'or' and 'not', and suggests an"
" efficient strategy for implementation.  A prototype of this "
"implementation is available for download."
msgstr ""

#: ../../pep-0335.txt:29
msgid "Background"
msgstr ""

#: ../../pep-0335.txt:31
msgid ""
"Python does not currently provide any '__xxx__' special methods "
"corresponding to the 'and', 'or' and 'not' boolean operators.  In the "
"case of 'and' and 'or', the most likely reason is that these operators "
"have short-circuiting semantics, i.e. the second operand is not evaluated"
" if the result can be determined from the first operand.  The usual "
"technique of providing special methods for these operators therefore "
"would not work."
msgstr ""

#: ../../pep-0335.txt:39
msgid ""
"There is no such difficulty in the case of 'not', however, and it would "
"be straightforward to provide a special method for this operator.  The "
"rest of this proposal will therefore concentrate mainly on providing a "
"way to overload 'and' and 'or'."
msgstr ""

#: ../../pep-0335.txt:46
msgid "Motivation"
msgstr ""

#: ../../pep-0335.txt:48
msgid ""
"There are many applications in which it is natural to provide custom "
"meanings for Python operators, and in some of these, having boolean "
"operators excluded from those able to be customised can be inconvenient."
"  Examples include:"
msgstr ""

#: ../../pep-0335.txt:53
msgid ""
"NumPy, in which almost all the operators are defined on arrays so as to "
"perform the appropriate operation between corresponding elements, and "
"return an array of the results.  For consistency, one would expect a "
"boolean operation between two arrays to return an array of booleans, but "
"this is not currently possible."
msgstr ""

#: ../../pep-0335.txt:60
msgid ""
"There is a precedent for an extension of this kind: comparison operators "
"were originally restricted to returning boolean results, and rich "
"comparisons were added so that comparisons of NumPy arrays could return "
"arrays of booleans."
msgstr ""

#: ../../pep-0335.txt:65
msgid ""
"A symbolic algebra system, in which a Python expression is evaluated in "
"an environment which results in it constructing a tree of objects "
"corresponding to the structure of the expression."
msgstr ""

#: ../../pep-0335.txt:69
msgid ""
"A relational database interface, in which a Python expression is used to "
"construct an SQL query."
msgstr ""

#: ../../pep-0335.txt:72
msgid ""
"A workaround often suggested is to use the bitwise operators '&', '|' and"
" '~' in place of 'and', 'or' and 'not', but this has some drawbacks:"
msgstr ""

#: ../../pep-0335.txt:76
msgid ""
"The precedence of these is different in relation to the other operators, "
"and they may already be in use for other purposes (as in example 1)."
msgstr ""

#: ../../pep-0335.txt:79
msgid ""
"It is aesthetically displeasing to force users to use something other "
"than the most obvious syntax for what they are trying to express.  This "
"would be particularly acute in the case of example 3, considering that "
"boolean operations are a staple of SQL queries."
msgstr ""

#: ../../pep-0335.txt:84
msgid ""
"Bitwise operators do not provide a solution to the problem of chained "
"comparisons such as 'a < b < c' which involve an implicit 'and' "
"operation. Such expressions currently cannot be used at all on data types"
" such as NumPy arrays where the result of a comparison cannot be treated "
"as having normal boolean semantics; they must be expanded into something "
"like (a < b) & (b < c), losing a considerable amount of clarity."
msgstr ""

#: ../../pep-0335.txt:94
msgid "Rationale"
msgstr ""

#: ../../pep-0335.txt:96
msgid ""
"The requirements for a successful solution to the problem of allowing "
"boolean operators to be customised are:"
msgstr ""

#: ../../pep-0335.txt:99
msgid ""
"In the default case (where there is no customisation), the existing "
"short-circuiting semantics must be preserved."
msgstr ""

#: ../../pep-0335.txt:102
msgid "There must not be any appreciable loss of speed in the default case."
msgstr ""

#: ../../pep-0335.txt:105
msgid ""
"Ideally, the customisation mechanism should allow the object to provide "
"either short-circuiting or non-short-circuiting semantics, at its "
"discretion."
msgstr ""

#: ../../pep-0335.txt:109
msgid ""
"One obvious strategy, that has been previously suggested, is to pass into"
" the special method the first argument and a function for evaluating the "
"second argument.  This would satisfy requirements 1 and 3, but not "
"requirement 2, since it would incur the overhead of constructing a "
"function object and possibly a Python function call on every boolean "
"operation.  Therefore, it will not be considered further here."
msgstr ""

#: ../../pep-0335.txt:117
msgid ""
"The following section proposes a strategy that addresses all three "
"requirements.  A `prototype implementation`_ of this strategy is "
"available for download."
msgstr ""

#: ../../pep-0335.txt:126
msgid "Specification"
msgstr ""

#: ../../pep-0335.txt:129
msgid "Special Methods"
msgstr ""

#: ../../pep-0335.txt:131
msgid "At the Python level, objects may define the following special methods."
msgstr ""

#: ../../pep-0335.txt:134
msgid "Unary"
msgstr ""

#: ../../pep-0335.txt:134
msgid "Binary, phase 1"
msgstr ""

#: ../../pep-0335.txt:134
msgid "Binary, phase 2"
msgstr ""

#: ../../pep-0335.txt:136
msgid "__not__(self)"
msgstr ""

#: ../../pep-0335.txt:136
msgid "__and1__(self)"
msgstr ""

#: ../../pep-0335.txt:137
msgid "__or1__(self)"
msgstr ""

#: ../../pep-0335.txt:136
msgid "__and2__(self, other)"
msgstr ""

#: ../../pep-0335.txt:137
msgid "__or2__(self, other)"
msgstr ""

#: ../../pep-0335.txt:138
msgid "__rand2__(self, other)"
msgstr ""

#: ../../pep-0335.txt:139
msgid "__ror2__(self, other)"
msgstr ""

#: ../../pep-0335.txt:142
msgid ""
"The __not__ method, if defined, implements the 'not' operator.  If it is "
"not defined, or it returns NotImplemented, existing semantics are used."
msgstr ""

#: ../../pep-0335.txt:146
msgid ""
"To permit short-circuiting, processing of the 'and' and 'or' operators is"
" split into two phases.  Phase 1 occurs after evaluation of the first "
"operand but before the second.  If the first operand defines the relevant"
" phase 1 method, it is called with the first operand as argument.  If "
"that method can determine the result without needing the second operand, "
"it returns the result, and further processing is skipped."
msgstr ""

#: ../../pep-0335.txt:154
msgid ""
"If the phase 1 method determines that the second operand is needed, it "
"returns the special value NeedOtherOperand.  This triggers the evaluation"
" of the second operand, and the calling of a relevant phase 2 method. "
"During phase 2, the __and2__/__rand2__ and __or2__/__ror2__ method pairs "
"work as for other binary operators."
msgstr ""

#: ../../pep-0335.txt:160
msgid ""
"Processing falls back to existing semantics if at any stage a relevant "
"special method is not found or returns NotImplemented."
msgstr ""

#: ../../pep-0335.txt:163
msgid ""
"As a special case, if the first operand defines a phase 2 method but no "
"corresponding phase 1 method, the second operand is always evaluated and "
"the phase 2 method called.  This allows an object which does not want "
"short-circuiting semantics to simply implement the phase 2 methods and "
"ignore phase 1."
msgstr ""

#: ../../pep-0335.txt:171
msgid "Bytecodes"
msgstr ""

#: ../../pep-0335.txt:173
msgid ""
"The patch adds four new bytecodes, LOGICAL_AND_1, LOGICAL_AND_2, "
"LOGICAL_OR_1 and LOGICAL_OR_2.  As an example of their use, the bytecode "
"generated for an 'and' expression looks like this::"
msgstr ""

#: ../../pep-0335.txt:188
msgid ""
"The LOGICAL_AND_1 bytecode performs phase 1 processing.  If it determines"
" that the second operand is needed, it leaves the first operand on the "
"stack and continues with the following code.  Otherwise it pops the first"
" operand, pushes the result and branches to L."
msgstr ""

#: ../../pep-0335.txt:193
msgid ""
"The LOGICAL_AND_2 bytecode performs phase 2 processing, popping both "
"operands and pushing the result."
msgstr ""

#: ../../pep-0335.txt:198
msgid "Type Slots"
msgstr ""

#: ../../pep-0335.txt:200
msgid ""
"At the C level, the new special methods are manifested as five new slots "
"in the type object.  In the patch, they are added to the tp_as_number "
"substructure, since this allows making use of some existing code for "
"dealing with unary and binary operators.  Their existence is signalled by"
" a new type flag, Py_TPFLAGS_HAVE_BOOLEAN_OVERLOAD."
msgstr ""

#: ../../pep-0335.txt:207
msgid "The new type slots are::"
msgstr ""

#: ../../pep-0335.txt:217
msgid "Python/C API Functions"
msgstr ""

#: ../../pep-0335.txt:219
msgid ""
"There are also five new Python/C API functions corresponding to the new "
"operations::"
msgstr ""

#: ../../pep-0335.txt:230
msgid "Alternatives and Optimisations"
msgstr ""

#: ../../pep-0335.txt:232
msgid ""
"This section discusses some possible variations on the proposal, and ways"
" in which the bytecode sequences generated for boolean expressions could "
"be optimised."
msgstr ""

#: ../../pep-0335.txt:237
msgid "Reduced special method set"
msgstr ""

#: ../../pep-0335.txt:239
msgid ""
"For completeness, the full version of this proposal includes a mechanism "
"for types to define their own customised short-circuiting behaviour. "
"However, the full mechanism is not needed to address the main use cases "
"put forward here, and it would be possible to define a simplified version"
" that only includes the phase 2 methods. There would then only be 5 new "
"special methods (__and2__, __rand2__, __or2__, __ror2__, __not__) with 3 "
"associated type slots and 3 API functions."
msgstr ""

#: ../../pep-0335.txt:248
msgid ""
"This simplified version could be expanded to the full version later if "
"desired."
msgstr ""

#: ../../pep-0335.txt:252
msgid "Additional bytecodes"
msgstr ""

#: ../../pep-0335.txt:254
msgid ""
"As defined here, the bytecode sequence for code that branches on the "
"result of a boolean expression would be slightly longer than it currently"
" is. For example, in Python 2.7,"
msgstr ""

#: ../../pep-0335.txt:265
msgid "generates"
msgstr ""

#: ../../pep-0335.txt:279
msgid "Under this proposal as described so far, it would become something like"
msgstr ""

#: ../../pep-0335.txt:295
msgid ""
"This involves executing one extra bytecode in the short-circuiting case "
"and two extra bytecodes in the non-short-circuiting case."
msgstr ""

#: ../../pep-0335.txt:298
msgid ""
"However, by introducing extra bytecodes that combine the logical "
"operations with testing and branching on the result, it can be reduced to"
" the same number of bytecodes as the original:"
msgstr ""

#: ../../pep-0335.txt:315
msgid ""
"Here, AND1_JUMP performs phase 1 processing as above, and then examines "
"the result. If there is a result, it is popped from the stack, its truth "
"value is tested and a branch taken to one of two locations."
msgstr ""

#: ../../pep-0335.txt:320
msgid ""
"Otherwise, the first operand is left on the stack and execution continues"
" to the next bytecode. The AND2_JUMP_IF_FALSE bytecode performs phase 2 "
"processing, pops the result and branches if it tests false"
msgstr ""

#: ../../pep-0335.txt:325
msgid ""
"For the 'or' operator, there would be corresponding OR1_JUMP and "
"OR2_JUMP_IF_TRUE bytecodes."
msgstr ""

#: ../../pep-0335.txt:328
msgid ""
"If the simplified version without phase 1 methods is used, then early "
"exiting can only occur if the first operand is false for 'and' and true "
"for 'or'. Consequently, the two-target AND1_JUMP and OR1_JUMP bytecodes "
"can be replaced with AND1_JUMP_IF_FALSE and OR1_JUMP_IF_TRUE, these being"
" ordinary branch instructions with only one target."
msgstr ""

#: ../../pep-0335.txt:336
msgid "Optimisation of 'not'"
msgstr ""

#: ../../pep-0335.txt:338
msgid ""
"Recent versions of Python implement a simple optimisation in which "
"branching on a negated boolean expression is implemented by reversing the"
" sense of the branch, saving a UNARY_NOT opcode."
msgstr ""

#: ../../pep-0335.txt:342
msgid ""
"Taking a strict view, this optimisation should no longer be performed, "
"because the 'not' operator may be overridden to produce quite different "
"results from usual. However, in typical use cases, it is not envisaged "
"that expressions involving customised boolean operations will be used for"
" branching -- it is much more likely that the result will be used in some"
" other way."
msgstr ""

#: ../../pep-0335.txt:349
msgid ""
"Therefore, it would probably do little harm to specify that the compiler "
"is allowed to use the laws of boolean algebra to simplify any expression "
"that appears directly in a boolean context. If this is inconvenient, the "
"result can always be assigned to a temporary name first."
msgstr ""

#: ../../pep-0335.txt:355
msgid ""
"This would allow the existing 'not' optimisation to remain, and would "
"permit future extensions of it such as using De Morgan's laws to extend "
"it deeper into the expression."
msgstr ""

#: ../../pep-0335.txt:361
msgid "Usage Examples"
msgstr ""

#: ../../pep-0335.txt:364
msgid "Example 1: NumPy Arrays"
msgstr ""

#: ../../pep-0335.txt:409
msgid "Example 1 Output"
msgstr ""

#: ../../pep-0335.txt:423
msgid "Example 2: Database Queries"
msgstr ""

#: ../../pep-0335.txt:523
msgid "Example 2 Output"
msgstr ""

#: ../../pep-0335.txt:534
msgid "Copyright"
msgstr ""

#: ../../pep-0335.txt:536
msgid "This document has been placed in the public domain."
msgstr ""

