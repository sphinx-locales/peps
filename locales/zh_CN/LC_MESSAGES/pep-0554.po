# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0554.rst
msgid "PEP"
msgstr ""

#: ../../pep-0554.rst:1
msgid "554"
msgstr ""

#: ../../pep-0554.rst
msgid "Title"
msgstr ""

#: ../../pep-0554.rst:2
msgid "Multiple Interpreters in the Stdlib"
msgstr ""

#: ../../pep-0554.rst
msgid "Author"
msgstr ""

#: ../../pep-0554.rst:3
msgid "Eric Snow <ericsnowcurrently@gmail.com>"
msgstr ""

#: ../../pep-0554.rst
msgid "BDFL-Delegate"
msgstr ""

#: ../../pep-0554.rst:4
msgid "Antoine Pitrou <antoine@python.org>"
msgstr ""

#: ../../pep-0554.rst
msgid "Status"
msgstr ""

#: ../../pep-0554.rst:5
msgid "Draft"
msgstr ""

#: ../../pep-0554.rst
msgid "Type"
msgstr ""

#: ../../pep-0554.rst:6
msgid "Standards Track"
msgstr ""

#: ../../pep-0554.rst
msgid "Created"
msgstr ""

#: ../../pep-0554.rst:8
msgid "05-Sep-2017"
msgstr ""

#: ../../pep-0554.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0554.rst:9
msgid "3.10"
msgstr ""

#: ../../pep-0554.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0554.rst:10
msgid ""
"07-Sep-2017, 08-Sep-2017, 13-Sep-2017, 05-Dec-2017, 09-May-2018, "
"20-Apr-2020, 04-May-2020"
msgstr ""

#: ../../pep-0554.rst:15
msgid "Abstract"
msgstr ""

#: ../../pep-0554.rst:17
msgid ""
"CPython has supported multiple interpreters in the same process (AKA "
"\"subinterpreters\") since version 1.5 (1997).  The feature has been "
"available via the C-API. [c-api]_  Subinterpreters operate in `relative "
"isolation from one another <Interpreter Isolation_>`_, which facilitates "
"novel alternative approaches to `concurrency <Concurrency_>`_."
msgstr ""

#: ../../pep-0554.rst:24
msgid ""
"This proposal introduces the stdlib ``interpreters`` module.  The module "
"will be `provisional <Provisional Status_>`_.  It exposes the basic "
"functionality of subinterpreters already provided by the C-API, along "
"with new (basic) functionality for sharing data between interpreters."
msgstr ""

#: ../../pep-0554.rst:31
msgid "A Disclaimer about the GIL"
msgstr ""

#: ../../pep-0554.rst:33
msgid ""
"To avoid any confusion up front:  This PEP is unrelated to any efforts to"
" stop sharing the GIL between subinterpreters.  At most this proposal "
"will allow users to take advantage of any results of work on the GIL. The"
" position here is that exposing subinterpreters to Python code is worth "
"doing, even if they still share the GIL."
msgstr ""

#: ../../pep-0554.rst:41
msgid "Proposal"
msgstr ""

#: ../../pep-0554.rst:43
msgid ""
"The ``interpreters`` module will be added to the stdlib.  To help authors"
" of extension modules, a new page will be added to the `Extending Python "
"<extension-docs_>`_ docs.  More information on both is found in the "
"immediately following sections."
msgstr ""

#: ../../pep-0554.rst:49
msgid "The \"interpreters\" Module"
msgstr ""

#: ../../pep-0554.rst:51
msgid ""
"The ``interpreters`` module will provide a high-level interface to "
"subinterpreters and wrap a new low-level ``_interpreters`` (in the same "
"way as the ``threading`` module).  See the `Examples`_ section for "
"concrete usage and use cases."
msgstr ""

#: ../../pep-0554.rst:56
msgid ""
"Along with exposing the existing (in CPython) subinterpreter support, the"
" module will also provide a mechanism for sharing data between "
"interpreters.  This mechanism centers around \"channels\", which are "
"similar to queues and pipes."
msgstr ""

#: ../../pep-0554.rst:61
msgid ""
"Note that *objects* are not shared between interpreters since they are "
"tied to the interpreter in which they were created.  Instead, the "
"objects' *data* is passed between interpreters.  See the `Shared data`_ "
"section for more details about sharing between interpreters."
msgstr ""

#: ../../pep-0554.rst:66
msgid "At first only the following types will be supported for sharing:"
msgstr ""

#: ../../pep-0554.rst:68 ../../pep-0554.rst:622
msgid "None"
msgstr ""

#: ../../pep-0554.rst:69 ../../pep-0554.rst:623
msgid "bytes"
msgstr ""

#: ../../pep-0554.rst:70 ../../pep-0554.rst:624
msgid "str"
msgstr ""

#: ../../pep-0554.rst:71 ../../pep-0554.rst:625
msgid "int"
msgstr ""

#: ../../pep-0554.rst:72
msgid "PEP 554 channels"
msgstr ""

#: ../../pep-0554.rst:74
msgid ""
"Support for other basic types (e.g. bool, float, Ellipsis) will be added "
"later."
msgstr ""

#: ../../pep-0554.rst:77
msgid "API summary for interpreters module"
msgstr ""

#: ../../pep-0554.rst:79
msgid ""
"Here is a summary of the API for the ``interpreters`` module.  For a more"
" in-depth explanation of the proposed classes and functions, see the "
"`\"interpreters\" Module API`_ section below."
msgstr ""

#: ../../pep-0554.rst:83
msgid "For creating and using interpreters:"
msgstr ""

#: ../../pep-0554.rst:86 ../../pep-0554.rst:100 ../../pep-0554.rst:127
#: ../../pep-0554.rst:141 ../../pep-0554.rst:157
msgid "signature"
msgstr ""

#: ../../pep-0554.rst:86 ../../pep-0554.rst:100 ../../pep-0554.rst:119
#: ../../pep-0554.rst:127 ../../pep-0554.rst:141 ../../pep-0554.rst:157
#: ../../pep-0554.rst:172
msgid "description"
msgstr ""

#: ../../pep-0554.rst:88
msgid "``list_all() -> [Interpreter]``"
msgstr ""

#: ../../pep-0554.rst:88
msgid "Get all existing interpreters."
msgstr ""

#: ../../pep-0554.rst:90
msgid "``get_current() -> Interpreter``"
msgstr ""

#: ../../pep-0554.rst:90
msgid "Get the currently running interpreter."
msgstr ""

#: ../../pep-0554.rst:92
msgid "``get_main() -> Interpreter``"
msgstr ""

#: ../../pep-0554.rst:92
msgid "Get the main interpreter."
msgstr ""

#: ../../pep-0554.rst:94
msgid "``create(*, isolated=True) -> Interpreter``"
msgstr ""

#: ../../pep-0554.rst:94
msgid "Initialize a new (idle) Python interpreter."
msgstr ""

#: ../../pep-0554.rst:102
msgid "``class Interpreter(id)``"
msgstr ""

#: ../../pep-0554.rst:102
msgid "A single interpreter."
msgstr ""

#: ../../pep-0554.rst:104 ../../pep-0554.rst:145 ../../pep-0554.rst:161
msgid "``.id``"
msgstr ""

#: ../../pep-0554.rst:104
msgid "The interpreter's ID (read-only)."
msgstr ""

#: ../../pep-0554.rst:106
msgid "``.isolated``"
msgstr ""

#: ../../pep-0554.rst:106
msgid "The interpreter's mode (read-only)."
msgstr ""

#: ../../pep-0554.rst:108
msgid "``.is_running() -> bool``"
msgstr ""

#: ../../pep-0554.rst:108
msgid "Is the interpreter currently executing code?"
msgstr ""

#: ../../pep-0554.rst:110
msgid "``.close()``"
msgstr ""

#: ../../pep-0554.rst:110
msgid "Finalize and destroy the interpreter."
msgstr ""

#: ../../pep-0554.rst:112
msgid "``.run(src_str, /, *, channels=None)``"
msgstr ""

#: ../../pep-0554.rst
msgid "Run the given source code in the interpreter."
msgstr ""

#: ../../pep-0554.rst
msgid "(This blocks the current thread until done.)"
msgstr ""

#: ../../pep-0554.rst:119 ../../pep-0554.rst:172
msgid "exception"
msgstr ""

#: ../../pep-0554.rst:119 ../../pep-0554.rst:172
msgid "base"
msgstr ""

#: ../../pep-0554.rst:121
msgid "``RunFailedError``"
msgstr ""

#: ../../pep-0554.rst:121
msgid "``RuntimeError``"
msgstr ""

#: ../../pep-0554.rst:121
msgid "Interpreter.run() resulted in an uncaught exception."
msgstr ""

#: ../../pep-0554.rst:124
msgid "For sharing data between interpreters:"
msgstr ""

#: ../../pep-0554.rst:129
msgid "``is_shareable(obj) -> Bool``"
msgstr ""

#: ../../pep-0554.rst
msgid "Can the object's data be shared"
msgstr ""

#: ../../pep-0554.rst
msgid "between interpreters?"
msgstr ""

#: ../../pep-0554.rst:132
msgid "``create_channel() -> (RecvChannel, SendChannel)``"
msgstr ""

#: ../../pep-0554.rst
msgid "Create a new channel for passing"
msgstr ""

#: ../../pep-0554.rst
msgid "data between interpreters."
msgstr ""

#: ../../pep-0554.rst:135
msgid "``list_all_channels() -> [(RecvChannel, SendChannel)]``"
msgstr ""

#: ../../pep-0554.rst:135
msgid "Get all open channels."
msgstr ""

#: ../../pep-0554.rst:143
msgid "``class RecvChannel(id)``"
msgstr ""

#: ../../pep-0554.rst:143
msgid "The receiving end of a channel."
msgstr ""

#: ../../pep-0554.rst:145 ../../pep-0554.rst:161
msgid "The channel's unique ID."
msgstr ""

#: ../../pep-0554.rst:147
msgid "``.recv() -> object``"
msgstr ""

#: ../../pep-0554.rst
msgid "Get the next object from the channel,"
msgstr ""

#: ../../pep-0554.rst
msgid "and wait if none have been sent."
msgstr ""

#: ../../pep-0554.rst:150
msgid "``.recv_nowait(default=None) -> object``"
msgstr ""

#: ../../pep-0554.rst
msgid "Like recv(), but return the default"
msgstr ""

#: ../../pep-0554.rst
msgid "instead of waiting."
msgstr ""

#: ../../pep-0554.rst:159
msgid "``class SendChannel(id)``"
msgstr ""

#: ../../pep-0554.rst:159
msgid "The sending end of a channel."
msgstr ""

#: ../../pep-0554.rst:163
msgid "``.send(obj)``"
msgstr ""

#: ../../pep-0554.rst
msgid "Send the object (i.e. its data) to the"
msgstr ""

#: ../../pep-0554.rst
msgid "receiving end of the channel and wait."
msgstr ""

#: ../../pep-0554.rst:166
msgid "``.send_nowait(obj)``"
msgstr ""

#: ../../pep-0554.rst
msgid "Like send(), but return False if not received."
msgstr ""

#: ../../pep-0554.rst:174 ../../pep-0554.rst:176 ../../pep-0554.rst:178
#: ../../pep-0554.rst:180 ../../pep-0554.rst:182
msgid "``ChannelError``"
msgstr ""

#: ../../pep-0554.rst:174
msgid "``Exception``"
msgstr ""

#: ../../pep-0554.rst:174
msgid "The base class for channel-related exceptions."
msgstr ""

#: ../../pep-0554.rst:176
msgid "``ChannelNotFoundError``"
msgstr ""

#: ../../pep-0554.rst:176
msgid "The identified channel was not found."
msgstr ""

#: ../../pep-0554.rst:178
msgid "``ChannelEmptyError``"
msgstr ""

#: ../../pep-0554.rst:178
msgid "The channel was unexpectedly empty."
msgstr ""

#: ../../pep-0554.rst:180
msgid "``ChannelNotEmptyError``"
msgstr ""

#: ../../pep-0554.rst:180
msgid "The channel was unexpectedly not empty."
msgstr ""

#: ../../pep-0554.rst:182
msgid "``NotReceivedError``"
msgstr ""

#: ../../pep-0554.rst:182
msgid "Nothing was waiting to receive a sent object."
msgstr ""

#: ../../pep-0554.rst:186
msgid "Help for Extension Module Maintainers"
msgstr ""

#: ../../pep-0554.rst:188
msgid ""
"Many extension modules do not support use in subinterpreters yet.  The "
"maintainers and users of such extension modules will both benefit when "
"they are updated to support subinterpreters.  In the meantime users may "
"become confused by failures when using subinterpreters, which could "
"negatively impact extension maintainers.  See `Concerns`_ below."
msgstr ""

#: ../../pep-0554.rst:194
msgid ""
"To mitigate that impact and accelerate compatibility, we will do the "
"following:"
msgstr ""

#: ../../pep-0554.rst:197
msgid ""
"be clear that extension modules are *not* required to support use in "
"subinterpreters"
msgstr ""

#: ../../pep-0554.rst:199
msgid ""
"raise ``ImportError`` when an incompatible (no PEP 489 support) module is"
" imported in a subinterpreter"
msgstr ""

#: ../../pep-0554.rst:201
msgid "provide resources (e.g. docs) to help maintainers reach compatibility"
msgstr ""

#: ../../pep-0554.rst:202
msgid ""
"reach out to the maintainers of Cython and of the most used extension "
"modules (on PyPI) to get feedback and possibly provide assistance"
msgstr ""

#: ../../pep-0554.rst:207
msgid "Examples"
msgstr ""

#: ../../pep-0554.rst:210
msgid "Run isolated code"
msgstr ""

#: ../../pep-0554.rst:220
msgid "Run in a thread"
msgstr ""

#: ../../pep-0554.rst:233
msgid "Pre-populate an interpreter"
msgstr ""

#: ../../pep-0554.rst:249
msgid "Handling an exception"
msgstr ""

#: ../../pep-0554.rst:262
msgid "Re-raising an exception"
msgstr ""

#: ../../pep-0554.rst:277
msgid "Note that this pattern is a candidate for later improvement."
msgstr ""

#: ../../pep-0554.rst:280
msgid "Synchronize using a channel"
msgstr ""

#: ../../pep-0554.rst:302
msgid "Sharing a file descriptor"
msgstr ""

#: ../../pep-0554.rst:330
msgid "Passing objects via marshal"
msgstr ""

#: ../../pep-0554.rst:359
msgid "Passing objects via pickle"
msgstr ""

#: ../../pep-0554.rst:388
msgid "Running a module"
msgstr ""

#: ../../pep-0554.rst:397
msgid "Running as script (including zip archives & directories)"
msgstr ""

#: ../../pep-0554.rst:406
msgid "Running in a thread pool executor"
msgstr ""

#: ../../pep-0554.rst:419
msgid "Rationale"
msgstr ""

#: ../../pep-0554.rst:421
msgid ""
"Running code in multiple interpreters provides a useful level of "
"isolation within the same process.  This can be leveraged in a number of "
"ways.  Furthermore, subinterpreters provide a well-defined framework in "
"which such isolation may extended."
msgstr ""

#: ../../pep-0554.rst:426
msgid ""
"Nick Coghlan explained some of the benefits through a comparison with "
"multi-processing [benefits]_::"
msgstr ""

#: ../../pep-0554.rst:447
msgid ""
"CPython has supported subinterpreters, with increasing levels of support,"
" since version 1.5.  While the feature has the potential to be a powerful"
" tool, subinterpreters have suffered from neglect because they are not "
"available directly from Python.  Exposing the existing functionality in "
"the stdlib will help reverse the situation."
msgstr ""

#: ../../pep-0554.rst:453
msgid ""
"This proposal is focused on enabling the fundamental capability of "
"multiple isolated interpreters in the same Python process.  This is a new"
" area for Python so there is relative uncertainly about the best tools to"
" provide as companions to subinterpreters.  Thus we minimize the "
"functionality we add in the proposal as much as possible."
msgstr ""

#: ../../pep-0554.rst:460
msgid "Concerns"
msgstr ""

#: ../../pep-0554.rst:462
msgid "\"subinterpreters are not worth the trouble\""
msgstr ""

#: ../../pep-0554.rst:464
msgid ""
"Some have argued that subinterpreters do not add sufficient benefit to "
"justify making them an official part of Python.  Adding features to the "
"language (or stdlib) has a cost in increasing the size of the language.  "
"So an addition must pay for itself.  In this case, subinterpreters "
"provide a novel concurrency model focused on isolated threads of "
"execution.  Furthermore, they provide an opportunity for changes in "
"CPython that will allow simultaneous use of multiple CPU cores (currently"
" prevented by the GIL)."
msgstr ""

#: ../../pep-0554.rst:473
msgid ""
"Alternatives to subinterpreters include threading, async, and "
"multiprocessing.  Threading is limited by the GIL and async isn't the "
"right solution for every problem (nor for every person). Multiprocessing "
"is likewise valuable in some but not all situations. Direct IPC (rather "
"than via the multiprocessing module) provides similar benefits but with "
"the same caveat."
msgstr ""

#: ../../pep-0554.rst:480
msgid ""
"Notably, subinterpreters are not intended as a replacement for any of the"
" above.  Certainly they overlap in some areas, but the benefits of "
"subinterpreters include isolation and (potentially) performance.  In "
"particular, subinterpreters provide a direct route to an alternate "
"concurrency model (e.g. CSP) which has found success elsewhere and will "
"appeal to some Python users.  That is the core value that the "
"``interpreters`` module will provide."
msgstr ""

#: ../../pep-0554.rst:488
msgid ""
"\"stdlib support for subinterpreters adds extra burden on C extension "
"authors\""
msgstr ""

#: ../../pep-0554.rst:491
msgid ""
"In the `Interpreter Isolation`_ section below we identify ways in which "
"isolation in CPython's subinterpreters is incomplete.  Most notable is "
"extension modules that use C globals to store internal state.  PEP 3121 "
"and PEP 489 provide a solution for most of the problem, but one still "
"remains. [petr-c-ext]_  Until that is resolved (see PEP 573), C extension"
" authors will face extra difficulty to support subinterpreters."
msgstr ""

#: ../../pep-0554.rst:499
msgid ""
"Consequently, projects that publish extension modules may face an "
"increased maintenance burden as their users start using subinterpreters, "
"where their modules may break.  This situation is limited to modules that"
" use C globals (or use libraries that use C globals) to store internal "
"state.  For numpy, the reported-bug rate is one every 6 months. [bug-"
"rate]_"
msgstr ""

#: ../../pep-0554.rst:506
msgid ""
"Ultimately this comes down to a question of how often it will be a "
"problem in practice: how many projects would be affected, how often their"
" users will be affected, what the additional maintenance burden will be "
"for projects, and what the overall benefit of subinterpreters is to "
"offset those costs.  The position of this PEP is that the actual extra "
"maintenance burden will be small and well below the threshold at which "
"subinterpreters are worth it."
msgstr ""

#: ../../pep-0554.rst:514
msgid ""
"\"creating a new concurrency API deserves much more thought and "
"experimentation, so the new module shouldn't go into the stdlib right "
"away, if ever\""
msgstr ""

#: ../../pep-0554.rst:518
msgid ""
"Introducing an API for a new concurrency model, like happened with "
"asyncio, is an extremely large project that requires a lot of careful "
"consideration.  It is not something that can be done a simply as this PEP"
" proposes and likely deserves significant time on PyPI to mature. (See "
"`Nathaniel's post <nathaniel-asyncio>`_ on python-dev.)"
msgstr ""

#: ../../pep-0554.rst:524
msgid ""
"However, this PEP does not propose any new concurrency API.  At most it "
"exposes minimal tools (e.g. subinterpreters, channels) which may be used "
"to write code that follows patterns associated with (relatively) new-to-"
"Python `concurrency models <Concurrency_>`_.  Those tools could also be "
"used as the basis for APIs for such concurrency models. Again, this PEP "
"does not propose any such API."
msgstr ""

#: ../../pep-0554.rst:531
msgid ""
"\"there is no point to exposing subinterpreters if they still share the "
"GIL\""
msgstr ""

#: ../../pep-0554.rst:533
msgid "\"the effort to make the GIL per-interpreter is disruptive and risky\""
msgstr ""

#: ../../pep-0554.rst:535
msgid ""
"A common misconception is that this PEP also includes a promise that "
"subinterpreters will no longer share the GIL.  When that is clarified, "
"the next question is \"what is the point?\".  This is already answered at"
" length in this PEP.  Just to be clear, the value lies in::"
msgstr ""

#: ../../pep-0554.rst:546
msgid ""
"\"data sharing can have a negative impact on cache performance in multi-"
"core scenarios\""
msgstr ""

#: ../../pep-0554.rst:549
msgid "(See [cache-line-ping-pong]_.)"
msgstr ""

#: ../../pep-0554.rst:551
msgid ""
"This shouldn't be a problem for now as we have no immediate plans to "
"actually share data between interpreters, instead focusing on copying."
msgstr ""

#: ../../pep-0554.rst:557
msgid "About Subinterpreters"
msgstr ""

#: ../../pep-0554.rst:560
msgid "Concurrency"
msgstr ""

#: ../../pep-0554.rst:562
msgid ""
"Concurrency is a challenging area of software development.  Decades of "
"research and practice have led to a wide variety of concurrency models, "
"each with different goals.  Most center on correctness and usability."
msgstr ""

#: ../../pep-0554.rst:566
msgid ""
"One class of concurrency models focuses on isolated threads of execution "
"that interoperate through some message passing scheme.  A notable example"
" is `Communicating Sequential Processes`_ (CSP) (upon which Go's "
"concurrency is roughly based).  The isolation inherent to subinterpreters"
" makes them well-suited to this approach."
msgstr ""

#: ../../pep-0554.rst:573
msgid "Shared data"
msgstr ""

#: ../../pep-0554.rst:575
msgid ""
"Subinterpreters are inherently isolated (with caveats explained below), "
"in contrast to threads.  So the same communicate-via-shared-memory "
"approach doesn't work.  Without an alternative, effective use of "
"concurrency via subinterpreters is significantly limited."
msgstr ""

#: ../../pep-0554.rst:580
msgid ""
"The key challenge here is that sharing objects between interpreters faces"
" complexity due to various constraints on object ownership, visibility, "
"and mutability.  At a conceptual level it's easier to reason about "
"concurrency when objects only exist in one interpreter at a time.  At a "
"technical level, CPython's current memory model limits how Python "
"*objects* may be shared safely between interpreters; effectively objects "
"are bound to the interpreter in which they were created.  Furthermore, "
"the complexity of *object* sharing increases as subinterpreters become "
"more isolated, e.g. after GIL removal."
msgstr ""

#: ../../pep-0554.rst:590
msgid ""
"Consequently,the mechanism for sharing needs to be carefully considered. "
"There are a number of valid solutions, several of which may be "
"appropriate to support in Python.  This proposal provides a single basic "
"solution: \"channels\".  Ultimately, any other solution will look similar"
" to the proposed one, which will set the precedent.  Note that the "
"implementation of ``Interpreter.run()`` will be done in a way that allows"
" for multiple solutions to coexist, but doing so is not technically a "
"part of the proposal here."
msgstr ""

#: ../../pep-0554.rst:599
msgid ""
"Regarding the proposed solution, \"channels\", it is a basic, opt-in data"
" sharing mechanism that draws inspiration from pipes, queues, and CSP's "
"channels. [fifo]_"
msgstr ""

#: ../../pep-0554.rst:603
msgid ""
"As simply described earlier by the API summary, channels have two "
"operations: send and receive.  A key characteristic of those operations "
"is that channels transmit data derived from Python objects rather than "
"the objects themselves.  When objects are sent, their data is extracted."
"  When the \"object\" is received in the other interpreter, the data is "
"converted back into an object owned by that interpreter."
msgstr ""

#: ../../pep-0554.rst:611
msgid ""
"To make this work, the mutable shared state will be managed by the Python"
" runtime, not by any of the interpreters.  Initially we will support only"
" one type of objects for shared state: the channels provided by "
"``create_channel()``.  Channels, in turn, will carefully manage passing "
"objects between interpreters."
msgstr ""

#: ../../pep-0554.rst:617
msgid ""
"This approach, including keeping the API minimal, helps us avoid further "
"exposing any underlying complexity to Python users.  Along those same "
"lines, we will initially restrict the types that may be passed through "
"channels to the following:"
msgstr ""

#: ../../pep-0554.rst:626
msgid "channels"
msgstr ""

#: ../../pep-0554.rst:628
msgid ""
"Limiting the initial shareable types is a practical matter, reducing the "
"potential complexity of the initial implementation.  There are a number "
"of strategies we may pursue in the future to expand supported objects and"
" object sharing strategies."
msgstr ""

#: ../../pep-0554.rst:634
msgid "Interpreter Isolation"
msgstr ""

#: ../../pep-0554.rst:636
msgid ""
"CPython's interpreters are intended to be strictly isolated from each "
"other.  Each interpreter has its own copy of all modules, classes, "
"functions, and variables.  The same applies to state in C, including in "
"extension modules.  The CPython C-API docs explain more. [caveats]_"
msgstr ""

#: ../../pep-0554.rst:641
msgid ""
"However, there are ways in which interpreters share some state.  First of"
" all, some process-global state remains shared:"
msgstr ""

#: ../../pep-0554.rst:644
msgid "file descriptors"
msgstr ""

#: ../../pep-0554.rst:645
msgid "builtin types (e.g. dict, bytes)"
msgstr ""

#: ../../pep-0554.rst:646
msgid "singletons (e.g. None)"
msgstr ""

#: ../../pep-0554.rst:647
msgid ""
"underlying static module data (e.g. functions) for "
"builtin/extension/frozen modules"
msgstr ""

#: ../../pep-0554.rst:650
msgid "There are no plans to change this."
msgstr ""

#: ../../pep-0554.rst:652
msgid ""
"Second, some isolation is faulty due to bugs or implementations that did "
"not take subinterpreters into account.  This includes things like "
"extension modules that rely on C globals. [cryptography]_  In these cases"
" bugs should be opened (some are already):"
msgstr ""

#: ../../pep-0554.rst:657
msgid "readline module hook functions (http://bugs.python.org/issue4202)"
msgstr ""

#: ../../pep-0554.rst:658
msgid "memory leaks on re-init (http://bugs.python.org/issue21387)"
msgstr ""

#: ../../pep-0554.rst:660
msgid ""
"Finally, some potential isolation is missing due to the current design of"
" CPython.  Improvements are currently going on to address gaps in this "
"area:"
msgstr ""

#: ../../pep-0554.rst:664
msgid "GC is not run per-interpreter [global-gc]_"
msgstr ""

#: ../../pep-0554.rst:665
msgid "at-exit handlers are not run per-interpreter [global-atexit]_"
msgstr ""

#: ../../pep-0554.rst:666
msgid "extensions using the ``PyGILState_*`` API are incompatible [gilstate]_"
msgstr ""

#: ../../pep-0554.rst:667
msgid "interpreters share memory management (e.g. allocators, gc)"
msgstr ""

#: ../../pep-0554.rst:668
msgid "interpreters share the GIL"
msgstr ""

#: ../../pep-0554.rst:671
msgid "Existing Usage"
msgstr ""

#: ../../pep-0554.rst:673
msgid ""
"Subinterpreters are not a widely used feature.  In fact, the only "
"documented cases of widespread usage are `mod_wsgi "
"<https://github.com/GrahamDumpleton/mod_wsgi>`_, `OpenStack Ceph "
"<https://github.com/ceph/ceph/pull/14971>`_, and `JEP "
"<https://github.com/ninia/jep>`_.  On the one hand, these cases provide "
"confidence that existing subinterpreter support is relatively stable.  On"
" the other hand, there isn't much of a sample size from which to judge "
"the utility of the feature."
msgstr ""

#: ../../pep-0554.rst:684
msgid "Provisional Status"
msgstr ""

#: ../../pep-0554.rst:686
msgid ""
"The new ``interpreters`` module will be added with \"provisional\" status"
" (see PEP 411).  This allows Python users to experiment with the feature "
"and provide feedback while still allowing us to adjust to that feedback. "
"The module will be provisional in Python 3.9 and we will make a decision "
"before the 3.10 release whether to keep it provisional, graduate it, or "
"remove it.  This PEP will be updated accordingly."
msgstr ""

#: ../../pep-0554.rst:693
msgid ""
"While the module is provisional, any changes to the API (or to behavior) "
"do not need to be reflected here, nor get approval by the BDFL-delegate. "
"However, such changes will still need to go through the normal processes "
"(BPO for smaller changes and python-dev/PEP for substantial ones)."
msgstr ""

#: ../../pep-0554.rst:700
msgid "Alternate Python Implementations"
msgstr ""

#: ../../pep-0554.rst:702
msgid ""
"I've solicited feedback from various Python implementors about support "
"for subinterpreters.  Each has indicated that they would be able to "
"support subinterpreters (if they choose to) without a lot of trouble.  "
"Here are the projects I contacted:"
msgstr ""

#: ../../pep-0554.rst:707
msgid "jython  ([jython]_)"
msgstr ""

#: ../../pep-0554.rst:708
msgid "ironpython  (personal correspondence)"
msgstr ""

#: ../../pep-0554.rst:709
msgid "pypy  (personal correspondence)"
msgstr ""

#: ../../pep-0554.rst:710
msgid "micropython  (personal correspondence)"
msgstr ""

#: ../../pep-0554.rst:719
msgid "\"interpreters\" Module API"
msgstr ""

#: ../../pep-0554.rst:721
msgid "The module provides the following functions::"
msgstr ""

#: ../../pep-0554.rst:746
msgid "The module also provides the following class::"
msgstr ""

#: ../../pep-0554.rst:822
msgid "Uncaught Exceptions"
msgstr ""

#: ../../pep-0554.rst:824
msgid ""
"Regarding uncaught exceptions in ``Interpreter.run()``, we noted that "
"they are \"effectively\" propagated into the code where ``run()`` was "
"called.  To prevent leaking exceptions (and tracebacks) between "
"interpreters, we create a surrogate of the exception and its traceback "
"(see ``traceback.TracebackException``), set it to ``__cause__`` on a new "
"``RunFailedError``, and raise that."
msgstr ""

#: ../../pep-0554.rst:831
msgid ""
"Raising (a proxy of) the exception directly is problematic since it's "
"harder to distinguish between an error in the ``run()`` call and an "
"uncaught exception from the subinterpreter."
msgstr ""

#: ../../pep-0554.rst:842
msgid "API for sharing data"
msgstr ""

#: ../../pep-0554.rst:844
msgid ""
"Subinterpreters are less useful without a mechanism for sharing data "
"between them.  Sharing actual Python objects between interpreters, "
"however, has enough potential problems that we are avoiding support for "
"that here.  Instead, only minimum set of types will be supported. "
"Initially this will include ``None``, ``bytes``, ``str``, ``int``, and "
"channels.  Further types may be supported later."
msgstr ""

#: ../../pep-0554.rst:851
msgid ""
"The ``interpreters`` module provides a function that users may call to "
"determine whether an object is shareable or not::"
msgstr ""

#: ../../pep-0554.rst:862
msgid ""
"This proposal provides two ways to share such objects between "
"interpreters."
msgstr ""

#: ../../pep-0554.rst:865
msgid ""
"First, channels may be passed to ``run()`` via the ``channels`` keyword "
"argument, where they are effectively injected into the target "
"interpreter's ``__main__`` module.  While passing arbitrary shareable "
"objects this way is possible, doing so is mainly intended for sharing "
"meta-objects (e.g. channels) between interpreters.  It is less useful to "
"pass other objects (like ``bytes``) to ``run`` directly."
msgstr ""

#: ../../pep-0554.rst:872
msgid ""
"Second, the main mechanism for sharing objects (i.e. their data) between "
"interpreters is through channels.  A channel is a simplex FIFO similar to"
" a pipe.  The main difference is that channels can be associated with "
"zero or more interpreters on either end.  Like queues, which are also "
"many-to-many, channels are buffered (though they also offer methods with "
"unbuffered semantics)."
msgstr ""

#: ../../pep-0554.rst:879
msgid ""
"Python objects are not shared between interpreters.  However, in some "
"cases data those objects wrap is actually shared and not just copied. One"
" example might be PEP 3118 buffers.  In those cases the object in the "
"original interpreter is kept alive until the shared data in the other "
"interpreter is no longer used.  Then object destruction can happen like "
"normal in the original interpreter, along with the previously shared "
"data."
msgstr ""

#: ../../pep-0554.rst:887
msgid ""
"The ``interpreters`` module provides the following functions related to "
"channels::"
msgstr ""

#: ../../pep-0554.rst:903
msgid "The module also provides the following channel-related classes::"
msgstr ""

#: ../../pep-0554.rst:957
msgid "Channel Lifespan"
msgstr ""

#: ../../pep-0554.rst:959
msgid ""
"A channel is automatically closed and destroyed once there are no more "
"Python objects (e.g. ``RecvChannel`` and ``SendChannel``) referring to "
"it.  So it is effectively triggered via garbage-collection of those "
"objects.."
msgstr ""

#: ../../pep-0554.rst:968
msgid "Interpreter \"Isolated\" Mode"
msgstr ""

#: ../../pep-0554.rst:970
msgid ""
"By default, every new interpreter created by ``interpreters.create()`` "
"has specific restrictions on any code it runs.  This includes the "
"following:"
msgstr ""

#: ../../pep-0554.rst:974
msgid ""
"importing an extension module fails if it does not implement the PEP 489 "
"API"
msgstr ""

#: ../../pep-0554.rst:976
msgid "new threads of any kind are not allowed"
msgstr ""

#: ../../pep-0554.rst:977
msgid "``os.fork()`` is not allowed (so no ``multiprocessing``)"
msgstr ""

#: ../../pep-0554.rst:978
msgid "``os.exec*()``, AKA \"fork+exec\", is not allowed (so no ``subprocess``)"
msgstr ""

#: ../../pep-0554.rst:980
msgid ""
"This represents the full \"isolated\" mode of subinterpreters.  It is "
"applied when ``interpreters.create()`` is called with the \"isolated\" "
"keyword-only argument set to ``True`` (the default).  If "
"``interpreters.create(isolated=False)`` is called then none of those "
"restrictions is applied."
msgstr ""

#: ../../pep-0554.rst:986
msgid ""
"One advantage of this approach is that it allows extension maintainers to"
" check subinterpreter compatibility before they implement the PEP 489 "
"API.  Also note that ``isolated=False`` represents the historical "
"behavior when using the existing subinterpreters C-API, thus providing "
"backward compatibility.  For the existing C-API itself, the default "
"remains ``isolated=False``.  The same is true for the \"main\" module, so"
" existing use of Python will not change."
msgstr ""

#: ../../pep-0554.rst:994
msgid ""
"We may choose to later loosen some of the above restrictions or provide a"
" way to enable/disable granular restrictions individually.  Regardless, "
"requiring PEP 489 support from extension modules will always be a default"
" restriction."
msgstr ""

#: ../../pep-0554.rst:1001
msgid "Documentation"
msgstr ""

#: ../../pep-0554.rst:1003
msgid ""
"The new stdlib docs page for the ``interpreters`` module will include the"
" following:"
msgstr ""

#: ../../pep-0554.rst:1006
msgid ""
"(at the top) a clear note that subinterpreter support in extension "
"modules is not required"
msgstr ""

#: ../../pep-0554.rst:1008
msgid "some explanation about what subinterpreters are"
msgstr ""

#: ../../pep-0554.rst:1009
msgid "brief examples of how to use subinterpreters and channels"
msgstr ""

#: ../../pep-0554.rst:1010
msgid "a summary of the limitations of subinterpreters"
msgstr ""

#: ../../pep-0554.rst:1011
msgid ""
"(for extension maintainers) a link to the resources for ensuring "
"subinterpreter compatibility"
msgstr ""

#: ../../pep-0554.rst:1013
msgid "much of the API information in this PEP"
msgstr ""

#: ../../pep-0554.rst:1015
msgid ""
"A separate page will be added to the docs for resources to help extension"
" maintainers ensure their modules can be used safely in subinterpreters, "
"under `Extending Python <extension-docs>`_.  The page will include the "
"following information:"
msgstr ""

#: ../../pep-0554.rst:1020
msgid ""
"a summary about subinterpreters (similar to the same in the new "
"``interpreters`` module page and in the C-API docs)"
msgstr ""

#: ../../pep-0554.rst:1022
msgid "an explanation of how extension modules can be impacted"
msgstr ""

#: ../../pep-0554.rst:1023
msgid "how to implement PEP 489 support"
msgstr ""

#: ../../pep-0554.rst:1024
msgid "how to move from global module state to per-interpreter"
msgstr ""

#: ../../pep-0554.rst:1025
msgid ""
"how to take advantage of PEP 384 (heap types), PEP 3121 (module state), "
"and PEP 573"
msgstr ""

#: ../../pep-0554.rst:1027
msgid ""
"strategies for dealing with 3rd party C libraries that keep their own "
"subinterpreter-incompatible global state"
msgstr ""

#: ../../pep-0554.rst:1030
msgid ""
"Note that the documentation will play a large part in mitigating any "
"negative impact that the new ``interpreters`` module might have on "
"extension module maintainers."
msgstr ""

#: ../../pep-0554.rst:1034
msgid ""
"Also, the ``ImportError`` for incompatible extgension modules will have a"
" message that clearly says it is due to missing subinterpreter "
"compatibility and that extensions are not required to provide it.  This "
"will help set user expectations properly."
msgstr ""

#: ../../pep-0554.rst:1041
msgid "Deferred Functionality"
msgstr ""

#: ../../pep-0554.rst:1043
msgid ""
"In the interest of keeping this proposal minimal, the following "
"functionality has been left out for future consideration.  Note that this"
" is not a judgement against any of said capability, but rather a "
"deferment.  That said, each is arguably valid."
msgstr ""

#: ../../pep-0554.rst:1049
msgid "Interpreter.call()"
msgstr ""

#: ../../pep-0554.rst:1051
msgid ""
"It would be convenient to run existing functions in subinterpreters "
"directly.  ``Interpreter.run()`` could be adjusted to support this or a "
"``call()`` method could be added::"
msgstr ""

#: ../../pep-0554.rst:1057
msgid ""
"This suffers from the same problem as sharing objects between "
"interpreters via queues.  The minimal solution (running a source string) "
"is sufficient for us to get the feature out where it can be explored."
msgstr ""

#: ../../pep-0554.rst:1062
msgid "timeout arg to recv() and send()"
msgstr ""

#: ../../pep-0554.rst:1064
msgid ""
"Typically functions that have a ``block`` argument also have a "
"``timeout`` argument.  It sometimes makes sense to do likewise for "
"functions that otherwise block, like the channel ``recv()`` and "
"``send()`` methods.  We can add it later if needed."
msgstr ""

#: ../../pep-0554.rst:1070
msgid "Interpreter.run_in_thread()"
msgstr ""

#: ../../pep-0554.rst:1072
msgid ""
"This method would make a ``run()`` call for you in a thread.  Doing this "
"using only ``threading.Thread`` and ``run()`` is relatively trivial so "
"we've left it out."
msgstr ""

#: ../../pep-0554.rst:1077
msgid "Synchronization Primitives"
msgstr ""

#: ../../pep-0554.rst:1079
msgid ""
"The ``threading`` module provides a number of synchronization primitives "
"for coordinating concurrent operations.  This is especially necessary due"
" to the shared-state nature of threading.  In contrast, subinterpreters "
"do not share state.  Data sharing is restricted to channels, which do "
"away with the need for explicit synchronization.  If any sort of opt-in "
"shared state support is added to subinterpreters in the future, that same"
" effort can introduce synchronization primitives to meet that need."
msgstr ""

#: ../../pep-0554.rst:1089
msgid "CSP Library"
msgstr ""

#: ../../pep-0554.rst:1091
msgid ""
"A ``csp`` module would not be a large step away from the functionality "
"provided by this PEP.  However, adding such a module is outside the "
"minimalist goals of this proposal."
msgstr ""

#: ../../pep-0554.rst:1096
msgid "Syntactic Support"
msgstr ""

#: ../../pep-0554.rst:1098
msgid ""
"The ``Go`` language provides a concurrency model based on CSP, so it's "
"similar to the concurrency model that subinterpreters support. However, "
"``Go`` also provides syntactic support, as well several builtin "
"concurrency primitives, to make concurrency a first-class feature. "
"Conceivably, similar syntactic (and builtin) support could be added to "
"Python using subinterpreters.  However, that is *way* outside the scope "
"of this PEP!"
msgstr ""

#: ../../pep-0554.rst:1107
msgid "Multiprocessing"
msgstr ""

#: ../../pep-0554.rst:1109
msgid ""
"The ``multiprocessing`` module could support subinterpreters in the same "
"way it supports threads and processes.  In fact, the module's maintainer,"
" Davin Potts, has indicated this is a reasonable feature request.  "
"However, it is outside the narrow scope of this PEP."
msgstr ""

#: ../../pep-0554.rst:1115
msgid "C-extension opt-in/opt-out"
msgstr ""

#: ../../pep-0554.rst:1117
msgid ""
"By using the ``PyModuleDef_Slot`` introduced by PEP 489, we could easily "
"add a mechanism by which C-extension modules could opt out of support for"
" subinterpreters.  Then the import machinery, when operating in a "
"subinterpreter, would need to check the module for support.  It would "
"raise an ImportError if unsupported."
msgstr ""

#: ../../pep-0554.rst:1123
msgid ""
"Alternately we could support opting in to subinterpreter support. "
"However, that would probably exclude many more modules (unnecessarily) "
"than the opt-out approach.  Also, note that PEP 489 defined that an "
"extension's use of the PEP's machinery implies support for "
"subinterpreters."
msgstr ""

#: ../../pep-0554.rst:1129
msgid ""
"The scope of adding the ModuleDef slot and fixing up the import machinery"
" is non-trivial, but could be worth it.  It all depends on how many "
"extension modules break under subinterpreters.  Given that there are "
"relatively few cases we know of through mod_wsgi, we can leave this for "
"later."
msgstr ""

#: ../../pep-0554.rst:1136
msgid "Poisoning channels"
msgstr ""

#: ../../pep-0554.rst:1138
msgid ""
"CSP has the concept of poisoning a channel.  Once a channel has been "
"poisoned, any ``send()`` or ``recv()`` call on it would raise a special "
"exception, effectively ending execution in the interpreter that tried to "
"use the poisoned channel."
msgstr ""

#: ../../pep-0554.rst:1143
msgid ""
"This could be accomplished by adding a ``poison()`` method to both ends "
"of the channel.  The ``close()`` method can be used in this way (mostly),"
" but these semantics are relatively specialized and can wait."
msgstr ""

#: ../../pep-0554.rst:1148
msgid "Resetting __main__"
msgstr ""

#: ../../pep-0554.rst:1150
msgid ""
"As proposed, every call to ``Interpreter.run()`` will execute in the "
"namespace of the interpreter's existing ``__main__`` module.  This means "
"that data persists there between ``run()`` calls.  Sometimes this isn't "
"desirable and you want to execute in a fresh ``__main__``.  Also, you "
"don't necessarily want to leak objects there that you aren't using any "
"more."
msgstr ""

#: ../../pep-0554.rst:1157
msgid ""
"Note that the following won't work right because it will clear too much "
"(e.g. ``__name__`` and the other \"__dunder__\" attributes::"
msgstr ""

#: ../../pep-0554.rst:1162
msgid "Possible solutions include:"
msgstr ""

#: ../../pep-0554.rst:1164
msgid ""
"a ``create()`` arg to indicate resetting ``__main__`` after each ``run`` "
"call"
msgstr ""

#: ../../pep-0554.rst:1166
msgid ""
"an ``Interpreter.reset_main`` flag to support opting in or out after the "
"fact"
msgstr ""

#: ../../pep-0554.rst:1168
msgid "an ``Interpreter.reset_main()`` method to opt in when desired"
msgstr ""

#: ../../pep-0554.rst:1169
msgid "``importlib.util.reset_globals()`` [reset_globals]_"
msgstr ""

#: ../../pep-0554.rst:1171
msgid ""
"Also note that resetting ``__main__`` does nothing about state stored in "
"other modules.  So any solution would have to be clear about the scope of"
" what is being reset.  Conceivably we could invent a mechanism by which "
"any (or every) module could be reset, unlike ``reload()`` which does not "
"clear the module before loading into it.  Regardless, since ``__main__`` "
"is the execution namespace of the interpreter, resetting it has a much "
"more direct correlation to interpreters and their dynamic state than does"
" resetting other modules.  So a more generic module reset mechanism may "
"prove unnecessary."
msgstr ""

#: ../../pep-0554.rst:1181
msgid ""
"This isn't a critical feature initially.  It can wait until later if "
"desirable."
msgstr ""

#: ../../pep-0554.rst:1185
msgid "Resetting an interpreter's state"
msgstr ""

#: ../../pep-0554.rst:1187
msgid ""
"It may be nice to re-use an existing subinterpreter instead of spinning "
"up a new one.  Since an interpreter has substantially more state than "
"just the ``__main__`` module, it isn't so easy to put an interpreter back"
" into a pristine/fresh state.  In fact, there *may* be parts of the state"
" that cannot be reset from Python code."
msgstr ""

#: ../../pep-0554.rst:1193
msgid ""
"A possible solution is to add an ``Interpreter.reset()`` method.  This "
"would put the interpreter back into the state it was in when newly "
"created.  If called on a running interpreter it would fail (hence the "
"main interpreter could never be reset).  This would likely be more "
"efficient than creating a new subinterpreter, though that depends on what"
" optimizations will be made later to subinterpreter creation."
msgstr ""

#: ../../pep-0554.rst:1200
msgid ""
"While this would potentially provide functionality that is not otherwise "
"available from Python code, it isn't a fundamental functionality.  So in "
"the spirit of minimalism here, this can wait. Regardless, I doubt it "
"would be controversial to add it post-PEP."
msgstr ""

#: ../../pep-0554.rst:1206
msgid "File descriptors and sockets in channels"
msgstr ""

#: ../../pep-0554.rst:1208
msgid ""
"Given that file descriptors and sockets are process-global resources, "
"support for passing them through channels is a reasonable idea.  They "
"would be a good candidate for the first effort at expanding the types "
"that channels support.  They aren't strictly necessary for the initial "
"API."
msgstr ""

#: ../../pep-0554.rst:1215
msgid "Integration with async"
msgstr ""

#: ../../pep-0554.rst:1217
msgid "Per Antoine Pitrou [async]_::"
msgstr ""

#: ../../pep-0554.rst:1227
msgid ""
"A possible solution is to provide async implementations of the blocking "
"channel methods (``recv()``, and ``send()``).  However, the basic "
"functionality of subinterpreters does not depend on async and can be "
"added later."
msgstr ""

#: ../../pep-0554.rst:1232
msgid ""
"Alternately, \"readiness callbacks\" could be used to simplify use in "
"async scenarios.  This would mean adding an optional ``callback`` (kw-"
"only) parameter to the ``recv_nowait()`` and ``send_nowait()`` channel "
"methods.  The callback would be called once the object was sent or "
"received (respectively)."
msgstr ""

#: ../../pep-0554.rst:1238
msgid ""
"(Note that making channels buffered makes readiness callbacks less "
"important.)"
msgstr ""

#: ../../pep-0554.rst:1242
msgid "Support for iteration"
msgstr ""

#: ../../pep-0554.rst:1244
msgid ""
"Supporting iteration on ``RecvChannel`` (via ``__iter__()`` or "
"``_next__()``) may be useful.  A trivial implementation would use the "
"``recv()`` method, similar to how files do iteration.  Since this isn't a"
" fundamental capability and has a simple analog, adding iteration support"
" can wait until later."
msgstr ""

#: ../../pep-0554.rst:1251
msgid "Channel context managers"
msgstr ""

#: ../../pep-0554.rst:1253
msgid ""
"Context manager support on ``RecvChannel`` and ``SendChannel`` may be "
"helpful.  The implementation would be simple, wrapping a call to "
"``close()`` (or maybe ``release()``) like files do.  As with iteration, "
"this can wait."
msgstr ""

#: ../../pep-0554.rst:1259
msgid "Pipes and Queues"
msgstr ""

#: ../../pep-0554.rst:1261
msgid ""
"With the proposed object passing mechanism of \"channels\", other similar"
" basic types aren't required to achieve the minimal useful functionality "
"of subinterpreters.  Such types include pipes (like unbuffered channels, "
"but one-to-one) and queues (like channels, but more generic).  See below "
"in `Rejected Ideas`_ for more information."
msgstr ""

#: ../../pep-0554.rst:1267
msgid ""
"Even though these types aren't part of this proposal, they may still be "
"useful in the context of concurrency.  Adding them later is entirely "
"reasonable.  The could be trivially implemented as wrappers around "
"channels.  Alternatively they could be implemented for efficiency at the "
"same low level as channels."
msgstr ""

#: ../../pep-0554.rst:1274
msgid "Return a lock from send()"
msgstr ""

#: ../../pep-0554.rst:1276
msgid ""
"When sending an object through a channel, you don't have a way of knowing"
" when the object gets received on the other end.  One way to work around "
"this is to return a locked ``threading.Lock`` from ``SendChannel.send()``"
" that unlocks once the object is received."
msgstr ""

#: ../../pep-0554.rst:1281
msgid ""
"Alternately, the proposed ``SendChannel.send()`` (blocking) and "
"``SendChannel.send_nowait()`` provide an explicit distinction that is "
"less likely to confuse users."
msgstr ""

#: ../../pep-0554.rst:1285
msgid ""
"Note that returning a lock would matter for buffered channels (i.e. "
"queues).  For unbuffered channels it is a non-issue."
msgstr ""

#: ../../pep-0554.rst:1289
msgid "Support prioritization in channels"
msgstr ""

#: ../../pep-0554.rst:1291
msgid "A simple example is ``queue.PriorityQueue`` in the stdlib."
msgstr ""

#: ../../pep-0554.rst:1294
msgid "Support inheriting settings (and more?)"
msgstr ""

#: ../../pep-0554.rst:1296
msgid ""
"Folks might find it useful, when creating a new subinterpreter, to be "
"able to indicate that they would like some things \"inherited\" by the "
"new interpreter.  The mechanism could be a strict copy or it could be "
"copy-on-write.  The motivating example is with the warnings module (e.g. "
"copy the filters)."
msgstr ""

#: ../../pep-0554.rst:1302
msgid ""
"The feature isn't critical, nor would it be widely useful, so it can wait"
" until there's interest.  Notably, both suggested solutions will require "
"significant work, especially when it comes to complex objects and most "
"especially for mutable containers of mutable complex objects."
msgstr ""

#: ../../pep-0554.rst:1309
msgid "Make exceptions shareable"
msgstr ""

#: ../../pep-0554.rst:1311
msgid ""
"Exceptions are propagated out of ``run()`` calls, so it isn't a big leap "
"to make them shareable in channels.  However, as noted elsewhere, it "
"isn't essential or (particularly common) so we can wait on doing that."
msgstr ""

#: ../../pep-0554.rst:1317
msgid "Make RunFailedError.__cause__ lazy"
msgstr ""

#: ../../pep-0554.rst:1319
msgid ""
"An uncaught exception in a subinterpreter (from ``run()``) is copied to "
"the calling interpreter and set as ``__cause__`` on a ``RunFailedError`` "
"which is then raised.  That copying part involves some sort of "
"deserialization in the calling interpreter, which can be expensive (e.g. "
"due to imports) yet is not always necessary."
msgstr ""

#: ../../pep-0554.rst:1325
msgid ""
"So it may be useful to use an ``ExceptionProxy`` type to wrap the "
"serialized exception and only deserialize it when needed.  That could be "
"via ``ExceptionProxy__getattribute__()`` or perhaps through "
"``RunFailedError.resolve()`` (which would raise the deserialized "
"exception and set ``RunFailedError.__cause__`` to the exception."
msgstr ""

#: ../../pep-0554.rst:1331
msgid ""
"It may also make sense to have ``RunFailedError.__cause__`` be a "
"descriptor that does the lazy deserialization (and set ``__cause__``) on "
"the ``RunFailedError`` instance."
msgstr ""

#: ../../pep-0554.rst:1336
msgid "Serialize everything through channels"
msgstr ""

#: ../../pep-0554.rst:1338
msgid ""
"We could use pickle (or marshal) to serialize everything sent through "
"channels.  Doing this is potentially inefficient, but it may be a matter "
"of convenience in the end.  We can add it later, but trying to remove it "
"later would be significantly more painful."
msgstr ""

#: ../../pep-0554.rst:1344
msgid "Return a value from ``run()``"
msgstr ""

#: ../../pep-0554.rst:1346
msgid ""
"Currently ``run()`` always returns None.  One idea is to return the "
"return value from whatever the subinterpreter ran.  However, for now it "
"doesn't make sense.  The only thing folks can run is a string of code "
"(i.e. a script).  This is equivalent to ``PyRun_StringFlags()``, "
"``exec()``, or a module body.  None of those \"return\" anything.  We can"
" revisit this once ``run()`` supports functions, etc."
msgstr ""

#: ../../pep-0554.rst:1354
msgid "Add a \"tp_share\" type slot"
msgstr ""

#: ../../pep-0554.rst:1356
msgid "This would replace the current global registry for shareable types."
msgstr ""

#: ../../pep-0554.rst:1359
msgid "Expose which interpreters have actually *used* a channel end."
msgstr ""

#: ../../pep-0554.rst:1361
msgid ""
"Currently we associate interpreters upon access to a channel.  We would "
"keep a separate association list for \"upon use\" and expose that."
msgstr ""

#: ../../pep-0554.rst:1365
msgid "Add a shareable synchronization primitive"
msgstr ""

#: ../../pep-0554.rst:1367
msgid ""
"This would be ``_threading.Lock`` (or something like it) where "
"interpreters would actually share the underlying mutex.  This would "
"provide much better efficiency than blocking channel ops.  The main "
"concern is that locks and channels don't mix well (as learned in Go)."
msgstr ""

#: ../../pep-0554.rst:1372
msgid ""
"Note that the same functionality as a lock can be achieved by passing "
"some sort of \"token\" object through a channel.  \"send()\" would be "
"equivalent to releasing the lock and \"recv()\" to acquiring the lock."
msgstr ""

#: ../../pep-0554.rst:1376
msgid "We can add this later if it proves desirable without much trouble."
msgstr ""

#: ../../pep-0554.rst:1379
msgid "Propagate SystemExit and KeyboardInterrupt Differently"
msgstr ""

#: ../../pep-0554.rst:1381
msgid ""
"The exception types that inherit from ``BaseException`` (aside from "
"``Exception``) are usually treated specially.  These types are: "
"``KeyboardInterrupt``, ``SystemExit``, and ``GeneratorExit``.  It may "
"make sense to treat them specially when it comes to propagation from "
"``run()``.  Here are some options::"
msgstr ""

#: ../../pep-0554.rst:1392
msgid ""
"We aren't going to worry about handling them differently.  Threads "
"already ignore ``SystemExit``, so for now we will follow that pattern."
msgstr ""

#: ../../pep-0554.rst:1396
msgid "Add an explicit release() and close() to channel end classes"
msgstr ""

#: ../../pep-0554.rst:1398
msgid ""
"It can be convenient to have an explicit way to close a channel against "
"further global use.  Likewise it could be useful to have an explicit way "
"to release one of the channel ends relative to the current interpreter.  "
"Among other reasons, such a mechanism is useful for communicating overall"
" state between interpreters without the extra boilerplate that passing "
"objects through a channel directly would require."
msgstr ""

#: ../../pep-0554.rst:1406
msgid ""
"The challenge is getting automatic release/close right without making it "
"hard to understand.  This is especially true when dealing with a non-"
"empty channel.  We should be able to get by without release/close for "
"now."
msgstr ""

#: ../../pep-0554.rst:1412
msgid "Add SendChannel.send_buffer()"
msgstr ""

#: ../../pep-0554.rst:1414
msgid ""
"This method would allow no-copy sending of an object through a channel if"
" it supports the PEP 3118 buffer protocol (e.g. memoryview)."
msgstr ""

#: ../../pep-0554.rst:1417
msgid ""
"Support for this is not fundamental to channels and can be added on later"
" without much disruption."
msgstr ""

#: ../../pep-0554.rst:1421
msgid "Auto-run in a thread"
msgstr ""

#: ../../pep-0554.rst:1423
msgid ""
"The PEP proposes a hard separation between subinterpreters and threads: "
"if you want to run in a thread you must create the thread yourself and "
"call ``run()`` in it.  However, it might be convenient if ``run()`` could"
" do that for you, meaning there would be less boilerplate."
msgstr ""

#: ../../pep-0554.rst:1428
msgid ""
"Furthermore, we anticipate that users will want to run in a thread much "
"more often than not.  So it would make sense to make this the default "
"behavior.  We would add a kw-only param \"threaded\" (default ``True``) "
"to ``run()`` to allow the run-in-the-current-thread operation."
msgstr ""

#: ../../pep-0554.rst:1435
msgid "Rejected Ideas"
msgstr ""

#: ../../pep-0554.rst:1438
msgid "Explicit channel association"
msgstr ""

#: ../../pep-0554.rst:1440
msgid ""
"Interpreters are implicitly associated with channels upon ``recv()`` and "
"``send()`` calls.  They are de-associated with ``release()`` calls.  The "
"alternative would be explicit methods.  It would be either "
"``add_channel()`` and ``remove_channel()`` methods on ``Interpreter`` "
"objects or something similar on channel objects."
msgstr ""

#: ../../pep-0554.rst:1446
msgid ""
"In practice, this level of management shouldn't be necessary for users. "
"So adding more explicit support would only add clutter to the API."
msgstr ""

#: ../../pep-0554.rst:1450
msgid "Use pipes instead of channels"
msgstr ""

#: ../../pep-0554.rst:1452
msgid ""
"A pipe would be a simplex FIFO between exactly two interpreters.  For "
"most use cases this would be sufficient.  It could potentially simplify "
"the implementation as well.  However, it isn't a big step to supporting a"
" many-to-many simplex FIFO via channels.  Also, with pipes the API ends "
"up being slightly more complicated, requiring naming the pipes."
msgstr ""

#: ../../pep-0554.rst:1459
msgid "Use queues instead of channels"
msgstr ""

#: ../../pep-0554.rst:1461
msgid ""
"Queues and buffered channels are almost the same thing.  The main "
"difference is that channels have a stronger relationship with context "
"(i.e. the associated interpreter)."
msgstr ""

#: ../../pep-0554.rst:1465
msgid ""
"The name \"Channel\" was used instead of \"Queue\" to avoid confusion "
"with the stdlib ``queue.Queue``."
msgstr ""

#: ../../pep-0554.rst:1469
msgid "\"enumerate\""
msgstr ""

#: ../../pep-0554.rst:1471
msgid ""
"The ``list_all()`` function provides the list of all interpreters. In the"
" threading module, which partly inspired the proposed API, the function "
"is called ``enumerate()``.  The name is different here to avoid confusing"
" Python users that are not already familiar with the threading API.  For "
"them \"enumerate\" is rather unclear, whereas \"list_all\" is clear."
msgstr ""

#: ../../pep-0554.rst:1479
msgid "Alternate solutions to prevent leaking exceptions across interpreters"
msgstr ""

#: ../../pep-0554.rst:1481
msgid ""
"In function calls, uncaught exceptions propagate to the calling frame. "
"The same approach could be taken with ``run()``.  However, this would "
"mean that exception objects would leak across the inter-interpreter "
"boundary.  Likewise, the frames in the traceback would potentially leak."
msgstr ""

#: ../../pep-0554.rst:1486
msgid ""
"While that might not be a problem currently, it would be a problem once "
"interpreters get better isolation relative to memory management (which is"
" necessary to stop sharing the GIL between interpreters).  We've resolved"
" the semantics of how the exceptions propagate by raising a "
"``RunFailedError`` instead, for which ``__cause__`` wraps a safe proxy "
"for the original exception and traceback."
msgstr ""

#: ../../pep-0554.rst:1493
msgid "Rejected possible solutions:"
msgstr ""

#: ../../pep-0554.rst:1495
msgid ""
"reproduce the exception and traceback in the original interpreter and "
"raise that."
msgstr ""

#: ../../pep-0554.rst:1497
msgid ""
"raise a subclass of RunFailedError that proxies the original exception "
"and traceback."
msgstr ""

#: ../../pep-0554.rst:1499
msgid "raise RuntimeError instead of RunFailedError"
msgstr ""

#: ../../pep-0554.rst:1500
msgid ""
"convert at the boundary (a la ``subprocess.CalledProcessError``) "
"(requires a cross-interpreter representation)"
msgstr ""

#: ../../pep-0554.rst:1502
msgid ""
"support customization via ``Interpreter.excepthook`` (requires a cross-"
"interpreter representation)"
msgstr ""

#: ../../pep-0554.rst:1504
msgid ""
"wrap in a proxy at the boundary (including with support for something "
"like ``err.raise()`` to propagate the traceback)."
msgstr ""

#: ../../pep-0554.rst:1506
msgid "return the exception (or its proxy) from ``run()`` instead of raising it"
msgstr ""

#: ../../pep-0554.rst:1508
msgid ""
"return a result object (like ``subprocess`` does) [result-object]_ "
"(unnecessary complexity?)"
msgstr ""

#: ../../pep-0554.rst:1510
msgid ""
"throw the exception away and expect users to deal with unhandled "
"exceptions explicitly in the script they pass to ``run()`` (they can pass"
" error info out via channels); with threads you have to do something "
"similar"
msgstr ""

#: ../../pep-0554.rst:1516
msgid "Always associate each new interpreter with its own thread"
msgstr ""

#: ../../pep-0554.rst:1518
msgid ""
"As implemented in the C-API, a subinterpreter is not inherently tied to "
"any thread.  Furthermore, it will run in any existing thread, whether "
"created by Python or not.  You only have to activate one of its thread "
"states (``PyThreadState``) in the thread first.  This means that the same"
" thread may run more than one interpreter (though obviously not at the "
"same time)."
msgstr ""

#: ../../pep-0554.rst:1525
msgid ""
"The proposed module maintains this behavior.  Subinterpreters are not "
"tied to threads.  Only calls to ``Interpreter.run()`` are.  However, one "
"of the key objectives of this PEP is to provide a more human- centric "
"concurrency model.  With that in mind, from a conceptual standpoint the "
"module *might* be easier to understand if each subinterpreter were "
"associated with its own thread."
msgstr ""

#: ../../pep-0554.rst:1532
msgid ""
"That would mean ``interpreters.create()`` would create a new thread and "
"``Interpreter.run()`` would only execute in that thread (and nothing else"
" would).  The benefit is that users would not have to wrap "
"``Interpreter.run()`` calls in a new ``threading.Thread``.  Nor would "
"they be in a position to accidentally pause the current interpreter (in "
"the current thread) while their subinterpreter executes."
msgstr ""

#: ../../pep-0554.rst:1540
msgid ""
"The idea is rejected because the benefit is small and the cost is high. "
"The difference from the capability in the C-API would be potentially "
"confusing.  The implicit creation of threads is magical.  The early "
"creation of threads is potentially wasteful.  The inability to run "
"arbitrary interpreters in an existing thread would prevent some valid use"
" cases, frustrating users.  Tying interpreters to threads would require "
"extra runtime modifications.  It would also make the module's "
"implementation overly complicated.  Finally, it might not even make the "
"module easier to understand."
msgstr ""

#: ../../pep-0554.rst:1551
msgid "Only associate interpreters upon use"
msgstr ""

#: ../../pep-0554.rst:1553
msgid ""
"Associate interpreters with channel ends only once ``recv()``, "
"``send()``, etc. are called."
msgstr ""

#: ../../pep-0554.rst:1556
msgid ""
"Doing this is potentially confusing and also can lead to unexpected races"
" where a channel is auto-closed before it can be used in the original "
"(creating) interpreter."
msgstr ""

#: ../../pep-0554.rst:1561
msgid "Add a \"reraise\" method to RunFailedError"
msgstr ""

#: ../../pep-0554.rst:1563
msgid ""
"While having ``__cause__`` set on ``RunFailedError`` helps produce a more"
" useful traceback, it's less helpful when handling the original error.  "
"To help facilitate this, we could add ``RunFailedError.reraise()``.  This"
" method would enable the following pattern::"
msgstr ""

#: ../../pep-0554.rst:1577
msgid ""
"This would be made even simpler if there existed a ``__reraise__`` "
"protocol."
msgstr ""

#: ../../pep-0554.rst:1580
msgid ""
"All that said, this is completely unnecessary.  Using ``__cause__`` is "
"good enough::"
msgstr ""

#: ../../pep-0554.rst:1591
msgid "Note that in extreme cases it may require a little extra boilerplate::"
msgstr ""

#: ../../pep-0554.rst:1605
msgid "Implementation"
msgstr ""

#: ../../pep-0554.rst:1607
msgid "The implementation of the PEP has 4 parts:"
msgstr ""

#: ../../pep-0554.rst:1609
msgid ""
"the high-level module described in this PEP (mostly a light wrapper "
"around a low-level C extension"
msgstr ""

#: ../../pep-0554.rst:1611
msgid "the low-level C extension module"
msgstr ""

#: ../../pep-0554.rst:1612
msgid "additions to the (\"private\") C=API needed by the low-level module"
msgstr ""

#: ../../pep-0554.rst:1613
msgid ""
"secondary fixes/changes in the CPython runtime that facilitate the low-"
"level module (among other benefits)"
msgstr ""

#: ../../pep-0554.rst:1616
msgid ""
"These are at various levels of completion, with more done the lower you "
"go:"
msgstr ""

#: ../../pep-0554.rst:1619
msgid ""
"the high-level module has been, at best, roughly implemented. However, "
"fully implementing it will be almost trivial."
msgstr ""

#: ../../pep-0554.rst:1621
msgid ""
"the low-level module is mostly complete.  The bulk of the implementation "
"was merged into master in December 2018 as the \"_xxsubinterpreters\" "
"module (for the sake of testing subinterpreter functionality).  Only 3 "
"parts of the implementation remain: \"send_wait()\", \"send_buffer()\", "
"and exception propagation.  All three have been mostly finished, but were"
" blocked by work related to ceval. That blocker is basically resolved now"
" and finishing the low-level will not require extensive work."
msgstr ""

#: ../../pep-0554.rst:1629
msgid "all necessary C-API work has been finished"
msgstr ""

#: ../../pep-0554.rst:1630
msgid "all anticipated work in the runtime has been finished"
msgstr ""

#: ../../pep-0554.rst:1632
msgid ""
"The implementation effort for PEP 554 is being tracked as part of a "
"larger project aimed at improving multi-core support in CPython. [multi-"
"core-project]_"
msgstr ""

#: ../../pep-0554.rst:1638
msgid "References"
msgstr ""

#: ../../pep-0554.rst:1641
msgid "https://docs.python.org/3/c-api/init.html#sub-interpreter-support"
msgstr ""

#: ../../pep-0554.rst:1646
msgid ""
"https://en.wikipedia.org/wiki/Communicating_sequential_processes "
"https://github.com/futurecore/python-csp"
msgstr ""

#: ../../pep-0554.rst:1650
msgid ""
"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Pipe"
" "
"https://docs.python.org/3/library/multiprocessing.html#multiprocessing.Queue"
" https://docs.python.org/3/library/queue.html#module-queue "
"http://stackless.readthedocs.io/en/2.7-slp/library/stackless/channels.html"
" https://golang.org/doc/effective_go.html#sharing "
"http://www.jtolds.com/writing/2016/03/go-channels-are-bad-and-you-should-"
"feel-bad/"
msgstr ""

#: ../../pep-0554.rst:1658
msgid "https://docs.python.org/3/c-api/init.html#bugs-and-caveats"
msgstr ""

#: ../../pep-0554.rst:1661
msgid ""
"https://mail.python.org/pipermail/import-sig/2016-June/001062.html "
"https://mail.python.org/pipermail/python-ideas/2016-April/039748.html"
msgstr ""

#: ../../pep-0554.rst:1665
msgid "https://github.com/pyca/cryptography/issues/2299"
msgstr ""

#: ../../pep-0554.rst:1668
msgid "http://bugs.python.org/issue24554"
msgstr ""

#: ../../pep-0554.rst:1671
msgid "https://bugs.python.org/issue10915 http://bugs.python.org/issue15751"
msgstr ""

#: ../../pep-0554.rst:1675
msgid "https://bugs.python.org/issue6531"
msgstr ""

#: ../../pep-0554.rst:1678
msgid "https://docs.python.org/3/library/multiprocessing.html#connection-objects"
msgstr ""

#: ../../pep-0554.rst:1681
msgid "https://mail.python.org/pipermail/python-ideas/2017-September/047094.html"
msgstr ""

#: ../../pep-0554.rst:1684
msgid "https://mail.python.org/pipermail/python-ideas/2017-September/047122.html"
msgstr ""

#: ../../pep-0554.rst:1687
msgid ""
"https://mail.python.org/pipermail/python-ideas/2017-September/047144.html"
" https://mail.python.org/pipermail/python-dev/2017-September/149566.html"
msgstr ""

#: ../../pep-0554.rst:1691
msgid "https://mail.python.org/pipermail/python-dev/2017-September/149545.html"
msgstr ""

#: ../../pep-0554.rst:1694
msgid ""
"https://mail.python.org/pipermail/python-dev/2017-September/149420.html "
"https://mail.python.org/pipermail/python-dev/2017-September/149585.html"
msgstr ""

#: ../../pep-0554.rst:1698
msgid "https://mail.python.org/pipermail/python-dev/2017-September/149562.html"
msgstr ""

#: ../../pep-0554.rst:1701
msgid "https://mail.python.org/pipermail/python-ideas/2017-May/045771.html"
msgstr ""

#: ../../pep-0554.rst:1704
msgid "https://github.com/ericsnowcurrently/multi-core-python"
msgstr ""

#: ../../pep-0554.rst:1707
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/3HVRFWHDMWPNR367GXBILZ4JJAUQ2STZ/"
msgstr ""

#: ../../pep-0554.rst:1710
msgid ""
"https://mail.python.org/archives/list/python-"
"dev@python.org/message/TUEAZNZHVJGGLL4OFD32OW6JJDKM6FAS/"
msgstr ""

#: ../../pep-0554.rst:1713
msgid "https://docs.python.org/3/extending/index.html"
msgstr ""

#: ../../pep-0554.rst:1717
msgid "Copyright"
msgstr ""

#: ../../pep-0554.rst:1719
msgid "This document has been placed in the public domain."
msgstr ""

