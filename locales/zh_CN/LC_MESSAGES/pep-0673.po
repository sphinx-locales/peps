# SOME DESCRIPTIVE TITLE.
# Copyright (C)
# This file is distributed under the same license as the PEPs package.
# FIRST AUTHOR <EMAIL@ADDRESS>, 2021.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PEPs \n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2021-11-12 17:38+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=utf-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Generated-By: Babel 2.9.1\n"

#: ../../pep-0673.rst
msgid "PEP"
msgstr ""

#: ../../pep-0673.rst:1
msgid "673"
msgstr ""

#: ../../pep-0673.rst
msgid "Title"
msgstr ""

#: ../../pep-0673.rst:2
msgid "Self Type"
msgstr ""

#: ../../pep-0673.rst
msgid "Author"
msgstr ""

#: ../../pep-0673.rst:5
msgid ""
"Pradeep Kumar Srinivasan <gohanpra@gmail.com>, James Hilton-Balfe "
"<gobot1234yt@gmail.com>"
msgstr ""

#: ../../pep-0673.rst
msgid "Sponsor"
msgstr ""

#: ../../pep-0673.rst:7
msgid "Jelle Zijlstra <jelle.zijlstra@gmail.com>"
msgstr ""

#: ../../pep-0673.rst
msgid "Discussions-To"
msgstr ""

#: ../../pep-0673.rst:8
msgid "Typing-Sig <typing-sig@python.org>"
msgstr ""

#: ../../pep-0673.rst
msgid "Status"
msgstr ""

#: ../../pep-0673.rst:9
msgid "Draft"
msgstr ""

#: ../../pep-0673.rst
msgid "Type"
msgstr ""

#: ../../pep-0673.rst:10
msgid "Standards Track"
msgstr ""

#: ../../pep-0673.rst
msgid "Created"
msgstr ""

#: ../../pep-0673.rst:12
msgid "10-Nov-2021"
msgstr ""

#: ../../pep-0673.rst
msgid "Python-Version"
msgstr ""

#: ../../pep-0673.rst:13
msgid "3.11"
msgstr ""

#: ../../pep-0673.rst
msgid "Post-History"
msgstr ""

#: ../../pep-0673.rst:17
msgid "Abstract"
msgstr ""

#: ../../pep-0673.rst:19
msgid ""
"This PEP introduces a simple and intuitive way to annotate methods that "
"return an instance of their class. This behaves the same as the "
"``TypeVar``-based approach specified in `PEP 484 "
"<https://www.python.org/dev/peps/pep-0484>`_ but is more concise and "
"easier to follow."
msgstr ""

#: ../../pep-0673.rst:25
msgid "Motivation"
msgstr ""

#: ../../pep-0673.rst:27
msgid ""
"A common use case is to write a method that returns an instance of the "
"same class, usually by returning ``self``."
msgstr ""

#: ../../pep-0673.rst:40
msgid ""
"One way to denote the return type is to specify it as the current class, "
"say, ``Shape``. Using the method makes the type checker infer the type "
"``Shape``, as expected."
msgstr ""

#: ../../pep-0673.rst:54
msgid ""
"However, when we call ``set_scale`` on a subclass of ``Shape``, the type "
"checker still infers the return type to be ``Shape``. This is problematic"
" in situations such as the one shown below, where the type checker will "
"return an error because we are trying to use attributes or methods not "
"present on the base class."
msgstr ""

#: ../../pep-0673.rst:72
msgid ""
"The present workaround for such instances is to define a ``TypeVar`` with"
" the base class as the bound and use it as the annotation for the "
"``self`` parameter and the return type:"
msgstr ""

#: ../../pep-0673.rst:95
msgid ""
"Unfortunately, this is verbose and unintuitive. Because ``self`` is "
"usually not explicitly annotated, the above solution doesn't immediately "
"come to mind, and even if it does, it is very easy to go wrong by "
"forgetting either the bound on the ``TypeVar(bound=\"Shape\")`` or the "
"annotation for ``self``."
msgstr ""

#: ../../pep-0673.rst:100
msgid ""
"This difficulty means that users often give up and either use fallback "
"types like ``Any`` or just omit the type annotation completely, both of "
"which make the code less safe."
msgstr ""

#: ../../pep-0673.rst:104
msgid ""
"We propose a more intuitive and succinct way of expressing the above "
"intention. We introduce a special form ``Self`` that stands for a type "
"variable bound to the encapsulating class. For situations such as the one"
" above, the user simply has to annotate the return type as ``Self``:"
msgstr ""

#: ../../pep-0673.rst:124
msgid ""
"By annotating the return type as ``Self``, we no longer have to declare a"
" ``TypeVar`` with an explicit bound on the base class. The return type "
"``Self`` mirrors the fact that the function returns ``self`` and is "
"easier to understand."
msgstr ""

#: ../../pep-0673.rst:129
msgid ""
"As in the above example, the type checker will correctly infer the type "
"of ``Circle().set_scale(0.5)`` to be ``Circle``, as expected."
msgstr ""

#: ../../pep-0673.rst:133
msgid "Usage statistics"
msgstr ""

#: ../../pep-0673.rst:135
msgid ""
"We `analyzed <https://github.com/pradeep90/annotation_collector/#self-"
"type-stats>`_ popular open-source projects and found that patterns like "
"the above were used about **40%** as often as popular types like ``dict``"
" or ``Callable``. For example, in typeshed alone, such “Self” types are "
"used 523 times, compared to 1286 uses of ``dict`` and 1314 uses of "
"``Callable`` `as of October 2021 "
"<https://github.com/pradeep90/annotation_collector/#overall-stats-in-"
"typeshed>`_. This suggests that a ``Self`` type will be used quite often "
"and users will benefit a lot from the simpler approach above."
msgstr ""

#: ../../pep-0673.rst:146
msgid "Specification"
msgstr ""

#: ../../pep-0673.rst:149
msgid "Use in Method Signatures"
msgstr ""

#: ../../pep-0673.rst:151
msgid ""
"``Self`` used in the signature of a method is treated as if it were a "
"``TypeVar`` bound to the class."
msgstr ""

#: ../../pep-0673.rst:163 ../../pep-0673.rst:484
msgid "is treated equivalently to:"
msgstr ""

#: ../../pep-0673.rst:176
msgid "This works the same for a subclass too:"
msgstr ""

#: ../../pep-0673.rst:185
msgid "which is treated equivalently to:"
msgstr ""

#: ../../pep-0673.rst:196
msgid ""
"One implementation strategy is to simply desugar the former to the latter"
" in a preprocessing step. If a method uses ``Self`` in its signature, the"
" type of ``self`` within a method will be ``Self``. In other cases, the "
"type of ``self`` will remain the enclosing class."
msgstr ""

#: ../../pep-0673.rst:203
msgid "Use in Classmethod Signatures"
msgstr ""

#: ../../pep-0673.rst:205
msgid ""
"The ``Self`` type annotation is also useful for classmethods that return "
"an instance of the class that they operate on. For example, "
"``from_config`` in the following snippet builds a ``Shape`` object from a"
" given ``config``."
msgstr ""

#: ../../pep-0673.rst:219
msgid ""
"However, this means that ``Circle.from_config(...)`` is inferred to "
"return a value of type ``Shape``, when in fact it should be ``Circle``:"
msgstr ""

#: ../../pep-0673.rst:236
msgid "The current workaround for this is unintuitive and error-prone:"
msgstr ""

#: ../../pep-0673.rst:249
msgid "We propose using ``Self`` directly:"
msgstr ""

#: ../../pep-0673.rst:260
msgid ""
"This avoids the complicated ``cls: type[Self]`` annotation and the "
"``TypeVar`` declaration with a ``bound``. Once again, the latter code "
"behaves equivalently to the former code."
msgstr ""

#: ../../pep-0673.rst:265
msgid "Use in Parameter Types"
msgstr ""

#: ../../pep-0673.rst:267
msgid ""
"Another use for ``Self`` is to annotate parameters that expect instances "
"of the current class:"
msgstr ""

#: ../../pep-0673.rst:279
msgid "We propose using ``Self`` directly to achieve the same behavior:"
msgstr ""

#: ../../pep-0673.rst:290
msgid ""
"Note that specifying ``self: Self`` is harmless, so some users may find "
"it more readable to write the above as:"
msgstr ""

#: ../../pep-0673.rst:299
msgid "Use in Attribute Annotations"
msgstr ""

#: ../../pep-0673.rst:301
msgid ""
"Another use for ``Self`` is to annotate attributes. One example is where "
"we have a ``LinkedList`` whose elements must be subclasses of the current"
" class."
msgstr ""

#: ../../pep-0673.rst:322
msgid ""
"However, annotating the ``next`` attribute as ``LinkedList[T]`` allows "
"invalid constructions with subclasses:"
msgstr ""

#: ../../pep-0673.rst:340
msgid "We propose expressing this constraint using ``next: Self | None``:"
msgstr ""

#: ../../pep-0673.rst:366
msgid ""
"The code above is semantically equivalent to treating each attribute "
"containing a ``Self`` type as a ``property`` that returns that type:"
msgstr ""

#: ../../pep-0673.rst:394
msgid "Use in Generic Classes"
msgstr ""

#: ../../pep-0673.rst:396
msgid "``Self`` can also be used in generic class methods:"
msgstr ""

#: ../../pep-0673.rst:405
msgid "This is equivalent to writing:"
msgstr ""

#: ../../pep-0673.rst:416
msgid ""
"The behavior is to preserve the type argument of the object on which the "
"method was called. When called on an object with concrete type "
"``Container[int]``, ``Self`` is bound to ``Container[int]``. When called "
"with an object of generic type ``Container[T]``, ``Self`` is bound to "
"``Container[T]``:"
msgstr ""

#: ../../pep-0673.rst:436
msgid ""
"The PEP doesn’t specify the exact type of ``self.value`` within the "
"method ``set_value``. Some type checkers may choose to implement ``Self``"
" types using class-local type variables with ``Self = TypeVar(“Self”, "
"bound=Container[T])``, which will infer a precise type ``T``. However, "
"given that class-local type variables are not a standardized type system "
"feature, it is also acceptable to infer ``Any`` for ``self.value``. We "
"leave this up to the type checker."
msgstr ""

#: ../../pep-0673.rst:444
msgid ""
"Note that we reject using ``Self`` with type arguments, such as "
"``Self[int]``. This is because it creates ambiguity about the type of the"
" ``self`` parameter and introduces unnecessary complexity:"
msgstr ""

#: ../../pep-0673.rst:456
msgid "In such cases, we recommend using an explicit type for ``self``:"
msgstr ""

#: ../../pep-0673.rst:469
msgid "Use in Protocols"
msgstr ""

#: ../../pep-0673.rst:471
msgid "``Self`` is valid within Protocols, similar to its use in classes:"
msgstr ""

#: ../../pep-0673.rst:500
msgid ""
"See `PEP 544 <https://www.python.org/dev/peps/pep-0544/#self-types-in-"
"protocols>`_ for details on the behavior of TypeVars bound to protocols."
msgstr ""

#: ../../pep-0673.rst:504
msgid ""
"Checking a class for compatibility with a protocol: If a protocol uses "
"``Self`` in methods or attribute annotations, then a class ``Foo`` is "
"considered compatible with the protocol if its corresponding methods and "
"attribute annotations use either ``Self`` or ``Foo`` or any of ``Foo``’s "
"subclasses. See the examples below:"
msgstr ""

#: ../../pep-0673.rst:562
msgid "Valid Locations for ``Self``"
msgstr ""

#: ../../pep-0673.rst:564
msgid ""
"A ``Self`` annotation is only valid in class contexts, and will always "
"refer to the encapsulating class. In contexts involving nested classes, "
"``Self`` will always refer to the innermost class."
msgstr ""

#: ../../pep-0673.rst:568
msgid "The following uses of ``Self`` are accepted:"
msgstr ""

#: ../../pep-0673.rst:632
msgid "The following uses of ``Self`` are rejected."
msgstr ""

#: ../../pep-0673.rst:663
msgid ""
"Note that we reject ``Self`` in staticmethods. ``Self`` does not add much"
" value since there is no ``self`` or ``cls`` to return. The only possible"
" use cases would be to return a parameter itself or some element from a "
"container passed in as a parameter. These don’t seem worth the additional"
" complexity."
msgstr ""

#: ../../pep-0673.rst:679
msgid ""
"Likewise, we reject ``Self`` in metaclasses. ``Self`` in this PEP "
"consistently refers to the same type (that of ``self``). But in "
"metaclasses, it would have to refer to different types in different "
"method signatures. For example, in ``__mul__``, ``Self`` in the return "
"type would refer to the implementing class ``Foo``, not the enclosing "
"class ``MyMetaclass``. But, in ``__new__``, ``Self`` in the return type "
"would refer to the enclosing class ``MyMetaclass``. To avoid confusion, "
"we reject this edge case."
msgstr ""

#: ../../pep-0673.rst:700
msgid "Runtime behavior"
msgstr ""

#: ../../pep-0673.rst:702
msgid ""
"Because ``Self`` is not subscriptable, we propose an implementation "
"similar to ``typing.NoReturn``."
msgstr ""

#: ../../pep-0673.rst:725
msgid "Rejected Alternatives"
msgstr ""

#: ../../pep-0673.rst:728
msgid "Allow the Type Checker to Infer the Return Type"
msgstr ""

#: ../../pep-0673.rst:730
msgid ""
"One proposal is to leave the ``Self`` type implicit and let the type "
"checker infer from the body of the method that the return type must be "
"the same as the type of the ``self`` parameter:"
msgstr ""

#: ../../pep-0673.rst:741
msgid ""
"We reject this because Explicit Is Better Than Implicit. Beyond that, the"
" above approach will fail for type stubs, which don’t have method bodies "
"to analyze."
msgstr ""

#: ../../pep-0673.rst:747
msgid "Reference Implementations"
msgstr ""

#: ../../pep-0673.rst:749
msgid ""
"Mypy: Proof of concept implementation in `Mypy "
"<https://github.com/Gobot1234/mypy>`_."
msgstr ""

#: ../../pep-0673.rst:752
msgid "Pyright: v1.1.184"
msgstr ""

#: ../../pep-0673.rst:754
msgid ""
"Runtime implementation of ``Self``: `PR "
"<https://github.com/python/typing/pull/933>`_."
msgstr ""

#: ../../pep-0673.rst:758
msgid "Resources"
msgstr ""

#: ../../pep-0673.rst:760
msgid ""
"Similar discussions on a ``Self`` type in Python started in Mypy around "
"2016: `Mypy issue #1212 <https://github.com/python/mypy/issues/1212>`_ - "
"SelfType or another way to spell \"type of self\". However, the approach "
"ultimately taken there was the bounded ``TypeVar`` approach shown in our "
"\"before\" examples. Other issues that discuss this include `Mypy issue "
"#2354 <https://github.com/python/mypy/issues/2354>`_ - Self types in "
"generic classes."
msgstr ""

#: ../../pep-0673.rst:770
msgid "Pradeep made a concrete proposal at the PyCon Typing Summit 2021:"
msgstr ""

#: ../../pep-0673.rst:769
msgid ""
"`recorded talk <https://youtu.be/ld9rwCvGdhc?t=3260>`_, `slides "
"<https://drive.google.com/file/d/1x-"
"qoDVY_OvLpIV1EwT7m3vm4HrgubHPG/view>`_."
msgstr ""

#: ../../pep-0673.rst:772
msgid ""
"James brought up the proposal independently on typing-sig: `Typing-sig "
"thread <https://mail.python.org/archives/list/typing-"
"sig@python.org/thread/SJAANGA2CWZ6D6TJ7KOPG7PZQC56K73S/#B2CBLQDHXQ5HMFUMS4VNY2D4YDCFT64Q>`_."
msgstr ""

#: ../../pep-0673.rst:775
msgid ""
"Other languages have similar ways to express the type of the enclosing "
"class:"
msgstr ""

#: ../../pep-0673.rst:777
msgid ""
"TypeScript has the ``this`` type (`TypeScript docs "
"<https://typescriptlang.org/docs/handbook/2/classes.html#this-types>`_)"
msgstr ""

#: ../../pep-0673.rst:779
msgid ""
"Rust has the ``Self`` type (`Rust docs <https://doc.rust-"
"lang.org/std/keyword.SelfTy.html>`_)"
msgstr ""

#: ../../pep-0673.rst:782
msgid "Thanks to the following people for their feedback on the PEP:"
msgstr ""

#: ../../pep-0673.rst:784
msgid ""
"Jia Chen, Rebecca Chen, Sergei Lebedev, Kaylynn Morgan, Tuomas Suutari, "
"Alex Waygood, Shannon Zhu, and Никита Соболев"
msgstr ""

#: ../../pep-0673.rst:788
msgid "Copyright"
msgstr ""

#: ../../pep-0673.rst:790
msgid ""
"This document is placed in the public domain or under the "
"CC0-1.0-Universal license, whichever is more permissive."
msgstr ""

